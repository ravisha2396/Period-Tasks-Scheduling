
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

60000000 <hyperflash_config>:
60000000:	46 43 46 42 00 04 01 56 00 00 00 00 03 03 03 03     FCFB...V........
	...
60000040:	59 00 00 00 00 08 07 00 00 00 00 00 00 00 00 00     Y...............
60000050:	00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
60000078:	10 00 10 00 00 00 00 00 a0 87 18 8b 10 8f 06 b3     ................
60000088:	04 a7 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
600001c0:	00 02 00 00 00 00 04 00 00 01 00 00 00 00 00 00     ................
600001d0:	00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

60001000 <image_vector_table>:
60001000:	d1 00 20 41 00 20 00 60 00 00 00 00 30 10 00 60     .. A. .`....0..`
60001010:	20 10 00 60 00 10 00 60 00 00 00 00 00 00 00 00      ..`...`........

60001020 <boot_data>:
60001020:	00 00 00 60 00 00 00 04 00 00 00 00 ff ff ff ff     ...`............

60001030 <dcd_data>:
60001030:	d2 04 10 41 cc 03 8c 04 40 0f c0 68 ff ff ff ff     ...A....@..h....
60001040:	40 0f c0 6c ff ff ff ff 40 0f c0 70 ff ff ff ff     @..l....@..p....
60001050:	40 0f c0 74 ff ff ff ff 40 0f c0 78 ff ff ff ff     @..t....@..x....
60001060:	40 0f c0 7c ff ff ff ff 40 0f c0 80 ff ff ff ff     @..|....@.......
60001070:	40 0d 80 30 00 00 20 01 40 0d 81 00 00 1d 00 00     @..0.. .@.......
60001080:	40 0f c0 14 00 01 0d 40 40 1f 80 14 00 00 00 00     @......@@.......
60001090:	40 1f 80 18 00 00 00 00 40 1f 80 1c 00 00 00 00     @.......@.......
600010a0:	40 1f 80 20 00 00 00 00 40 1f 80 24 00 00 00 00     @.. ....@..$....
600010b0:	40 1f 80 28 00 00 00 00 40 1f 80 2c 00 00 00 00     @..(....@..,....
600010c0:	40 1f 80 30 00 00 00 00 40 1f 80 34 00 00 00 00     @..0....@..4....
600010d0:	40 1f 80 38 00 00 00 00 40 1f 80 3c 00 00 00 00     @..8....@..<....
600010e0:	40 1f 80 40 00 00 00 00 40 1f 80 44 00 00 00 00     @..@....@..D....
600010f0:	40 1f 80 48 00 00 00 00 40 1f 80 4c 00 00 00 00     @..H....@..L....
60001100:	40 1f 80 50 00 00 00 00 40 1f 80 54 00 00 00 00     @..P....@..T....
60001110:	40 1f 80 58 00 00 00 00 40 1f 80 5c 00 00 00 00     @..X....@..\....
60001120:	40 1f 80 60 00 00 00 00 40 1f 80 64 00 00 00 00     @..`....@..d....
60001130:	40 1f 80 68 00 00 00 00 40 1f 80 6c 00 00 00 00     @..h....@..l....
60001140:	40 1f 80 70 00 00 00 00 40 1f 80 74 00 00 00 00     @..p....@..t....
60001150:	40 1f 80 78 00 00 00 00 40 1f 80 7c 00 00 00 00     @..x....@..|....
60001160:	40 1f 80 80 00 00 00 00 40 1f 80 84 00 00 00 00     @.......@.......
60001170:	40 1f 80 88 00 00 00 00 40 1f 80 8c 00 00 00 00     @.......@.......
60001180:	40 1f 80 90 00 00 00 00 40 1f 80 94 00 00 00 00     @.......@.......
60001190:	40 1f 80 98 00 00 00 00 40 1f 80 9c 00 00 00 00     @.......@.......
600011a0:	40 1f 80 a0 00 00 00 00 40 1f 80 a4 00 00 00 00     @.......@.......
600011b0:	40 1f 80 a8 00 00 00 00 40 1f 80 ac 00 00 00 00     @.......@.......
600011c0:	40 1f 80 b0 00 00 00 10 40 1f 82 04 00 01 10 f9     @.......@.......
600011d0:	40 1f 82 08 00 01 10 f9 40 1f 82 0c 00 01 10 f9     @.......@.......
600011e0:	40 1f 82 10 00 01 10 f9 40 1f 82 14 00 01 10 f9     @.......@.......
600011f0:	40 1f 82 18 00 01 10 f9 40 1f 82 1c 00 01 10 f9     @.......@.......
60001200:	40 1f 82 20 00 01 10 f9 40 1f 82 24 00 01 10 f9     @.. ....@..$....
60001210:	40 1f 82 28 00 01 10 f9 40 1f 82 2c 00 01 10 f9     @..(....@..,....
60001220:	40 1f 82 30 00 01 10 f9 40 1f 82 34 00 01 10 f9     @..0....@..4....
60001230:	40 1f 82 38 00 01 10 f9 40 1f 82 3c 00 01 10 f9     @..8....@..<....
60001240:	40 1f 82 40 00 01 10 f9 40 1f 82 44 00 01 10 f9     @..@....@..D....
60001250:	40 1f 82 48 00 01 10 f9 40 1f 82 4c 00 01 10 f9     @..H....@..L....
60001260:	40 1f 82 50 00 01 10 f9 40 1f 82 54 00 01 10 f9     @..P....@..T....
60001270:	40 1f 82 58 00 01 10 f9 40 1f 82 5c 00 01 10 f9     @..X....@..\....
60001280:	40 1f 82 60 00 01 10 f9 40 1f 82 64 00 01 10 f9     @..`....@..d....
60001290:	40 1f 82 68 00 01 10 f9 40 1f 82 6c 00 01 10 f9     @..h....@..l....
600012a0:	40 1f 82 70 00 01 10 f9 40 1f 82 74 00 01 10 f9     @..p....@..t....
600012b0:	40 1f 82 78 00 01 10 f9 40 1f 82 7c 00 01 10 f9     @..x....@..|....
600012c0:	40 1f 82 80 00 01 10 f9 40 1f 82 84 00 01 10 f9     @.......@.......
600012d0:	40 1f 82 88 00 01 10 f9 40 1f 82 8c 00 01 10 f9     @.......@.......
600012e0:	40 1f 82 90 00 01 10 f9 40 1f 82 94 00 01 10 f9     @.......@.......
600012f0:	40 1f 82 98 00 01 10 f9 40 1f 82 9c 00 01 10 f9     @.......@.......
60001300:	40 1f 82 a0 00 01 10 f9 40 2f 00 00 10 00 00 04     @.......@/......
60001310:	40 2f 00 08 00 03 05 24 40 2f 00 0c 06 03 05 24     @/.....$@/.....$
60001320:	40 2f 00 10 80 00 00 1b 40 2f 00 14 82 00 00 1b     @/......@/......
60001330:	40 2f 00 18 84 00 00 1b 40 2f 00 1c 86 00 00 1b     @/......@/......
60001340:	40 2f 00 20 90 00 00 21 40 2f 00 24 a0 00 00 19     @/. ...!@/.$....
60001350:	40 2f 00 28 a8 00 00 17 40 2f 00 2c a9 00 00 1b     @/.(....@/.,....
60001360:	40 2f 00 30 00 00 00 21 40 2f 00 04 00 00 79 a8     @/.0...!@/....y.
60001370:	40 2f 00 40 00 00 0f 31 40 2f 00 44 00 65 29 22     @/.@...1@/.D.e)"
60001380:	40 2f 00 48 00 01 09 20 40 2f 00 4c 50 21 0a 08     @/.H... @/.LP!..
60001390:	40 2f 00 80 00 00 00 21 40 2f 00 84 00 88 88 88     @/.....!@/......
600013a0:	40 2f 00 94 00 00 00 02 40 2f 00 98 00 00 00 00     @/......@/......
600013b0:	40 2f 00 90 80 00 00 00 40 2f 00 9c a5 5a 00 0f     @/......@/...Z..
600013c0:	cf 00 0c 1c 40 2f 00 3c 00 00 00 01 cc 00 14 04     ....@/.<........
600013d0:	40 2f 00 90 80 00 00 00 40 2f 00 9c a5 5a 00 0c     @/......@/...Z..
600013e0:	cf 00 0c 1c 40 2f 00 3c 00 00 00 01 cc 00 14 04     ....@/.<........
600013f0:	40 2f 00 90 80 00 00 00 40 2f 00 9c a5 5a 00 0c     @/......@/...Z..
60001400:	cf 00 0c 1c 40 2f 00 3c 00 00 00 01 cc 00 1c 04     ....@/.<........
60001410:	40 2f 00 a0 00 00 00 33 40 2f 00 90 80 00 00 00     @/.....3@/......
60001420:	40 2f 00 9c a5 5a 00 0a cf 00 0c 1c 40 2f 00 3c     @/...Z......@/.<
60001430:	00 00 00 01 cc 00 0c 04 40 2f 00 4c 50 21 0a 09     ........@/.LP!..
	...

60002000 <_vector_table>:
60002000:	60 30 00 80 ad 62 00 60 07 b8 00 60 e5 62 00 60     `0...b.`...`.b.`
60002010:	e5 62 00 60 e5 62 00 60 e5 62 00 60 00 00 00 00     .b.`.b.`.b.`....
	...
6000202c:	79 60 00 60 e5 62 00 60 00 00 00 00 0d 60 00 60     y`.`.b.`.....`.`
6000203c:	15 5e 00 60                                         .^.`

60002040 <_irq_vector_table>:
60002040:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002050:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002060:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002070:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002080:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002090:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600020a0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600020b0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600020c0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600020d0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600020e0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600020f0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002100:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002110:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002120:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002130:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002140:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002150:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002160:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002170:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002180:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002190:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600021a0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600021b0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600021c0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600021d0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600021e0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600021f0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002200:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002210:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002220:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002230:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002240:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002250:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002260:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002270:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002280:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
60002290:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600022a0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`
600022b0:	7d 62 00 60 7d 62 00 60 7d 62 00 60 7d 62 00 60     }b.`}b.`}b.`}b.`

Disassembly of section text:

600022c0 <__aeabi_uldivmod>:
600022c0:	b953      	cbnz	r3, 600022d8 <__aeabi_uldivmod+0x18>
600022c2:	b94a      	cbnz	r2, 600022d8 <__aeabi_uldivmod+0x18>
600022c4:	2900      	cmp	r1, #0
600022c6:	bf08      	it	eq
600022c8:	2800      	cmpeq	r0, #0
600022ca:	bf1c      	itt	ne
600022cc:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
600022d0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
600022d4:	f000 b80c 	b.w	600022f0 <__aeabi_idiv0>
600022d8:	f1ad 0c08 	sub.w	ip, sp, #8
600022dc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
600022e0:	f000 f808 	bl	600022f4 <__udivmoddi4>
600022e4:	f8dd e004 	ldr.w	lr, [sp, #4]
600022e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
600022ec:	b004      	add	sp, #16
600022ee:	4770      	bx	lr

600022f0 <__aeabi_idiv0>:
600022f0:	4770      	bx	lr
600022f2:	bf00      	nop

600022f4 <__udivmoddi4>:
600022f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
600022f8:	4607      	mov	r7, r0
600022fa:	468c      	mov	ip, r1
600022fc:	4608      	mov	r0, r1
600022fe:	9e09      	ldr	r6, [sp, #36]	; 0x24
60002300:	4615      	mov	r5, r2
60002302:	463c      	mov	r4, r7
60002304:	4619      	mov	r1, r3
60002306:	2b00      	cmp	r3, #0
60002308:	f040 80c6 	bne.w	60002498 <__udivmoddi4+0x1a4>
6000230c:	4282      	cmp	r2, r0
6000230e:	fab2 f782 	clz	r7, r2
60002312:	d946      	bls.n	600023a2 <__udivmoddi4+0xae>
60002314:	b14f      	cbz	r7, 6000232a <__udivmoddi4+0x36>
60002316:	f1c7 0e20 	rsb	lr, r7, #32
6000231a:	fa24 fe0e 	lsr.w	lr, r4, lr
6000231e:	fa00 f307 	lsl.w	r3, r0, r7
60002322:	40bd      	lsls	r5, r7
60002324:	ea4e 0c03 	orr.w	ip, lr, r3
60002328:	40bc      	lsls	r4, r7
6000232a:	ea4f 4815 	mov.w	r8, r5, lsr #16
6000232e:	fa1f fe85 	uxth.w	lr, r5
60002332:	fbbc f9f8 	udiv	r9, ip, r8
60002336:	0c22      	lsrs	r2, r4, #16
60002338:	fb08 c319 	mls	r3, r8, r9, ip
6000233c:	fb09 fa0e 	mul.w	sl, r9, lr
60002340:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
60002344:	459a      	cmp	sl, r3
60002346:	d928      	bls.n	6000239a <__udivmoddi4+0xa6>
60002348:	18eb      	adds	r3, r5, r3
6000234a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
6000234e:	d204      	bcs.n	6000235a <__udivmoddi4+0x66>
60002350:	459a      	cmp	sl, r3
60002352:	d902      	bls.n	6000235a <__udivmoddi4+0x66>
60002354:	f1a9 0002 	sub.w	r0, r9, #2
60002358:	442b      	add	r3, r5
6000235a:	eba3 030a 	sub.w	r3, r3, sl
6000235e:	b2a4      	uxth	r4, r4
60002360:	fbb3 f2f8 	udiv	r2, r3, r8
60002364:	fb08 3312 	mls	r3, r8, r2, r3
60002368:	fb02 fe0e 	mul.w	lr, r2, lr
6000236c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
60002370:	45a6      	cmp	lr, r4
60002372:	d914      	bls.n	6000239e <__udivmoddi4+0xaa>
60002374:	192c      	adds	r4, r5, r4
60002376:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
6000237a:	d203      	bcs.n	60002384 <__udivmoddi4+0x90>
6000237c:	45a6      	cmp	lr, r4
6000237e:	d901      	bls.n	60002384 <__udivmoddi4+0x90>
60002380:	1e93      	subs	r3, r2, #2
60002382:	442c      	add	r4, r5
60002384:	eba4 040e 	sub.w	r4, r4, lr
60002388:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
6000238c:	b11e      	cbz	r6, 60002396 <__udivmoddi4+0xa2>
6000238e:	40fc      	lsrs	r4, r7
60002390:	2300      	movs	r3, #0
60002392:	6034      	str	r4, [r6, #0]
60002394:	6073      	str	r3, [r6, #4]
60002396:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
6000239a:	4648      	mov	r0, r9
6000239c:	e7dd      	b.n	6000235a <__udivmoddi4+0x66>
6000239e:	4613      	mov	r3, r2
600023a0:	e7f0      	b.n	60002384 <__udivmoddi4+0x90>
600023a2:	b902      	cbnz	r2, 600023a6 <__udivmoddi4+0xb2>
600023a4:	deff      	udf	#255	; 0xff
600023a6:	bb87      	cbnz	r7, 6000240a <__udivmoddi4+0x116>
600023a8:	1a83      	subs	r3, r0, r2
600023aa:	2101      	movs	r1, #1
600023ac:	ea4f 4e15 	mov.w	lr, r5, lsr #16
600023b0:	b2aa      	uxth	r2, r5
600023b2:	fbb3 fcfe 	udiv	ip, r3, lr
600023b6:	0c20      	lsrs	r0, r4, #16
600023b8:	fb0e 331c 	mls	r3, lr, ip, r3
600023bc:	fb0c f802 	mul.w	r8, ip, r2
600023c0:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
600023c4:	4598      	cmp	r8, r3
600023c6:	d963      	bls.n	60002490 <__udivmoddi4+0x19c>
600023c8:	18eb      	adds	r3, r5, r3
600023ca:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
600023ce:	d204      	bcs.n	600023da <__udivmoddi4+0xe6>
600023d0:	4598      	cmp	r8, r3
600023d2:	d902      	bls.n	600023da <__udivmoddi4+0xe6>
600023d4:	f1ac 0002 	sub.w	r0, ip, #2
600023d8:	442b      	add	r3, r5
600023da:	eba3 0308 	sub.w	r3, r3, r8
600023de:	b2a4      	uxth	r4, r4
600023e0:	fbb3 fcfe 	udiv	ip, r3, lr
600023e4:	fb0e 331c 	mls	r3, lr, ip, r3
600023e8:	fb0c f202 	mul.w	r2, ip, r2
600023ec:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
600023f0:	42a2      	cmp	r2, r4
600023f2:	d94f      	bls.n	60002494 <__udivmoddi4+0x1a0>
600023f4:	192c      	adds	r4, r5, r4
600023f6:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
600023fa:	d204      	bcs.n	60002406 <__udivmoddi4+0x112>
600023fc:	42a2      	cmp	r2, r4
600023fe:	d902      	bls.n	60002406 <__udivmoddi4+0x112>
60002400:	f1ac 0302 	sub.w	r3, ip, #2
60002404:	442c      	add	r4, r5
60002406:	1aa4      	subs	r4, r4, r2
60002408:	e7be      	b.n	60002388 <__udivmoddi4+0x94>
6000240a:	f1c7 0c20 	rsb	ip, r7, #32
6000240e:	fa20 f80c 	lsr.w	r8, r0, ip
60002412:	fa00 f307 	lsl.w	r3, r0, r7
60002416:	fa24 fc0c 	lsr.w	ip, r4, ip
6000241a:	40bd      	lsls	r5, r7
6000241c:	ea4c 0203 	orr.w	r2, ip, r3
60002420:	ea4f 4e15 	mov.w	lr, r5, lsr #16
60002424:	b2ab      	uxth	r3, r5
60002426:	fbb8 fcfe 	udiv	ip, r8, lr
6000242a:	0c11      	lsrs	r1, r2, #16
6000242c:	fb0e 801c 	mls	r0, lr, ip, r8
60002430:	fb0c f903 	mul.w	r9, ip, r3
60002434:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
60002438:	4581      	cmp	r9, r0
6000243a:	fa04 f407 	lsl.w	r4, r4, r7
6000243e:	d923      	bls.n	60002488 <__udivmoddi4+0x194>
60002440:	1828      	adds	r0, r5, r0
60002442:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
60002446:	d204      	bcs.n	60002452 <__udivmoddi4+0x15e>
60002448:	4581      	cmp	r9, r0
6000244a:	d902      	bls.n	60002452 <__udivmoddi4+0x15e>
6000244c:	f1ac 0102 	sub.w	r1, ip, #2
60002450:	4428      	add	r0, r5
60002452:	eba0 0009 	sub.w	r0, r0, r9
60002456:	b292      	uxth	r2, r2
60002458:	fbb0 fcfe 	udiv	ip, r0, lr
6000245c:	fb0e 001c 	mls	r0, lr, ip, r0
60002460:	fb0c f803 	mul.w	r8, ip, r3
60002464:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
60002468:	4598      	cmp	r8, r3
6000246a:	d90f      	bls.n	6000248c <__udivmoddi4+0x198>
6000246c:	18eb      	adds	r3, r5, r3
6000246e:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
60002472:	d204      	bcs.n	6000247e <__udivmoddi4+0x18a>
60002474:	4598      	cmp	r8, r3
60002476:	d902      	bls.n	6000247e <__udivmoddi4+0x18a>
60002478:	f1ac 0202 	sub.w	r2, ip, #2
6000247c:	442b      	add	r3, r5
6000247e:	eba3 0308 	sub.w	r3, r3, r8
60002482:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
60002486:	e791      	b.n	600023ac <__udivmoddi4+0xb8>
60002488:	4661      	mov	r1, ip
6000248a:	e7e2      	b.n	60002452 <__udivmoddi4+0x15e>
6000248c:	4662      	mov	r2, ip
6000248e:	e7f6      	b.n	6000247e <__udivmoddi4+0x18a>
60002490:	4660      	mov	r0, ip
60002492:	e7a2      	b.n	600023da <__udivmoddi4+0xe6>
60002494:	4663      	mov	r3, ip
60002496:	e7b6      	b.n	60002406 <__udivmoddi4+0x112>
60002498:	4283      	cmp	r3, r0
6000249a:	d905      	bls.n	600024a8 <__udivmoddi4+0x1b4>
6000249c:	b10e      	cbz	r6, 600024a2 <__udivmoddi4+0x1ae>
6000249e:	e9c6 7000 	strd	r7, r0, [r6]
600024a2:	2100      	movs	r1, #0
600024a4:	4608      	mov	r0, r1
600024a6:	e776      	b.n	60002396 <__udivmoddi4+0xa2>
600024a8:	fab3 f183 	clz	r1, r3
600024ac:	b981      	cbnz	r1, 600024d0 <__udivmoddi4+0x1dc>
600024ae:	4283      	cmp	r3, r0
600024b0:	d301      	bcc.n	600024b6 <__udivmoddi4+0x1c2>
600024b2:	42ba      	cmp	r2, r7
600024b4:	d80a      	bhi.n	600024cc <__udivmoddi4+0x1d8>
600024b6:	1abc      	subs	r4, r7, r2
600024b8:	eb60 0303 	sbc.w	r3, r0, r3
600024bc:	2001      	movs	r0, #1
600024be:	469c      	mov	ip, r3
600024c0:	2e00      	cmp	r6, #0
600024c2:	d068      	beq.n	60002596 <__udivmoddi4+0x2a2>
600024c4:	e9c6 4c00 	strd	r4, ip, [r6]
600024c8:	2100      	movs	r1, #0
600024ca:	e764      	b.n	60002396 <__udivmoddi4+0xa2>
600024cc:	4608      	mov	r0, r1
600024ce:	e7f7      	b.n	600024c0 <__udivmoddi4+0x1cc>
600024d0:	f1c1 0c20 	rsb	ip, r1, #32
600024d4:	408b      	lsls	r3, r1
600024d6:	fa22 f40c 	lsr.w	r4, r2, ip
600024da:	431c      	orrs	r4, r3
600024dc:	fa02 f501 	lsl.w	r5, r2, r1
600024e0:	fa00 f301 	lsl.w	r3, r0, r1
600024e4:	fa27 f20c 	lsr.w	r2, r7, ip
600024e8:	fa20 fb0c 	lsr.w	fp, r0, ip
600024ec:	ea4f 4914 	mov.w	r9, r4, lsr #16
600024f0:	4313      	orrs	r3, r2
600024f2:	fbbb f8f9 	udiv	r8, fp, r9
600024f6:	fa1f fe84 	uxth.w	lr, r4
600024fa:	fb09 bb18 	mls	fp, r9, r8, fp
600024fe:	0c1a      	lsrs	r2, r3, #16
60002500:	fb08 fa0e 	mul.w	sl, r8, lr
60002504:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
60002508:	4592      	cmp	sl, r2
6000250a:	fa07 f701 	lsl.w	r7, r7, r1
6000250e:	d93e      	bls.n	6000258e <__udivmoddi4+0x29a>
60002510:	18a2      	adds	r2, r4, r2
60002512:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
60002516:	d204      	bcs.n	60002522 <__udivmoddi4+0x22e>
60002518:	4592      	cmp	sl, r2
6000251a:	d902      	bls.n	60002522 <__udivmoddi4+0x22e>
6000251c:	f1a8 0002 	sub.w	r0, r8, #2
60002520:	4422      	add	r2, r4
60002522:	eba2 020a 	sub.w	r2, r2, sl
60002526:	b29b      	uxth	r3, r3
60002528:	fbb2 f8f9 	udiv	r8, r2, r9
6000252c:	fb09 2218 	mls	r2, r9, r8, r2
60002530:	fb08 fe0e 	mul.w	lr, r8, lr
60002534:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
60002538:	4596      	cmp	lr, r2
6000253a:	d92a      	bls.n	60002592 <__udivmoddi4+0x29e>
6000253c:	18a2      	adds	r2, r4, r2
6000253e:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
60002542:	d204      	bcs.n	6000254e <__udivmoddi4+0x25a>
60002544:	4596      	cmp	lr, r2
60002546:	d902      	bls.n	6000254e <__udivmoddi4+0x25a>
60002548:	f1a8 0302 	sub.w	r3, r8, #2
6000254c:	4422      	add	r2, r4
6000254e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
60002552:	fba0 9305 	umull	r9, r3, r0, r5
60002556:	eba2 020e 	sub.w	r2, r2, lr
6000255a:	429a      	cmp	r2, r3
6000255c:	46ce      	mov	lr, r9
6000255e:	4698      	mov	r8, r3
60002560:	d302      	bcc.n	60002568 <__udivmoddi4+0x274>
60002562:	d106      	bne.n	60002572 <__udivmoddi4+0x27e>
60002564:	454f      	cmp	r7, r9
60002566:	d204      	bcs.n	60002572 <__udivmoddi4+0x27e>
60002568:	ebb9 0e05 	subs.w	lr, r9, r5
6000256c:	eb63 0804 	sbc.w	r8, r3, r4
60002570:	3801      	subs	r0, #1
60002572:	b186      	cbz	r6, 60002596 <__udivmoddi4+0x2a2>
60002574:	ebb7 030e 	subs.w	r3, r7, lr
60002578:	eb62 0708 	sbc.w	r7, r2, r8
6000257c:	fa07 fc0c 	lsl.w	ip, r7, ip
60002580:	40cb      	lsrs	r3, r1
60002582:	ea4c 0303 	orr.w	r3, ip, r3
60002586:	40cf      	lsrs	r7, r1
60002588:	e9c6 3700 	strd	r3, r7, [r6]
6000258c:	e79c      	b.n	600024c8 <__udivmoddi4+0x1d4>
6000258e:	4640      	mov	r0, r8
60002590:	e7c7      	b.n	60002522 <__udivmoddi4+0x22e>
60002592:	4643      	mov	r3, r8
60002594:	e7db      	b.n	6000254e <__udivmoddi4+0x25a>
60002596:	4631      	mov	r1, r6
60002598:	e6fd      	b.n	60002396 <__udivmoddi4+0xa2>
	...

6000259c <cmd_activate>:
	static bool DONE=true;
	
	struct k_sem com_sem;	
	struct k_sem sem[NUM_THREADS];
			
static int cmd_activate(const struct shell *shell, size_t argc, char **argv){	
6000259c:	b508      	push	{r3, lr}
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
6000259e:	4802      	ldr	r0, [pc, #8]	; (600025a8 <cmd_activate+0xc>)
600025a0:	f006 f926 	bl	600087f0 <z_impl_k_sem_give>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	k_sem_give(&com_sem);		
	return 0;
}
600025a4:	2000      	movs	r0, #0
600025a6:	bd08      	pop	{r3, pc}
600025a8:	800009c8 	.word	0x800009c8

600025ac <thread_entry>:
	while(n>0){ 
		n--;
		}
}

void thread_entry(void *dummy1, void *dummy2, void *dummy3){
600025ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
600025b0:	b093      	sub	sp, #76	; 0x4c
	
	struct  task_s *t = (struct task_s*)dummy1;
	
	int num;
	num = *((int *)dummy2);
600025b2:	680b      	ldr	r3, [r1, #0]
void thread_entry(void *dummy1, void *dummy2, void *dummy3){
600025b4:	4604      	mov	r4, r0
	
	struct k_timer th_timer;
	k_timer_init(&th_timer, thread_expiry, NULL);
600025b6:	2200      	movs	r2, #0
600025b8:	a804      	add	r0, sp, #16
600025ba:	4925      	ldr	r1, [pc, #148]	; (60002650 <thread_entry+0xa4>)
	num = *((int *)dummy2);
600025bc:	9303      	str	r3, [sp, #12]
	k_timer_init(&th_timer, thread_expiry, NULL);
600025be:	f009 ffc3 	bl	6000c548 <k_timer_init>

	th_timer.user_data = &num;
600025c2:	ab03      	add	r3, sp, #12
	
	ARG_UNUSED(dummy3);
	k_sem_take(&sem[num],K_FOREVER);
600025c4:	4d23      	ldr	r5, [pc, #140]	; (60002654 <thread_entry+0xa8>)
600025c6:	9803      	ldr	r0, [sp, #12]
	th_timer.user_data = &num;
600025c8:	9311      	str	r3, [sp, #68]	; 0x44
	k_sem_take(&sem[num],K_FOREVER);
600025ca:	2318      	movs	r3, #24
600025cc:	fb03 5000 	mla	r0, r3, r0, r5
	return z_impl_k_sem_take(sem, timeout);
600025d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
600025d4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
600025d8:	f006 f938 	bl	6000884c <z_impl_k_sem_take>
	k_timer_start(&th_timer, K_MSEC(t->period), K_MSEC(t->period));
600025dc:	6a62      	ldr	r2, [r4, #36]	; 0x24
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * (to_hz / from_hz);
600025de:	230a      	movs	r3, #10
600025e0:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
600025e4:	fb82 2303 	smull	r2, r3, r2, r3
	while(DONE==true){
600025e8:	4f1b      	ldr	r7, [pc, #108]	; (60002658 <thread_entry+0xac>)
	z_impl_k_timer_start(timer, duration, period);
600025ea:	a804      	add	r0, sp, #16

		compute(t->loop_iter[0]);

		//printk("Completed compute 1\n");

		k_mutex_lock(&m[t->mutex_m], K_FOREVER);		
600025ec:	4e1b      	ldr	r6, [pc, #108]	; (6000265c <thread_entry+0xb0>)
		compute(t->loop_iter[2]);

		//printk("Completed compute 3\n");

		if(k_timer_status_get(&th_timer)>0){
			printk("Task missed deadline\n");
600025ee:	f8df 8070 	ldr.w	r8, [pc, #112]	; 60002660 <thread_entry+0xb4>
600025f2:	e9cd 2300 	strd	r2, r3, [sp]
600025f6:	f006 ff17 	bl	60009428 <z_impl_k_timer_start>
	while(DONE==true){
600025fa:	783b      	ldrb	r3, [r7, #0]
600025fc:	b92b      	cbnz	r3, 6000260a <thread_entry+0x5e>
	z_impl_k_timer_stop(timer);
600025fe:	a804      	add	r0, sp, #16
60002600:	f009 ffb4 	bl	6000c56c <z_impl_k_timer_stop>
		}	
		k_sem_take(&sem[num],K_FOREVER);		
	}
	k_timer_stop(&th_timer);			
}
60002604:	b013      	add	sp, #76	; 0x4c
60002606:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		k_mutex_lock(&m[t->mutex_m], K_FOREVER);		
6000260a:	6b60      	ldr	r0, [r4, #52]	; 0x34
6000260c:	f04f 0914 	mov.w	r9, #20
60002610:	fb09 6000 	mla	r0, r9, r0, r6
	return z_impl_k_mutex_lock(mutex, timeout);
60002614:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60002618:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
6000261c:	f006 f80a 	bl	60008634 <z_impl_k_mutex_lock>
		k_mutex_unlock(&m[t->mutex_m]);
60002620:	6b60      	ldr	r0, [r4, #52]	; 0x34
60002622:	fb09 6000 	mla	r0, r9, r0, r6
	return z_impl_k_mutex_unlock(mutex);
60002626:	f006 f88f 	bl	60008748 <z_impl_k_mutex_unlock>
	return z_impl_k_timer_status_get(timer);
6000262a:	a804      	add	r0, sp, #16
6000262c:	f009 ffc0 	bl	6000c5b0 <z_impl_k_timer_status_get>
		if(k_timer_status_get(&th_timer)>0){
60002630:	b110      	cbz	r0, 60002638 <thread_entry+0x8c>
			printk("Task missed deadline\n");
60002632:	4640      	mov	r0, r8
60002634:	f007 f94f 	bl	600098d6 <printk>
		k_sem_take(&sem[num],K_FOREVER);		
60002638:	9803      	ldr	r0, [sp, #12]
6000263a:	2318      	movs	r3, #24
6000263c:	fb03 5000 	mla	r0, r3, r0, r5
	return z_impl_k_sem_take(sem, timeout);
60002640:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60002644:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60002648:	f006 f900 	bl	6000884c <z_impl_k_sem_take>
6000264c:	e7d5      	b.n	600025fa <thread_entry+0x4e>
6000264e:	bf00      	nop
60002650:	60002665 	.word	0x60002665
60002654:	80000a1c 	.word	0x80000a1c
60002658:	80000170 	.word	0x80000170
6000265c:	800009e0 	.word	0x800009e0
60002660:	6000d716 	.word	0x6000d716

60002664 <thread_expiry>:
	int id = *((int *)timer_id->user_data);
60002664:	6b43      	ldr	r3, [r0, #52]	; 0x34
	k_sem_give(&sem[id]);
60002666:	2218      	movs	r2, #24
60002668:	4802      	ldr	r0, [pc, #8]	; (60002674 <thread_expiry+0x10>)
6000266a:	681b      	ldr	r3, [r3, #0]
6000266c:	fb02 0003 	mla	r0, r2, r3, r0
	z_impl_k_sem_give(sem);
60002670:	f006 b8be 	b.w	600087f0 <z_impl_k_sem_give>
60002674:	80000a1c 	.word	0x80000a1c

60002678 <main>:


void main(void)
{	
60002678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int thread_number[NUM_THREADS];
	printk("Inside main!\n");
6000267c:	483b      	ldr	r0, [pc, #236]	; (6000276c <main+0xf4>)
{	
6000267e:	b08d      	sub	sp, #52	; 0x34
	printk("Inside main!\n");
60002680:	f007 f929 	bl	600098d6 <printk>
	return z_impl_k_sem_init(sem, initial_count, limit);
60002684:	2201      	movs	r2, #1
60002686:	2100      	movs	r1, #0
60002688:	4839      	ldr	r0, [pc, #228]	; (60002770 <main+0xf8>)
6000268a:	f009 fe04 	bl	6000c296 <z_impl_k_sem_init>
	return z_impl_k_mutex_init(mutex);
6000268e:	4839      	ldr	r0, [pc, #228]	; (60002774 <main+0xfc>)
60002690:	f009 fdf4 	bl	6000c27c <z_impl_k_mutex_init>
60002694:	4838      	ldr	r0, [pc, #224]	; (60002778 <main+0x100>)
60002696:	f009 fdf1 	bl	6000c27c <z_impl_k_mutex_init>
6000269a:	4838      	ldr	r0, [pc, #224]	; (6000277c <main+0x104>)
6000269c:	f10d 0920 	add.w	r9, sp, #32
600026a0:	f009 fdec 	bl	6000c27c <z_impl_k_mutex_init>
	
	k_sem_init(&com_sem,0,1);
	
	for(int i=0;i<NUM_MUTEXES;i++){
600026a4:	4e36      	ldr	r6, [pc, #216]	; (60002780 <main+0x108>)
600026a6:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 60002784 <main+0x10c>
		k_mutex_init(&m[i]);	
	}
	
	for(int i=0;i<NUM_THREADS;i++){
600026aa:	2500      	movs	r5, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
600026ac:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 60002788 <main+0x110>
600026b0:	4b36      	ldr	r3, [pc, #216]	; (6000278c <main+0x114>)
		
		thread_number[i] = i;	
600026b2:	4f37      	ldr	r7, [pc, #220]	; (60002790 <main+0x118>)
		
		t_arr[i]=k_thread_create(&thread_data[i], arr[i], STACKSIZE, thread_entry, &threads[i], &thread_number[i], NULL, threads[i].priority, 0, K_FOREVER);
600026b4:	6a32      	ldr	r2, [r6, #32]
		thread_number[i] = i;	
600026b6:	f8c9 5000 	str.w	r5, [r9]
600026ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
600026be:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
600026c2:	2400      	movs	r4, #0
600026c4:	9600      	str	r6, [sp, #0]
600026c6:	e9cd 0106 	strd	r0, r1, [sp, #24]
600026ca:	f44f 6184 	mov.w	r1, #1056	; 0x420
600026ce:	20c0      	movs	r0, #192	; 0xc0
600026d0:	e9cd 2403 	strd	r2, r4, [sp, #12]
600026d4:	fb01 b105 	mla	r1, r1, r5, fp
600026d8:	f44f 6280 	mov.w	r2, #1024	; 0x400
600026dc:	fb00 7005 	mla	r0, r0, r5, r7
600026e0:	e9cd 9401 	strd	r9, r4, [sp, #4]
600026e4:	f005 fe7c 	bl	600083e0 <z_impl_k_thread_create>
		t_arr[i]=k_thread_create(&thread_data[i], arr[i], STACKSIZE, thread_entry, &threads[i], &thread_number[i], NULL, threads[i].priority, 0, K_FOREVER);
600026e8:	f8ca 0000 	str.w	r0, [sl]
	return z_impl_k_thread_name_set(thread, str);
600026ec:	4631      	mov	r1, r6
600026ee:	f005 fdb3 	bl	60008258 <z_impl_k_thread_name_set>
		#if PIN_THREADS
		k_thread_cpu_mask_clear(t_arr[i]);
		k_thread_cpu_mask_enable(t_arr[i],0);
		#endif
		
		k_thread_start(t_arr[i]);
600026f2:	f85a 0b04 	ldr.w	r0, [sl], #4
	z_impl_k_thread_start(thread);
600026f6:	f009 fd76 	bl	6000c1e6 <z_impl_k_thread_start>
		k_sem_init(&sem[i],0,1);
600026fa:	f8df 8098 	ldr.w	r8, [pc, #152]	; 60002794 <main+0x11c>
	return z_impl_k_sem_init(sem, initial_count, limit);
600026fe:	2018      	movs	r0, #24
60002700:	2201      	movs	r2, #1
60002702:	4621      	mov	r1, r4
	for(int i=0;i<NUM_THREADS;i++){
60002704:	f109 0904 	add.w	r9, r9, #4
60002708:	fb00 8005 	mla	r0, r0, r5, r8
6000270c:	3501      	adds	r5, #1
6000270e:	f009 fdc2 	bl	6000c296 <z_impl_k_sem_init>
60002712:	3638      	adds	r6, #56	; 0x38
60002714:	2d04      	cmp	r5, #4
60002716:	4b1d      	ldr	r3, [pc, #116]	; (6000278c <main+0x114>)
60002718:	d1cb      	bne.n	600026b2 <main+0x3a>

	}
	
	DONE=true;
6000271a:	4d1f      	ldr	r5, [pc, #124]	; (60002798 <main+0x120>)
6000271c:	2301      	movs	r3, #1
6000271e:	702b      	strb	r3, [r5, #0]
	return z_impl_k_sem_take(sem, timeout);
60002720:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60002724:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60002728:	4811      	ldr	r0, [pc, #68]	; (60002770 <main+0xf8>)
6000272a:	f006 f88f 	bl	6000884c <z_impl_k_sem_take>

	k_sem_take(&com_sem, K_FOREVER);
	for(int i=0;i<NUM_THREADS;i++){
6000272e:	3401      	adds	r4, #1
	z_impl_k_sem_give(sem);
60002730:	4640      	mov	r0, r8
60002732:	f006 f85d 	bl	600087f0 <z_impl_k_sem_give>
60002736:	f108 0818 	add.w	r8, r8, #24
6000273a:	2c04      	cmp	r4, #4
6000273c:	d1f7      	bne.n	6000272e <main+0xb6>
		k_sem_give(&sem[i]);
	}

	k_msleep(TOTAL_TIME);
	DONE=false;
6000273e:	2400      	movs	r4, #0
	return z_impl_k_sleep(timeout);
60002740:	f649 4040 	movw	r0, #40000	; 0x9c40
60002744:	2100      	movs	r1, #0
60002746:	f006 fbb3 	bl	60008eb0 <z_impl_k_sleep>
6000274a:	702c      	strb	r4, [r5, #0]
	for(int i=0; i<NUM_THREADS; i++)
6000274c:	3401      	adds	r4, #1
	return z_impl_k_thread_join(thread, timeout);
6000274e:	4638      	mov	r0, r7
60002750:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60002754:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60002758:	f006 fc48 	bl	60008fec <z_impl_k_thread_join>
6000275c:	2c04      	cmp	r4, #4
6000275e:	f107 07c0 	add.w	r7, r7, #192	; 0xc0
60002762:	d1f3      	bne.n	6000274c <main+0xd4>
	{
		k_thread_join(&thread_data[i], K_FOREVER);
	}
}
60002764:	b00d      	add	sp, #52	; 0x34
60002766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
6000276a:	bf00      	nop
6000276c:	6000d72c 	.word	0x6000d72c
60002770:	800009c8 	.word	0x800009c8
60002774:	800009e0 	.word	0x800009e0
60002778:	800009f4 	.word	0x800009f4
6000277c:	80000a08 	.word	0x80000a08
60002780:	80000000 	.word	0x80000000
60002784:	80000a7c 	.word	0x80000a7c
60002788:	800010a0 	.word	0x800010a0
6000278c:	600025ad 	.word	0x600025ad
60002790:	800002a8 	.word	0x800002a8
60002794:	80000a1c 	.word	0x80000a1c
60002798:	80000170 	.word	0x80000170

6000279c <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
6000279c:	4b01      	ldr	r3, [pc, #4]	; (600027a4 <__printk_hook_install+0x8>)
6000279e:	6018      	str	r0, [r3, #0]
}
600027a0:	4770      	bx	lr
600027a2:	bf00      	nop
600027a4:	800000e0 	.word	0x800000e0

600027a8 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
600027a8:	b530      	push	{r4, r5, lr}
600027aa:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
600027ac:	2500      	movs	r5, #0
{
600027ae:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
600027b0:	9503      	str	r5, [sp, #12]
600027b2:	e9cd 0101 	strd	r0, r1, [sp, #4]

	cbvprintf(str_out, &ctx, fmt, ap);
600027b6:	a901      	add	r1, sp, #4
600027b8:	4804      	ldr	r0, [pc, #16]	; (600027cc <vsnprintk+0x24>)
600027ba:	f000 f809 	bl	600027d0 <cbvprintf>

	if (ctx.count < ctx.max) {
600027be:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
600027c2:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
600027c4:	bfb8      	it	lt
600027c6:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
600027c8:	b005      	add	sp, #20
600027ca:	bd30      	pop	{r4, r5, pc}
600027cc:	600098b3 	.word	0x600098b3

600027d0 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
600027d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
600027d4:	468b      	mov	fp, r1
600027d6:	b091      	sub	sp, #68	; 0x44
600027d8:	4692      	mov	sl, r2
600027da:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
600027dc:	2500      	movs	r5, #0
{
600027de:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
600027e0:	f89a 0000 	ldrb.w	r0, [sl]
600027e4:	b908      	cbnz	r0, 600027ea <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
600027e6:	4628      	mov	r0, r5
600027e8:	e360      	b.n	60002eac <cbvprintf+0x6dc>
		if (*fp != '%') {
600027ea:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
600027ec:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
600027f0:	d007      	beq.n	60002802 <cbvprintf+0x32>
			OUTC('%');
600027f2:	4659      	mov	r1, fp
600027f4:	9b02      	ldr	r3, [sp, #8]
600027f6:	4798      	blx	r3
600027f8:	2800      	cmp	r0, #0
600027fa:	f2c0 8357 	blt.w	60002eac <cbvprintf+0x6dc>
600027fe:	3501      	adds	r5, #1
			break;
60002800:	e212      	b.n	60002c28 <cbvprintf+0x458>
		} state = {
60002802:	2218      	movs	r2, #24
60002804:	2100      	movs	r1, #0
60002806:	a80a      	add	r0, sp, #40	; 0x28
60002808:	f009 f8ce 	bl	6000b9a8 <memset>
	if (*sp == '%') {
6000280c:	f89a 3001 	ldrb.w	r3, [sl, #1]
60002810:	2b25      	cmp	r3, #37	; 0x25
60002812:	d078      	beq.n	60002906 <cbvprintf+0x136>
60002814:	2200      	movs	r2, #0
60002816:	4610      	mov	r0, r2
60002818:	4696      	mov	lr, r2
6000281a:	4694      	mov	ip, r2
6000281c:	4616      	mov	r6, r2
6000281e:	4639      	mov	r1, r7
		switch (*sp) {
60002820:	f817 3b01 	ldrb.w	r3, [r7], #1
60002824:	2b2b      	cmp	r3, #43	; 0x2b
60002826:	f000 809d 	beq.w	60002964 <cbvprintf+0x194>
6000282a:	f200 8094 	bhi.w	60002956 <cbvprintf+0x186>
6000282e:	2b20      	cmp	r3, #32
60002830:	f000 809b 	beq.w	6000296a <cbvprintf+0x19a>
60002834:	2b23      	cmp	r3, #35	; 0x23
60002836:	f000 809b 	beq.w	60002970 <cbvprintf+0x1a0>
6000283a:	b12e      	cbz	r6, 60002848 <cbvprintf+0x78>
6000283c:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
60002840:	f046 0604 	orr.w	r6, r6, #4
60002844:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
60002848:	f1bc 0f00 	cmp.w	ip, #0
6000284c:	d005      	beq.n	6000285a <cbvprintf+0x8a>
6000284e:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
60002852:	f046 0608 	orr.w	r6, r6, #8
60002856:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
6000285a:	f1be 0f00 	cmp.w	lr, #0
6000285e:	d005      	beq.n	6000286c <cbvprintf+0x9c>
60002860:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
60002864:	f046 0610 	orr.w	r6, r6, #16
60002868:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
6000286c:	b128      	cbz	r0, 6000287a <cbvprintf+0xaa>
6000286e:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
60002872:	f040 0020 	orr.w	r0, r0, #32
60002876:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
6000287a:	b12a      	cbz	r2, 60002888 <cbvprintf+0xb8>
6000287c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
60002880:	f042 0240 	orr.w	r2, r2, #64	; 0x40
60002884:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
60002888:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
6000288c:	f002 0044 	and.w	r0, r2, #68	; 0x44
60002890:	2844      	cmp	r0, #68	; 0x44
60002892:	d103      	bne.n	6000289c <cbvprintf+0xcc>
		conv->flag_zero = false;
60002894:	f36f 1286 	bfc	r2, #6, #1
60002898:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
6000289c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
600028a0:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
600028a2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
600028a6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
600028aa:	d17b      	bne.n	600029a4 <cbvprintf+0x1d4>
		conv->width_star = true;
600028ac:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
			++sp;
600028b0:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
600028b2:	f042 0201 	orr.w	r2, r2, #1
600028b6:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
600028ba:	781a      	ldrb	r2, [r3, #0]
600028bc:	2a2e      	cmp	r2, #46	; 0x2e
600028be:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
600028c2:	bf0c      	ite	eq
600028c4:	2101      	moveq	r1, #1
600028c6:	2100      	movne	r1, #0
600028c8:	f361 0241 	bfi	r2, r1, #1, #1
600028cc:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
600028d0:	d174      	bne.n	600029bc <cbvprintf+0x1ec>
	if (*sp == '*') {
600028d2:	785a      	ldrb	r2, [r3, #1]
600028d4:	2a2a      	cmp	r2, #42	; 0x2a
600028d6:	d06a      	beq.n	600029ae <cbvprintf+0x1de>
	++sp;
600028d8:	3301      	adds	r3, #1
	size_t val = 0;
600028da:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
600028dc:	260a      	movs	r6, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
600028de:	4618      	mov	r0, r3
600028e0:	f810 2b01 	ldrb.w	r2, [r0], #1
600028e4:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
600028e8:	2f09      	cmp	r7, #9
600028ea:	f240 808e 	bls.w	60002a0a <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
600028ee:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
600028f2:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
600028f4:	f3c2 0040 	ubfx	r0, r2, #1, #1
600028f8:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
600028fc:	f361 0241 	bfi	r2, r1, #1, #1
60002900:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
60002904:	e05a      	b.n	600029bc <cbvprintf+0x1ec>
		conv->specifier = *sp++;
60002906:	f10a 0702 	add.w	r7, sl, #2
6000290a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
6000290e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
60002912:	07d9      	lsls	r1, r3, #31
60002914:	f140 8149 	bpl.w	60002baa <cbvprintf+0x3da>
			width = va_arg(ap, int);
60002918:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
6000291c:	f1b9 0f00 	cmp.w	r9, #0
60002920:	da07      	bge.n	60002932 <cbvprintf+0x162>
				conv->flag_dash = true;
60002922:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
60002926:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
6000292a:	f042 0204 	orr.w	r2, r2, #4
6000292e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
60002932:	075a      	lsls	r2, r3, #29
60002934:	f140 8142 	bpl.w	60002bbc <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
60002938:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
6000293c:	f1b8 0f00 	cmp.w	r8, #0
60002940:	f280 8141 	bge.w	60002bc6 <cbvprintf+0x3f6>
				conv->prec_present = false;
60002944:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
60002948:	f36f 0341 	bfc	r3, #1, #1
6000294c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
60002950:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
60002954:	e137      	b.n	60002bc6 <cbvprintf+0x3f6>
		switch (*sp) {
60002956:	2b2d      	cmp	r3, #45	; 0x2d
60002958:	d00c      	beq.n	60002974 <cbvprintf+0x1a4>
6000295a:	2b30      	cmp	r3, #48	; 0x30
6000295c:	f47f af6d 	bne.w	6000283a <cbvprintf+0x6a>
			conv->flag_zero = true;
60002960:	2201      	movs	r2, #1
	} while (loop);
60002962:	e75c      	b.n	6000281e <cbvprintf+0x4e>
			conv->flag_plus = true;
60002964:	f04f 0c01 	mov.w	ip, #1
60002968:	e759      	b.n	6000281e <cbvprintf+0x4e>
			conv->flag_space = true;
6000296a:	f04f 0e01 	mov.w	lr, #1
6000296e:	e756      	b.n	6000281e <cbvprintf+0x4e>
			conv->flag_hash = true;
60002970:	2001      	movs	r0, #1
60002972:	e754      	b.n	6000281e <cbvprintf+0x4e>
		switch (*sp) {
60002974:	2601      	movs	r6, #1
60002976:	e752      	b.n	6000281e <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
60002978:	fb0c 0202 	mla	r2, ip, r2, r0
6000297c:	4633      	mov	r3, r6
6000297e:	3a30      	subs	r2, #48	; 0x30
60002980:	461e      	mov	r6, r3
60002982:	f816 0b01 	ldrb.w	r0, [r6], #1
60002986:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
6000298a:	2f09      	cmp	r7, #9
6000298c:	d9f4      	bls.n	60002978 <cbvprintf+0x1a8>
	if (sp != wp) {
6000298e:	4299      	cmp	r1, r3
60002990:	d093      	beq.n	600028ba <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
60002992:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
60002996:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
60002998:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
6000299a:	f362 0141 	bfi	r1, r2, #1, #1
6000299e:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
600029a2:	e78a      	b.n	600028ba <cbvprintf+0xea>
600029a4:	460b      	mov	r3, r1
	size_t val = 0;
600029a6:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
600029a8:	f04f 0c0a 	mov.w	ip, #10
600029ac:	e7e8      	b.n	60002980 <cbvprintf+0x1b0>
		conv->prec_star = true;
600029ae:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
600029b2:	3302      	adds	r3, #2
		conv->prec_star = true;
600029b4:	f042 0204 	orr.w	r2, r2, #4
600029b8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
600029bc:	461f      	mov	r7, r3
600029be:	f817 2b01 	ldrb.w	r2, [r7], #1
600029c2:	2a6c      	cmp	r2, #108	; 0x6c
600029c4:	d041      	beq.n	60002a4a <cbvprintf+0x27a>
600029c6:	d825      	bhi.n	60002a14 <cbvprintf+0x244>
600029c8:	2a68      	cmp	r2, #104	; 0x68
600029ca:	d02b      	beq.n	60002a24 <cbvprintf+0x254>
600029cc:	2a6a      	cmp	r2, #106	; 0x6a
600029ce:	d046      	beq.n	60002a5e <cbvprintf+0x28e>
600029d0:	2a4c      	cmp	r2, #76	; 0x4c
600029d2:	d04c      	beq.n	60002a6e <cbvprintf+0x29e>
600029d4:	461f      	mov	r7, r3
	conv->specifier = *sp++;
600029d6:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
600029da:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
600029de:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
600029e0:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
600029e4:	f200 80d9 	bhi.w	60002b9a <cbvprintf+0x3ca>
600029e8:	2a57      	cmp	r2, #87	; 0x57
600029ea:	d84d      	bhi.n	60002a88 <cbvprintf+0x2b8>
600029ec:	2a41      	cmp	r2, #65	; 0x41
600029ee:	d003      	beq.n	600029f8 <cbvprintf+0x228>
600029f0:	3a45      	subs	r2, #69	; 0x45
600029f2:	2a02      	cmp	r2, #2
600029f4:	f200 80d1 	bhi.w	60002b9a <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
600029f8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
600029fc:	2204      	movs	r2, #4
600029fe:	f362 0302 	bfi	r3, r2, #0, #3
60002a02:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
60002a06:	2301      	movs	r3, #1
			break;
60002a08:	e09e      	b.n	60002b48 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
60002a0a:	fb06 2101 	mla	r1, r6, r1, r2
60002a0e:	4603      	mov	r3, r0
60002a10:	3930      	subs	r1, #48	; 0x30
60002a12:	e764      	b.n	600028de <cbvprintf+0x10e>
	switch (*sp) {
60002a14:	2a74      	cmp	r2, #116	; 0x74
60002a16:	d026      	beq.n	60002a66 <cbvprintf+0x296>
60002a18:	2a7a      	cmp	r2, #122	; 0x7a
60002a1a:	d1db      	bne.n	600029d4 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
60002a1c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
60002a20:	2206      	movs	r2, #6
60002a22:	e00d      	b.n	60002a40 <cbvprintf+0x270>
		if (*++sp == 'h') {
60002a24:	785a      	ldrb	r2, [r3, #1]
60002a26:	2a68      	cmp	r2, #104	; 0x68
60002a28:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
60002a2c:	d106      	bne.n	60002a3c <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
60002a2e:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
60002a30:	f361 02c6 	bfi	r2, r1, #3, #4
			++sp;
60002a34:	1c9f      	adds	r7, r3, #2
			conv->length_mod = LENGTH_LL;
60002a36:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
60002a3a:	e7cc      	b.n	600029d6 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
60002a3c:	4613      	mov	r3, r2
60002a3e:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
60002a40:	f362 03c6 	bfi	r3, r2, #3, #4
60002a44:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
60002a48:	e7c5      	b.n	600029d6 <cbvprintf+0x206>
		if (*++sp == 'l') {
60002a4a:	785a      	ldrb	r2, [r3, #1]
60002a4c:	2a6c      	cmp	r2, #108	; 0x6c
60002a4e:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
60002a52:	d101      	bne.n	60002a58 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
60002a54:	2104      	movs	r1, #4
60002a56:	e7eb      	b.n	60002a30 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
60002a58:	4613      	mov	r3, r2
60002a5a:	2203      	movs	r2, #3
60002a5c:	e7f0      	b.n	60002a40 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
60002a5e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
60002a62:	2205      	movs	r2, #5
60002a64:	e7ec      	b.n	60002a40 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
60002a66:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
60002a6a:	2207      	movs	r2, #7
60002a6c:	e7e8      	b.n	60002a40 <cbvprintf+0x270>
		conv->unsupported = true;
60002a6e:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
60002a72:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
60002a76:	f023 0302 	bic.w	r3, r3, #2
60002a7a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
60002a7e:	f043 0302 	orr.w	r3, r3, #2
60002a82:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
60002a86:	e7a6      	b.n	600029d6 <cbvprintf+0x206>
	switch (conv->specifier) {
60002a88:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
60002a8c:	2920      	cmp	r1, #32
60002a8e:	f200 8084 	bhi.w	60002b9a <cbvprintf+0x3ca>
60002a92:	a001      	add	r0, pc, #4	; (adr r0, 60002a98 <cbvprintf+0x2c8>)
60002a94:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
60002a98:	60002b5d 	.word	0x60002b5d
60002a9c:	60002b9b 	.word	0x60002b9b
60002aa0:	60002b9b 	.word	0x60002b9b
60002aa4:	60002b9b 	.word	0x60002b9b
60002aa8:	60002b9b 	.word	0x60002b9b
60002aac:	60002b9b 	.word	0x60002b9b
60002ab0:	60002b9b 	.word	0x60002b9b
60002ab4:	60002b9b 	.word	0x60002b9b
60002ab8:	60002b9b 	.word	0x60002b9b
60002abc:	600029f9 	.word	0x600029f9
60002ac0:	60002b9b 	.word	0x60002b9b
60002ac4:	60002b5d 	.word	0x60002b5d
60002ac8:	60002b1d 	.word	0x60002b1d
60002acc:	600029f9 	.word	0x600029f9
60002ad0:	600029f9 	.word	0x600029f9
60002ad4:	600029f9 	.word	0x600029f9
60002ad8:	60002b9b 	.word	0x60002b9b
60002adc:	60002b1d 	.word	0x60002b1d
60002ae0:	60002b9b 	.word	0x60002b9b
60002ae4:	60002b9b 	.word	0x60002b9b
60002ae8:	60002b9b 	.word	0x60002b9b
60002aec:	60002b9b 	.word	0x60002b9b
60002af0:	60002b65 	.word	0x60002b65
60002af4:	60002b5d 	.word	0x60002b5d
60002af8:	60002b81 	.word	0x60002b81
60002afc:	60002b9b 	.word	0x60002b9b
60002b00:	60002b9b 	.word	0x60002b9b
60002b04:	60002b81 	.word	0x60002b81
60002b08:	60002b9b 	.word	0x60002b9b
60002b0c:	60002b5d 	.word	0x60002b5d
60002b10:	60002b9b 	.word	0x60002b9b
60002b14:	60002b9b 	.word	0x60002b9b
60002b18:	60002b5d 	.word	0x60002b5d
		conv->specifier_cat = SPECIFIER_SINT;
60002b1c:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
60002b20:	2001      	movs	r0, #1
		if (conv->length_mod == LENGTH_UPPER_L) {
60002b22:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
60002b26:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
60002b2a:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
60002b2c:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
60002b30:	bf02      	ittt	eq
60002b32:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
60002b36:	f041 0101 	orreq.w	r1, r1, #1
60002b3a:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
60002b3e:	2a63      	cmp	r2, #99	; 0x63
60002b40:	d131      	bne.n	60002ba6 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
60002b42:	3b00      	subs	r3, #0
60002b44:	bf18      	it	ne
60002b46:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
60002b48:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
60002b4c:	f3c2 0140 	ubfx	r1, r2, #1, #1
60002b50:	430b      	orrs	r3, r1
60002b52:	f363 0241 	bfi	r2, r3, #1, #1
60002b56:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
60002b5a:	e6d8      	b.n	6000290e <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
60002b5c:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
60002b60:	2002      	movs	r0, #2
60002b62:	e7de      	b.n	60002b22 <cbvprintf+0x352>
		if (conv->length_mod == LENGTH_UPPER_L) {
60002b64:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
60002b68:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
60002b6c:	2103      	movs	r1, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
60002b6e:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
60002b72:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
60002b76:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
60002b78:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
60002b7c:	4143      	adcs	r3, r0
60002b7e:	e7e3      	b.n	60002b48 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
60002b80:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
60002b84:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
60002b86:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
60002b8a:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
60002b8e:	bf14      	ite	ne
60002b90:	2301      	movne	r3, #1
60002b92:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
60002b94:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
60002b98:	e7d6      	b.n	60002b48 <cbvprintf+0x378>
		conv->invalid = true;
60002b9a:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
60002b9e:	f043 0301 	orr.w	r3, r3, #1
60002ba2:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
60002ba6:	2300      	movs	r3, #0
60002ba8:	e7ce      	b.n	60002b48 <cbvprintf+0x378>
		} else if (conv->width_present) {
60002baa:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
60002bae:	2a00      	cmp	r2, #0
			width = conv->width_value;
60002bb0:	bfb4      	ite	lt
60002bb2:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
		int width = -1;
60002bb6:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
60002bba:	e6ba      	b.n	60002932 <cbvprintf+0x162>
		} else if (conv->prec_present) {
60002bbc:	079b      	lsls	r3, r3, #30
60002bbe:	f57f aec7 	bpl.w	60002950 <cbvprintf+0x180>
			precision = conv->prec_value;
60002bc2:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
60002bc6:	2300      	movs	r3, #0
			= (enum length_mod_enum)conv->length_mod;
60002bc8:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		conv->pad0_pre_exp = 0;
60002bcc:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
60002bd0:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
60002bd4:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		enum specifier_cat_enum specifier_cat
60002bd8:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
60002bdc:	2b01      	cmp	r3, #1
60002bde:	d138      	bne.n	60002c52 <cbvprintf+0x482>
			switch (length_mod) {
60002be0:	1ecb      	subs	r3, r1, #3
60002be2:	2b04      	cmp	r3, #4
60002be4:	d822      	bhi.n	60002c2c <cbvprintf+0x45c>
60002be6:	e8df f003 	tbb	[pc, r3]
60002bea:	0903      	.short	0x0903
60002bec:	2109      	.short	0x2109
60002bee:	21          	.byte	0x21
60002bef:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
60002bf0:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
60002bf4:	17da      	asrs	r2, r3, #31
60002bf6:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
60002bfa:	e006      	b.n	60002c0a <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
60002bfc:	3407      	adds	r4, #7
60002bfe:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
60002c02:	e8f4 2302 	ldrd	r2, r3, [r4], #8
60002c06:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
60002c0a:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
60002c0e:	f013 0603 	ands.w	r6, r3, #3
60002c12:	d056      	beq.n	60002cc2 <cbvprintf+0x4f2>
			OUTS(sp, fp);
60002c14:	463b      	mov	r3, r7
60002c16:	4652      	mov	r2, sl
60002c18:	4659      	mov	r1, fp
60002c1a:	9802      	ldr	r0, [sp, #8]
60002c1c:	f006 ffa2 	bl	60009b64 <outs>
60002c20:	2800      	cmp	r0, #0
60002c22:	f2c0 8143 	blt.w	60002eac <cbvprintf+0x6dc>
60002c26:	4405      	add	r5, r0
			continue;
60002c28:	46ba      	mov	sl, r7
60002c2a:	e5d9      	b.n	600027e0 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
60002c2c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
60002c30:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
60002c32:	ea4f 72e3 	mov.w	r2, r3, asr #31
60002c36:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
60002c3a:	d105      	bne.n	60002c48 <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
60002c3c:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
60002c40:	930a      	str	r3, [sp, #40]	; 0x28
60002c42:	2300      	movs	r3, #0
60002c44:	930b      	str	r3, [sp, #44]	; 0x2c
60002c46:	e7e0      	b.n	60002c0a <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
60002c48:	2902      	cmp	r1, #2
60002c4a:	d1de      	bne.n	60002c0a <cbvprintf+0x43a>
				value->sint = (short)value->sint;
60002c4c:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
60002c50:	e7d0      	b.n	60002bf4 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
60002c52:	2b02      	cmp	r3, #2
60002c54:	d123      	bne.n	60002c9e <cbvprintf+0x4ce>
			switch (length_mod) {
60002c56:	1ecb      	subs	r3, r1, #3
60002c58:	2b04      	cmp	r3, #4
60002c5a:	d813      	bhi.n	60002c84 <cbvprintf+0x4b4>
60002c5c:	e8df f003 	tbb	[pc, r3]
60002c60:	120a0a03 	.word	0x120a0a03
60002c64:	12          	.byte	0x12
60002c65:	00          	.byte	0x00
					value->uint = (wchar_t)va_arg(ap,
60002c66:	6822      	ldr	r2, [r4, #0]
60002c68:	2300      	movs	r3, #0
				value->sint = va_arg(ap, int);
60002c6a:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
60002c6c:	920a      	str	r2, [sp, #40]	; 0x28
60002c6e:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
60002c70:	4604      	mov	r4, r0
60002c72:	e7ca      	b.n	60002c0a <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
60002c74:	1de0      	adds	r0, r4, #7
60002c76:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
60002c7a:	e8f0 2302 	ldrd	r2, r3, [r0], #8
60002c7e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
60002c82:	e7f5      	b.n	60002c70 <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
60002c84:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
60002c88:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
60002c8a:	930a      	str	r3, [sp, #40]	; 0x28
60002c8c:	f04f 0300 	mov.w	r3, #0
60002c90:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
60002c92:	d0d3      	beq.n	60002c3c <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
60002c94:	2902      	cmp	r1, #2
60002c96:	d1b8      	bne.n	60002c0a <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
60002c98:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
60002c9c:	e7d0      	b.n	60002c40 <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
60002c9e:	2b04      	cmp	r3, #4
60002ca0:	d109      	bne.n	60002cb6 <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
60002ca2:	1de3      	adds	r3, r4, #7
60002ca4:	f023 0307 	bic.w	r3, r3, #7
60002ca8:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
60002cac:	e9d3 2300 	ldrd	r2, r3, [r3]
60002cb0:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
60002cb4:	e7a9      	b.n	60002c0a <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
60002cb6:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
60002cb8:	bf04      	itt	eq
60002cba:	f854 3b04 	ldreq.w	r3, [r4], #4
60002cbe:	930a      	streq	r3, [sp, #40]	; 0x28
60002cc0:	e7a3      	b.n	60002c0a <cbvprintf+0x43a>
		switch (conv->specifier) {
60002cc2:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
60002cc6:	2878      	cmp	r0, #120	; 0x78
60002cc8:	d8ae      	bhi.n	60002c28 <cbvprintf+0x458>
60002cca:	2862      	cmp	r0, #98	; 0x62
60002ccc:	d822      	bhi.n	60002d14 <cbvprintf+0x544>
60002cce:	2825      	cmp	r0, #37	; 0x25
60002cd0:	f43f ad8f 	beq.w	600027f2 <cbvprintf+0x22>
60002cd4:	2858      	cmp	r0, #88	; 0x58
60002cd6:	d1a7      	bne.n	60002c28 <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
60002cd8:	f10d 0326 	add.w	r3, sp, #38	; 0x26
60002cdc:	aa0c      	add	r2, sp, #48	; 0x30
60002cde:	9300      	str	r3, [sp, #0]
60002ce0:	ab04      	add	r3, sp, #16
60002ce2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
60002ce6:	f006 fef7 	bl	60009ad8 <encode_uint>
60002cea:	4682      	mov	sl, r0
			if (precision >= 0) {
60002cec:	f1b8 0f00 	cmp.w	r8, #0
60002cf0:	f10d 0026 	add.w	r0, sp, #38	; 0x26
60002cf4:	db0c      	blt.n	60002d10 <cbvprintf+0x540>
				conv->flag_zero = false;
60002cf6:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
60002cfa:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
60002cfe:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
60002d02:	4598      	cmp	r8, r3
				conv->flag_zero = false;
60002d04:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
60002d08:	d902      	bls.n	60002d10 <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
60002d0a:	eba8 0303 	sub.w	r3, r8, r3
60002d0e:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
60002d10:	4680      	mov	r8, r0
60002d12:	e03d      	b.n	60002d90 <cbvprintf+0x5c0>
		switch (conv->specifier) {
60002d14:	3863      	subs	r0, #99	; 0x63
60002d16:	2815      	cmp	r0, #21
60002d18:	d886      	bhi.n	60002c28 <cbvprintf+0x458>
60002d1a:	a201      	add	r2, pc, #4	; (adr r2, 60002d20 <cbvprintf+0x550>)
60002d1c:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
60002d20:	60002da1 	.word	0x60002da1
60002d24:	60002e05 	.word	0x60002e05
60002d28:	60002c29 	.word	0x60002c29
60002d2c:	60002c29 	.word	0x60002c29
60002d30:	60002c29 	.word	0x60002c29
60002d34:	60002c29 	.word	0x60002c29
60002d38:	60002e05 	.word	0x60002e05
60002d3c:	60002c29 	.word	0x60002c29
60002d40:	60002c29 	.word	0x60002c29
60002d44:	60002c29 	.word	0x60002c29
60002d48:	60002c29 	.word	0x60002c29
60002d4c:	60002e61 	.word	0x60002e61
60002d50:	60002e2f 	.word	0x60002e2f
60002d54:	60002e33 	.word	0x60002e33
60002d58:	60002c29 	.word	0x60002c29
60002d5c:	60002c29 	.word	0x60002c29
60002d60:	60002d79 	.word	0x60002d79
60002d64:	60002c29 	.word	0x60002c29
60002d68:	60002e2f 	.word	0x60002e2f
60002d6c:	60002c29 	.word	0x60002c29
60002d70:	60002c29 	.word	0x60002c29
60002d74:	60002e2f 	.word	0x60002e2f
			if (precision >= 0) {
60002d78:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
60002d7c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
60002d80:	db0a      	blt.n	60002d98 <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
60002d82:	4641      	mov	r1, r8
60002d84:	4650      	mov	r0, sl
60002d86:	f008 fd95 	bl	6000b8b4 <strnlen>
			bpe = bps + len;
60002d8a:	eb0a 0800 	add.w	r8, sl, r0
		char sign = 0;
60002d8e:	2600      	movs	r6, #0
		if (bps == NULL) {
60002d90:	f1ba 0f00 	cmp.w	sl, #0
60002d94:	d10c      	bne.n	60002db0 <cbvprintf+0x5e0>
60002d96:	e747      	b.n	60002c28 <cbvprintf+0x458>
				len = strlen(bps);
60002d98:	4650      	mov	r0, sl
60002d9a:	f008 fd84 	bl	6000b8a6 <strlen>
60002d9e:	e7f4      	b.n	60002d8a <cbvprintf+0x5ba>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
60002da0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			break;
60002da2:	2600      	movs	r6, #0
			bps = buf;
60002da4:	f10d 0a10 	add.w	sl, sp, #16
			bpe = buf + 1;
60002da8:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
60002dac:	f88d 3010 	strb.w	r3, [sp, #16]
		size_t nj_len = (bpe - bps);
60002db0:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
60002db4:	b106      	cbz	r6, 60002db8 <cbvprintf+0x5e8>
			nj_len += 1U;
60002db6:	3301      	adds	r3, #1
		if (conv->altform_0c) {
60002db8:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
60002dbc:	06d0      	lsls	r0, r2, #27
60002dbe:	d569      	bpl.n	60002e94 <cbvprintf+0x6c4>
			nj_len += 2U;
60002dc0:	3302      	adds	r3, #2
		if (conv->pad_fp) {
60002dc2:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
60002dc4:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
60002dc6:	bf48      	it	mi
60002dc8:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
60002dca:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
60002dcc:	bf48      	it	mi
60002dce:	189b      	addmi	r3, r3, r2
		if (width > 0) {
60002dd0:	f1b9 0f00 	cmp.w	r9, #0
60002dd4:	dd77      	ble.n	60002ec6 <cbvprintf+0x6f6>
			if (!conv->flag_dash) {
60002dd6:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
60002dda:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
60002dde:	f3c2 0380 	ubfx	r3, r2, #2, #1
60002de2:	9303      	str	r3, [sp, #12]
60002de4:	0753      	lsls	r3, r2, #29
60002de6:	d46e      	bmi.n	60002ec6 <cbvprintf+0x6f6>
				if (conv->flag_zero) {
60002de8:	0650      	lsls	r0, r2, #25
60002dea:	d562      	bpl.n	60002eb2 <cbvprintf+0x6e2>
					if (sign != 0) {
60002dec:	b146      	cbz	r6, 60002e00 <cbvprintf+0x630>
						OUTC(sign);
60002dee:	4659      	mov	r1, fp
60002df0:	4630      	mov	r0, r6
60002df2:	9b02      	ldr	r3, [sp, #8]
60002df4:	4798      	blx	r3
60002df6:	2800      	cmp	r0, #0
60002df8:	db58      	blt.n	60002eac <cbvprintf+0x6dc>
						sign = 0;
60002dfa:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
60002dfc:	3501      	adds	r5, #1
						sign = 0;
60002dfe:	461e      	mov	r6, r3
					pad = '0';
60002e00:	2330      	movs	r3, #48	; 0x30
60002e02:	e057      	b.n	60002eb4 <cbvprintf+0x6e4>
			if (conv->flag_plus) {
60002e04:	071e      	lsls	r6, r3, #28
60002e06:	d410      	bmi.n	60002e2a <cbvprintf+0x65a>
				sign = ' ';
60002e08:	f013 0610 	ands.w	r6, r3, #16
60002e0c:	bf18      	it	ne
60002e0e:	2620      	movne	r6, #32
			sint = value->sint;
60002e10:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
60002e14:	2b00      	cmp	r3, #0
60002e16:	f6bf af5f 	bge.w	60002cd8 <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
60002e1a:	4252      	negs	r2, r2
				sign = '-';
60002e1c:	f04f 062d 	mov.w	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
60002e20:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
60002e24:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
60002e28:	e756      	b.n	60002cd8 <cbvprintf+0x508>
				sign = '+';
60002e2a:	262b      	movs	r6, #43	; 0x2b
60002e2c:	e7f0      	b.n	60002e10 <cbvprintf+0x640>
		switch (conv->specifier) {
60002e2e:	2600      	movs	r6, #0
60002e30:	e752      	b.n	60002cd8 <cbvprintf+0x508>
			if (value->ptr != NULL) {
60002e32:	980a      	ldr	r0, [sp, #40]	; 0x28
60002e34:	b340      	cbz	r0, 60002e88 <cbvprintf+0x6b8>
				bps = encode_uint((uintptr_t)value->ptr, conv,
60002e36:	f10d 0326 	add.w	r3, sp, #38	; 0x26
60002e3a:	aa0c      	add	r2, sp, #48	; 0x30
60002e3c:	2100      	movs	r1, #0
		char sign = 0;
60002e3e:	2600      	movs	r6, #0
				bps = encode_uint((uintptr_t)value->ptr, conv,
60002e40:	9300      	str	r3, [sp, #0]
60002e42:	ab04      	add	r3, sp, #16
60002e44:	f006 fe48 	bl	60009ad8 <encode_uint>
				conv->altform_0c = true;
60002e48:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
60002e4c:	4682      	mov	sl, r0
				conv->altform_0c = true;
60002e4e:	f003 03ef 	and.w	r3, r3, #239	; 0xef
60002e52:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
60002e56:	f043 0310 	orr.w	r3, r3, #16
60002e5a:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
60002e5e:	e745      	b.n	60002cec <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
60002e60:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
60002e62:	2907      	cmp	r1, #7
60002e64:	f63f aee0 	bhi.w	60002c28 <cbvprintf+0x458>
60002e68:	e8df f001 	tbb	[pc, r1]
60002e6c:	0c06040c 	.word	0x0c06040c
60002e70:	0c0c0808 	.word	0x0c0c0808
		*(signed char *)dp = (signed char)count;
60002e74:	701d      	strb	r5, [r3, #0]
		break;
60002e76:	e6d7      	b.n	60002c28 <cbvprintf+0x458>
		*(short *)dp = (short)count;
60002e78:	801d      	strh	r5, [r3, #0]
		break;
60002e7a:	e6d5      	b.n	60002c28 <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
60002e7c:	17ea      	asrs	r2, r5, #31
60002e7e:	e9c3 5200 	strd	r5, r2, [r3]
		break;
60002e82:	e6d1      	b.n	60002c28 <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
60002e84:	601d      	str	r5, [r3, #0]
		break;
60002e86:	e6cf      	b.n	60002c28 <cbvprintf+0x458>
			bps = "(nil)";
60002e88:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 60002f50 <cbvprintf+0x780>
60002e8c:	4606      	mov	r6, r0
			bpe = bps + 5;
60002e8e:	f10a 0805 	add.w	r8, sl, #5
60002e92:	e78d      	b.n	60002db0 <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
60002e94:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
60002e96:	bf48      	it	mi
60002e98:	3301      	addmi	r3, #1
60002e9a:	e792      	b.n	60002dc2 <cbvprintf+0x5f2>
					OUTC(pad);
60002e9c:	4618      	mov	r0, r3
60002e9e:	9303      	str	r3, [sp, #12]
60002ea0:	4659      	mov	r1, fp
60002ea2:	9b02      	ldr	r3, [sp, #8]
60002ea4:	4798      	blx	r3
60002ea6:	2800      	cmp	r0, #0
60002ea8:	9b03      	ldr	r3, [sp, #12]
60002eaa:	da04      	bge.n	60002eb6 <cbvprintf+0x6e6>
#undef OUTS
#undef OUTC
}
60002eac:	b011      	add	sp, #68	; 0x44
60002eae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
60002eb2:	2320      	movs	r3, #32
60002eb4:	444d      	add	r5, r9
60002eb6:	464a      	mov	r2, r9
60002eb8:	eba5 0109 	sub.w	r1, r5, r9
				while (width-- > 0) {
60002ebc:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
60002ec0:	2a00      	cmp	r2, #0
60002ec2:	dceb      	bgt.n	60002e9c <cbvprintf+0x6cc>
60002ec4:	460d      	mov	r5, r1
		if (sign != 0) {
60002ec6:	b136      	cbz	r6, 60002ed6 <cbvprintf+0x706>
			OUTC(sign);
60002ec8:	4659      	mov	r1, fp
60002eca:	4630      	mov	r0, r6
60002ecc:	9b02      	ldr	r3, [sp, #8]
60002ece:	4798      	blx	r3
60002ed0:	2800      	cmp	r0, #0
60002ed2:	dbeb      	blt.n	60002eac <cbvprintf+0x6dc>
60002ed4:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
60002ed6:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
60002eda:	06d9      	lsls	r1, r3, #27
60002edc:	d401      	bmi.n	60002ee2 <cbvprintf+0x712>
60002ede:	071a      	lsls	r2, r3, #28
60002ee0:	d506      	bpl.n	60002ef0 <cbvprintf+0x720>
				OUTC('0');
60002ee2:	4659      	mov	r1, fp
60002ee4:	2030      	movs	r0, #48	; 0x30
60002ee6:	9b02      	ldr	r3, [sp, #8]
60002ee8:	4798      	blx	r3
60002eea:	2800      	cmp	r0, #0
60002eec:	dbde      	blt.n	60002eac <cbvprintf+0x6dc>
60002eee:	3501      	adds	r5, #1
			if (conv->altform_0c) {
60002ef0:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
60002ef4:	06db      	lsls	r3, r3, #27
60002ef6:	d507      	bpl.n	60002f08 <cbvprintf+0x738>
				OUTC(conv->specifier);
60002ef8:	4659      	mov	r1, fp
60002efa:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
60002efe:	9b02      	ldr	r3, [sp, #8]
60002f00:	4798      	blx	r3
60002f02:	2800      	cmp	r0, #0
60002f04:	dbd2      	blt.n	60002eac <cbvprintf+0x6dc>
60002f06:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
60002f08:	9e0d      	ldr	r6, [sp, #52]	; 0x34
60002f0a:	442e      	add	r6, r5
60002f0c:	1b73      	subs	r3, r6, r5
60002f0e:	2b00      	cmp	r3, #0
60002f10:	dc16      	bgt.n	60002f40 <cbvprintf+0x770>
			OUTS(bps, bpe);
60002f12:	4643      	mov	r3, r8
60002f14:	4652      	mov	r2, sl
60002f16:	4659      	mov	r1, fp
60002f18:	9802      	ldr	r0, [sp, #8]
60002f1a:	f006 fe23 	bl	60009b64 <outs>
60002f1e:	2800      	cmp	r0, #0
60002f20:	dbc4      	blt.n	60002eac <cbvprintf+0x6dc>
60002f22:	4405      	add	r5, r0
		while (width > 0) {
60002f24:	44a9      	add	r9, r5
60002f26:	eba9 0305 	sub.w	r3, r9, r5
60002f2a:	2b00      	cmp	r3, #0
60002f2c:	f77f ae7c 	ble.w	60002c28 <cbvprintf+0x458>
			OUTC(' ');
60002f30:	4659      	mov	r1, fp
60002f32:	2020      	movs	r0, #32
60002f34:	9b02      	ldr	r3, [sp, #8]
60002f36:	4798      	blx	r3
60002f38:	2800      	cmp	r0, #0
60002f3a:	dbb7      	blt.n	60002eac <cbvprintf+0x6dc>
60002f3c:	3501      	adds	r5, #1
			--width;
60002f3e:	e7f2      	b.n	60002f26 <cbvprintf+0x756>
				OUTC('0');
60002f40:	4659      	mov	r1, fp
60002f42:	2030      	movs	r0, #48	; 0x30
60002f44:	9b02      	ldr	r3, [sp, #8]
60002f46:	4798      	blx	r3
60002f48:	2800      	cmp	r0, #0
60002f4a:	dbaf      	blt.n	60002eac <cbvprintf+0x6dc>
60002f4c:	3501      	adds	r5, #1
60002f4e:	e7dd      	b.n	60002f0c <cbvprintf+0x73c>
60002f50:	6000d763 	.word	0x6000d763

60002f54 <imxrt_init>:
 *
 * @return 0
 */

static int imxrt_init(const struct device *arg)
{
60002f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
60002f56:	f04f 0310 	mov.w	r3, #16
60002f5a:	f3ef 8411 	mrs	r4, BASEPRI
60002f5e:	f383 8811 	msr	BASEPRI, r3
60002f62:	f3bf 8f6f 	isb	sy

	/* disable interrupts */
	oldLevel = irq_lock();

	/* Watchdog disable */
	if ((WDOG1->WCR & WDOG_WCR_WDE_MASK) != 0) {
60002f66:	4a64      	ldr	r2, [pc, #400]	; (600030f8 <imxrt_init+0x1a4>)
60002f68:	8813      	ldrh	r3, [r2, #0]
60002f6a:	075b      	lsls	r3, r3, #29
60002f6c:	d505      	bpl.n	60002f7a <imxrt_init+0x26>
		WDOG1->WCR &= ~WDOG_WCR_WDE_MASK;
60002f6e:	8813      	ldrh	r3, [r2, #0]
60002f70:	f023 0304 	bic.w	r3, r3, #4
60002f74:	041b      	lsls	r3, r3, #16
60002f76:	0c1b      	lsrs	r3, r3, #16
60002f78:	8013      	strh	r3, [r2, #0]
	}

	if ((WDOG2->WCR & WDOG_WCR_WDE_MASK) != 0) {
60002f7a:	4a60      	ldr	r2, [pc, #384]	; (600030fc <imxrt_init+0x1a8>)
60002f7c:	8813      	ldrh	r3, [r2, #0]
60002f7e:	075f      	lsls	r7, r3, #29
60002f80:	d505      	bpl.n	60002f8e <imxrt_init+0x3a>
		WDOG2->WCR &= ~WDOG_WCR_WDE_MASK;
60002f82:	8813      	ldrh	r3, [r2, #0]
60002f84:	f023 0304 	bic.w	r3, r3, #4
60002f88:	041b      	lsls	r3, r3, #16
60002f8a:	0c1b      	lsrs	r3, r3, #16
60002f8c:	8013      	strh	r3, [r2, #0]
	}

	RTWDOG->CNT = 0xD928C520U; /* 0xD928C520U is the update key */
60002f8e:	4a5c      	ldr	r2, [pc, #368]	; (60003100 <imxrt_init+0x1ac>)
60002f90:	4b5c      	ldr	r3, [pc, #368]	; (60003104 <imxrt_init+0x1b0>)
60002f92:	6053      	str	r3, [r2, #4]
	RTWDOG->TOVAL = 0xFFFF;
60002f94:	f64f 73ff 	movw	r3, #65535	; 0xffff
60002f98:	6093      	str	r3, [r2, #8]
	RTWDOG->CS = (uint32_t) ((RTWDOG->CS) & ~RTWDOG_CS_EN_MASK)
60002f9a:	6813      	ldr	r3, [r2, #0]
		| RTWDOG_CS_UPDATE_MASK;
60002f9c:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
60002fa0:	f043 0320 	orr.w	r3, r3, #32
	RTWDOG->CS = (uint32_t) ((RTWDOG->CS) & ~RTWDOG_CS_EN_MASK)
60002fa4:	6013      	str	r3, [r2, #0]

	/* Disable Systick which might be enabled by bootrom */
	if ((SysTick->CTRL & SysTick_CTRL_ENABLE_Msk) != 0) {
60002fa6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60002faa:	691a      	ldr	r2, [r3, #16]
60002fac:	07d6      	lsls	r6, r2, #31
60002fae:	d503      	bpl.n	60002fb8 <imxrt_init+0x64>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
60002fb0:	691a      	ldr	r2, [r3, #16]
60002fb2:	f022 0201 	bic.w	r2, r2, #1
60002fb6:	611a      	str	r2, [r3, #16]
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
60002fb8:	4b53      	ldr	r3, [pc, #332]	; (60003108 <imxrt_init+0x1b4>)
60002fba:	695a      	ldr	r2, [r3, #20]
60002fbc:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
60002fc0:	d111      	bne.n	60002fe6 <imxrt_init+0x92>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
60002fc2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60002fc6:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
60002fca:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
60002fce:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60002fd2:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
60002fd6:	695a      	ldr	r2, [r3, #20]
60002fd8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
60002fdc:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
60002fde:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60002fe2:	f3bf 8f6f 	isb	sy
	}

	SCB_EnableICache();
	if ((SCB->CCR & SCB_CCR_DC_Msk) == 0) {
60002fe6:	4a48      	ldr	r2, [pc, #288]	; (60003108 <imxrt_init+0x1b4>)
60002fe8:	6953      	ldr	r3, [r2, #20]
60002fea:	03dd      	lsls	r5, r3, #15
60002fec:	d427      	bmi.n	6000303e <imxrt_init+0xea>
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
60002fee:	6953      	ldr	r3, [r2, #20]
60002ff0:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
60002ff4:	d123      	bne.n	6000303e <imxrt_init+0xea>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
60002ff6:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
60002ffa:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
60002ffe:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
60003002:	f643 75e0 	movw	r5, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
60003006:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
6000300a:	f3c3 334e 	ubfx	r3, r3, #13, #15
6000300e:	015b      	lsls	r3, r3, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
60003010:	ea03 0705 	and.w	r7, r3, r5
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
60003014:	4601      	mov	r1, r0
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
60003016:	ea47 7681 	orr.w	r6, r7, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
6000301a:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
6000301c:	f8c2 6260 	str.w	r6, [r2, #608]	; 0x260
      } while (ways-- != 0U);
60003020:	d2f9      	bcs.n	60003016 <imxrt_init+0xc2>
    } while(sets-- != 0U);
60003022:	3b20      	subs	r3, #32
60003024:	f113 0f20 	cmn.w	r3, #32
60003028:	d1f2      	bne.n	60003010 <imxrt_init+0xbc>
6000302a:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
6000302e:	6953      	ldr	r3, [r2, #20]
60003030:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
60003034:	6153      	str	r3, [r2, #20]
60003036:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
6000303a:	f3bf 8f6f 	isb	sy
 *
 * @param freq The XTAL input clock frequency in Hz.
 */
static inline void CLOCK_SetXtalFreq(uint32_t freq)
{
    g_xtalFreq = freq;
6000303e:	4b33      	ldr	r3, [pc, #204]	; (6000310c <imxrt_init+0x1b8>)
60003040:	4a33      	ldr	r2, [pc, #204]	; (60003110 <imxrt_init+0x1bc>)
60003042:	601a      	str	r2, [r3, #0]
 *
 * @param freq The RTC XTAL input clock frequency in Hz.
 */
static inline void CLOCK_SetRtcXtalFreq(uint32_t freq)
{
    g_rtcXtalFreq = freq;
60003044:	f44f 4200 	mov.w	r2, #32768	; 0x8000
60003048:	4b32      	ldr	r3, [pc, #200]	; (60003114 <imxrt_init+0x1c0>)
6000304a:	601a      	str	r2, [r3, #0]
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
6000304c:	4b32      	ldr	r3, [pc, #200]	; (60003118 <imxrt_init+0x1c4>)
6000304e:	699a      	ldr	r2, [r3, #24]
60003050:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
60003054:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
60003058:	619a      	str	r2, [r3, #24]
6000305a:	695a      	ldr	r2, [r3, #20]
6000305c:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
60003060:	615a      	str	r2, [r3, #20]
        while ((CCM->CDHIPR & ((1UL << busyShift))) != 0UL)
60003062:	6c9a      	ldr	r2, [r3, #72]	; 0x48
60003064:	0690      	lsls	r0, r2, #26
60003066:	d4fc      	bmi.n	60003062 <imxrt_init+0x10e>
	DCDC->REG3 = (DCDC->REG3 & (~DCDC_REG3_TRG_MASK)) | DCDC_REG3_TRG(0x12);
60003068:	4a2c      	ldr	r2, [pc, #176]	; (6000311c <imxrt_init+0x1c8>)
6000306a:	68d3      	ldr	r3, [r2, #12]
6000306c:	f023 031f 	bic.w	r3, r3, #31
60003070:	f043 0312 	orr.w	r3, r3, #18
60003074:	60d3      	str	r3, [r2, #12]
			(DCDC_REG0_STS_DC_OK_MASK & DCDC->REG0)) {
60003076:	6813      	ldr	r3, [r2, #0]
	while (DCDC_REG0_STS_DC_OK_MASK !=
60003078:	2b00      	cmp	r3, #0
6000307a:	dafc      	bge.n	60003076 <imxrt_init+0x122>
	CLOCK_InitArmPll(&armPllConfig); /* Configure ARM PLL to 1200M */
6000307c:	4828      	ldr	r0, [pc, #160]	; (60003120 <imxrt_init+0x1cc>)
6000307e:	f003 fd8f 	bl	60006ba0 <CLOCK_InitArmPll>
	CLOCK_InitSysPll(&sysPllConfig); /* Configure SYS PLL to 528M */
60003082:	4828      	ldr	r0, [pc, #160]	; (60003124 <imxrt_init+0x1d0>)
60003084:	f003 fdae 	bl	60006be4 <CLOCK_InitSysPll>
	CLOCK_InitUsb1Pll(&usb1PllConfig); /* Configure USB1 PLL to 480M */
60003088:	4827      	ldr	r0, [pc, #156]	; (60003128 <imxrt_init+0x1d4>)
6000308a:	f003 fddf 	bl	60006c4c <CLOCK_InitUsb1Pll>
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
6000308e:	4b22      	ldr	r3, [pc, #136]	; (60003118 <imxrt_init+0x1c4>)
60003090:	691a      	ldr	r2, [r3, #16]
60003092:	f022 0207 	bic.w	r2, r2, #7
60003096:	f042 0201 	orr.w	r2, r2, #1
6000309a:	611a      	str	r2, [r3, #16]
        while ((CCM->CDHIPR & ((uint32_t)(1UL << busyShift))) != 0UL)
6000309c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
6000309e:	03d1      	lsls	r1, r2, #15
600030a0:	d4fc      	bmi.n	6000309c <imxrt_init+0x148>
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
600030a2:	695a      	ldr	r2, [r3, #20]
600030a4:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
600030a8:	615a      	str	r2, [r3, #20]
        while ((CCM->CDHIPR & ((uint32_t)(1UL << busyShift))) != 0UL)
600030aa:	4b1b      	ldr	r3, [pc, #108]	; (60003118 <imxrt_init+0x1c4>)
600030ac:	6c9a      	ldr	r2, [r3, #72]	; 0x48
600030ae:	0792      	lsls	r2, r2, #30
600030b0:	d4fc      	bmi.n	600030ac <imxrt_init+0x158>
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
600030b2:	695a      	ldr	r2, [r3, #20]
600030b4:	f442 7240 	orr.w	r2, r2, #768	; 0x300
600030b8:	615a      	str	r2, [r3, #20]
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
600030ba:	699a      	ldr	r2, [r3, #24]
600030bc:	f442 2240 	orr.w	r2, r2, #786432	; 0xc0000
600030c0:	619a      	str	r2, [r3, #24]
600030c2:	695a      	ldr	r2, [r3, #20]
600030c4:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
600030c8:	615a      	str	r2, [r3, #20]
        while ((CCM->CDHIPR & ((1UL << busyShift))) != 0UL)
600030ca:	4b13      	ldr	r3, [pc, #76]	; (60003118 <imxrt_init+0x1c4>)
600030cc:	6c98      	ldr	r0, [r3, #72]	; 0x48
600030ce:	f010 0020 	ands.w	r0, r0, #32
600030d2:	d1fb      	bne.n	600030cc <imxrt_init+0x178>
    CCM_TUPLE_REG(CCM, mux) = (CCM_TUPLE_REG(CCM, mux) & (~CCM_TUPLE_MASK(mux))) |
600030d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
600030d6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
600030da:	625a      	str	r2, [r3, #36]	; 0x24
    CCM_TUPLE_REG(CCM, divider) = (CCM_TUPLE_REG(CCM, divider) & (~CCM_TUPLE_MASK(divider))) |
600030dc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
600030de:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
600030e2:	625a      	str	r2, [r3, #36]	; 0x24
    CCM->CLPCR = (CCM->CLPCR & ~CCM_CLPCR_LPM_MASK) | CCM_CLPCR_LPM((uint32_t)mode);
600030e4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
600030e6:	f022 0203 	bic.w	r2, r2, #3
600030ea:	655a      	str	r2, [r3, #84]	; 0x54
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
600030ec:	f384 8811 	msr	BASEPRI, r4
600030f0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	/* restore interrupt state */
	irq_unlock(oldLevel);
	return 0;
}
600030f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
600030f6:	bf00      	nop
600030f8:	400b8000 	.word	0x400b8000
600030fc:	400d0000 	.word	0x400d0000
60003100:	400bc000 	.word	0x400bc000
60003104:	d928c520 	.word	0xd928c520
60003108:	e000ed00 	.word	0xe000ed00
6000310c:	80000ec4 	.word	0x80000ec4
60003110:	016e3600 	.word	0x016e3600
60003114:	80000ec0 	.word	0x80000ec0
60003118:	400fc000 	.word	0x400fc000
6000311c:	40080000 	.word	0x40080000
60003120:	6000d02c 	.word	0x6000d02c
60003124:	6000d034 	.word	0x6000d034
60003128:	6000d769 	.word	0x6000d769

6000312c <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
6000312c:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
6000312e:	2200      	movs	r2, #0
{
60003130:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
60003132:	490f      	ldr	r1, [pc, #60]	; (60003170 <enable_logger+0x44>)
60003134:	480f      	ldr	r0, [pc, #60]	; (60003174 <enable_logger+0x48>)
60003136:	f009 fa07 	bl	6000c548 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
6000313a:	2200      	movs	r2, #0
6000313c:	2300      	movs	r3, #0
6000313e:	2400      	movs	r4, #0
60003140:	4d0d      	ldr	r5, [pc, #52]	; (60003178 <enable_logger+0x4c>)
60003142:	490e      	ldr	r1, [pc, #56]	; (6000317c <enable_logger+0x50>)
60003144:	4628      	mov	r0, r5
60003146:	9400      	str	r4, [sp, #0]
60003148:	e9cd 2306 	strd	r2, r3, [sp, #24]
6000314c:	230e      	movs	r3, #14
6000314e:	f44f 7240 	mov.w	r2, #768	; 0x300
60003152:	e9cd 3403 	strd	r3, r4, [sp, #12]
60003156:	e9cd 4401 	strd	r4, r4, [sp, #4]
6000315a:	4b09      	ldr	r3, [pc, #36]	; (60003180 <enable_logger+0x54>)
6000315c:	f005 f940 	bl	600083e0 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
60003160:	4908      	ldr	r1, [pc, #32]	; (60003184 <enable_logger+0x58>)
60003162:	4628      	mov	r0, r5
60003164:	f005 f878 	bl	60008258 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
60003168:	4620      	mov	r0, r4
6000316a:	b009      	add	sp, #36	; 0x24
6000316c:	bd30      	pop	{r4, r5, pc}
6000316e:	bf00      	nop
60003170:	60003189 	.word	0x60003189
60003174:	800005a8 	.word	0x800005a8
60003178:	800005e0 	.word	0x800005e0
6000317c:	80002120 	.word	0x80002120
60003180:	60003689 	.word	0x60003689
60003184:	6000dae9 	.word	0x6000dae9

60003188 <log_process_thread_timer_expiry_fn>:
	z_impl_k_sem_give(sem);
60003188:	4801      	ldr	r0, [pc, #4]	; (60003190 <log_process_thread_timer_expiry_fn+0x8>)
6000318a:	f005 bb31 	b.w	600087f0 <z_impl_k_sem_give>
6000318e:	bf00      	nop
60003190:	80000290 	.word	0x80000290

60003194 <log_core_init>:
{
60003194:	b538      	push	{r3, r4, r5, lr}
	panic_mode = false;
60003196:	2400      	movs	r4, #0
60003198:	4b14      	ldr	r3, [pc, #80]	; (600031ec <log_core_init+0x58>)
		timestamp_func = default_lf_get_timestamp;
6000319a:	4a15      	ldr	r2, [pc, #84]	; (600031f0 <log_core_init+0x5c>)
	log_output_timestamp_freq_set(freq);
6000319c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	panic_mode = false;
600031a0:	701c      	strb	r4, [r3, #0]
		timestamp_func = default_lf_get_timestamp;
600031a2:	4b14      	ldr	r3, [pc, #80]	; (600031f4 <log_core_init+0x60>)
600031a4:	4d14      	ldr	r5, [pc, #80]	; (600031f8 <log_core_init+0x64>)
600031a6:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
600031a8:	f000 fd7e 	bl	60003ca8 <log_output_timestamp_freq_set>
		log_msg_pool_init();
600031ac:	f000 fb30 	bl	60003810 <log_msg_pool_init>
		log_list_init(&list);
600031b0:	4812      	ldr	r0, [pc, #72]	; (600031fc <log_core_init+0x68>)
600031b2:	f006 fedd 	bl	60009f70 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
600031b6:	2304      	movs	r3, #4
600031b8:	2228      	movs	r2, #40	; 0x28
600031ba:	4911      	ldr	r1, [pc, #68]	; (60003200 <log_core_init+0x6c>)
600031bc:	4811      	ldr	r0, [pc, #68]	; (60003204 <log_core_init+0x70>)
600031be:	f008 ffae 	bl	6000c11e <k_mem_slab_init>
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
600031c2:	4811      	ldr	r0, [pc, #68]	; (60003208 <log_core_init+0x74>)
600031c4:	4a11      	ldr	r2, [pc, #68]	; (6000320c <log_core_init+0x78>)
		for (int i = 0; i < log_sources_count(); i++) {
600031c6:	4623      	mov	r3, r4
600031c8:	1a12      	subs	r2, r2, r0
	return __log_const_start[source_id].level;
600031ca:	3004      	adds	r0, #4
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
600031cc:	08d2      	lsrs	r2, r2, #3
600031ce:	4293      	cmp	r3, r2
600031d0:	d100      	bne.n	600031d4 <log_core_init+0x40>
}
600031d2:	bd38      	pop	{r3, r4, r5, pc}
			LOG_FILTER_SLOT_SET(filters,
600031d4:	f810 1033 	ldrb.w	r1, [r0, r3, lsl #3]
		for (int i = 0; i < log_sources_count(); i++) {
600031d8:	3301      	adds	r3, #1
			LOG_FILTER_SLOT_SET(filters,
600031da:	682c      	ldr	r4, [r5, #0]
600031dc:	f001 0107 	and.w	r1, r1, #7
600031e0:	f024 0407 	bic.w	r4, r4, #7
600031e4:	4321      	orrs	r1, r4
600031e6:	f845 1b04 	str.w	r1, [r5], #4
		for (int i = 0; i < log_sources_count(); i++) {
600031ea:	e7f0      	b.n	600031ce <log_core_init+0x3a>
600031ec:	80000f3d 	.word	0x80000f3d
600031f0:	60009faf 	.word	0x60009faf
600031f4:	800000e4 	.word	0x800000e4
600031f8:	80000234 	.word	0x80000234
600031fc:	80000a98 	.word	0x80000a98
60003200:	80003e20 	.word	0x80003e20
60003204:	80000aa0 	.word	0x80000aa0
60003208:	6000ceb8 	.word	0x6000ceb8
6000320c:	6000cee8 	.word	0x6000cee8

60003210 <get_msg>:
{
60003210:	b510      	push	{r4, lr}
	__asm__ volatile(
60003212:	f04f 0310 	mov.w	r3, #16
60003216:	f3ef 8411 	mrs	r4, BASEPRI
6000321a:	f383 8811 	msr	BASEPRI, r3
6000321e:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
60003222:	4804      	ldr	r0, [pc, #16]	; (60003234 <get_msg+0x24>)
60003224:	f006 feb4 	bl	60009f90 <log_list_head_get>
	__asm__ volatile(
60003228:	f384 8811 	msr	BASEPRI, r4
6000322c:	f3bf 8f6f 	isb	sy
}
60003230:	bd10      	pop	{r4, pc}
60003232:	bf00      	nop
60003234:	80000a98 	.word	0x80000a98

60003238 <z_log_dropped>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
60003238:	4b06      	ldr	r3, [pc, #24]	; (60003254 <z_log_dropped+0x1c>)
6000323a:	f3bf 8f5b 	dmb	ish
6000323e:	e853 2f00 	ldrex	r2, [r3]
60003242:	3201      	adds	r2, #1
60003244:	e843 2100 	strex	r1, r2, [r3]
60003248:	2900      	cmp	r1, #0
6000324a:	d1f8      	bne.n	6000323e <z_log_dropped+0x6>
6000324c:	f3bf 8f5b 	dmb	ish
}
60003250:	4770      	bx	lr
60003252:	bf00      	nop
60003254:	80000a90 	.word	0x80000a90

60003258 <z_log_dropped_read_and_clear>:
}
60003258:	2000      	movs	r0, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
6000325a:	4b06      	ldr	r3, [pc, #24]	; (60003274 <z_log_dropped_read_and_clear+0x1c>)
6000325c:	f3bf 8f5b 	dmb	ish
60003260:	4602      	mov	r2, r0
60003262:	e853 0f00 	ldrex	r0, [r3]
60003266:	e843 2100 	strex	r1, r2, [r3]
6000326a:	2900      	cmp	r1, #0
6000326c:	d1f9      	bne.n	60003262 <z_log_dropped_read_and_clear+0xa>
6000326e:	f3bf 8f5b 	dmb	ish
60003272:	4770      	bx	lr
60003274:	80000a90 	.word	0x80000a90

60003278 <dropped_notify>:
{
60003278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
6000327a:	4c0b      	ldr	r4, [pc, #44]	; (600032a8 <dropped_notify+0x30>)
	uint32_t dropped = z_log_dropped_read_and_clear();
6000327c:	f7ff ffec 	bl	60003258 <z_log_dropped_read_and_clear>
60003280:	4d0a      	ldr	r5, [pc, #40]	; (600032ac <dropped_notify+0x34>)
60003282:	4607      	mov	r7, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
60003284:	2600      	movs	r6, #0
60003286:	1b2d      	subs	r5, r5, r4
60003288:	112d      	asrs	r5, r5, #4
6000328a:	42ae      	cmp	r6, r5
6000328c:	db00      	blt.n	60003290 <dropped_notify+0x18>
}
6000328e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
60003290:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
60003292:	795b      	ldrb	r3, [r3, #5]
60003294:	b12b      	cbz	r3, 600032a2 <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
60003296:	6823      	ldr	r3, [r4, #0]
60003298:	691b      	ldr	r3, [r3, #16]
6000329a:	b113      	cbz	r3, 600032a2 <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
6000329c:	4639      	mov	r1, r7
6000329e:	4620      	mov	r0, r4
600032a0:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
600032a2:	3601      	adds	r6, #1
600032a4:	3410      	adds	r4, #16
600032a6:	e7f0      	b.n	6000328a <dropped_notify+0x12>
600032a8:	6000cee8 	.word	0x6000cee8
600032ac:	6000cf08 	.word	0x6000cf08

600032b0 <log_source_name_get>:
600032b0:	4a04      	ldr	r2, [pc, #16]	; (600032c4 <log_source_name_get+0x14>)
600032b2:	4b05      	ldr	r3, [pc, #20]	; (600032c8 <log_source_name_get+0x18>)
600032b4:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
600032b6:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
600032ba:	bf34      	ite	cc
600032bc:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
600032c0:	2000      	movcs	r0, #0
}
600032c2:	4770      	bx	lr
600032c4:	6000ceb8 	.word	0x6000ceb8
600032c8:	6000cee8 	.word	0x6000cee8

600032cc <z_impl_log_filter_set>:
{
600032cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
600032d0:	4689      	mov	r9, r1
600032d2:	4616      	mov	r6, r2
600032d4:	4698      	mov	r8, r3
		if (backend == NULL) {
600032d6:	4604      	mov	r4, r0
600032d8:	b9c0      	cbnz	r0, 6000330c <z_impl_log_filter_set+0x40>
	return __log_backends_end - __log_backends_start;
600032da:	f8df a088 	ldr.w	sl, [pc, #136]	; 60003364 <z_impl_log_filter_set+0x98>
			uint32_t max = 0U;
600032de:	4605      	mov	r5, r0
600032e0:	4f21      	ldr	r7, [pc, #132]	; (60003368 <z_impl_log_filter_set+0x9c>)
600032e2:	eba7 070a 	sub.w	r7, r7, sl
600032e6:	113f      	asrs	r7, r7, #4
			for (int i = 0; i < log_backend_count_get(); i++) {
600032e8:	42bc      	cmp	r4, r7
600032ea:	db02      	blt.n	600032f2 <z_impl_log_filter_set+0x26>
}
600032ec:	4628      	mov	r0, r5
600032ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		/* coverity[OVERRUN] */
		return (uint32_t) arch_syscall_invoke4(*(uintptr_t *)&backend, *(uintptr_t *)&domain_id, *(uintptr_t *)&source_id, *(uintptr_t *)&level, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
600032f2:	eb0a 1004 	add.w	r0, sl, r4, lsl #4
600032f6:	4643      	mov	r3, r8
600032f8:	4632      	mov	r2, r6
600032fa:	4649      	mov	r1, r9
600032fc:	f7ff ffe6 	bl	600032cc <z_impl_log_filter_set>
				max = MAX(current, max);
60003300:	4285      	cmp	r5, r0
			for (int i = 0; i < log_backend_count_get(); i++) {
60003302:	f104 0401 	add.w	r4, r4, #1
				max = MAX(current, max);
60003306:	bf38      	it	cc
60003308:	4605      	movcc	r5, r0
			for (int i = 0; i < log_backend_count_get(); i++) {
6000330a:	e7ed      	b.n	600032e8 <z_impl_log_filter_set+0x1c>
	return __log_const_start[source_id].level;
6000330c:	4b17      	ldr	r3, [pc, #92]	; (6000336c <z_impl_log_filter_set+0xa0>)
			LOG_FILTER_SLOT_SET(filters,
6000330e:	4c18      	ldr	r4, [pc, #96]	; (60003370 <z_impl_log_filter_set+0xa4>)
60003310:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
	return log_compiled_level_get(source_id);
60003314:	791d      	ldrb	r5, [r3, #4]
	return backend->cb->id;
60003316:	6843      	ldr	r3, [r0, #4]
			level = MIN(level, max);
60003318:	4545      	cmp	r5, r8
			LOG_FILTER_SLOT_SET(filters,
6000331a:	791a      	ldrb	r2, [r3, #4]
6000331c:	f04f 0307 	mov.w	r3, #7
			level = MIN(level, max);
60003320:	bf28      	it	cs
60003322:	4645      	movcs	r5, r8
			LOG_FILTER_SLOT_SET(filters,
60003324:	eb02 0242 	add.w	r2, r2, r2, lsl #1
60003328:	fa03 f102 	lsl.w	r1, r3, r2
6000332c:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
60003330:	ea23 0301 	bic.w	r3, r3, r1
60003334:	f005 0107 	and.w	r1, r5, #7
60003338:	fa01 f202 	lsl.w	r2, r1, r2
	uint32_t max_filter = LOG_LEVEL_NONE;
6000333c:	2100      	movs	r1, #0
			LOG_FILTER_SLOT_SET(filters,
6000333e:	4313      	orrs	r3, r2
60003340:	2203      	movs	r2, #3
		uint32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
60003342:	fa23 f002 	lsr.w	r0, r3, r2
60003346:	3203      	adds	r2, #3
60003348:	f000 0007 	and.w	r0, r0, #7
6000334c:	4281      	cmp	r1, r0
6000334e:	bf38      	it	cc
60003350:	4601      	movcc	r1, r0
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
60003352:	2a1e      	cmp	r2, #30
60003354:	d1f5      	bne.n	60003342 <z_impl_log_filter_set+0x76>
			LOG_FILTER_SLOT_SET(filters,
60003356:	f023 0307 	bic.w	r3, r3, #7
6000335a:	430b      	orrs	r3, r1
6000335c:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
	return level;
60003360:	e7c4      	b.n	600032ec <z_impl_log_filter_set+0x20>
60003362:	bf00      	nop
60003364:	6000cee8 	.word	0x6000cee8
60003368:	6000cf08 	.word	0x6000cf08
6000336c:	6000ceb8 	.word	0x6000ceb8
60003370:	80000234 	.word	0x80000234

60003374 <backend_filter_set>:
{
60003374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
60003376:	4c09      	ldr	r4, [pc, #36]	; (6000339c <backend_filter_set+0x28>)
60003378:	4606      	mov	r6, r0
6000337a:	4b09      	ldr	r3, [pc, #36]	; (600033a0 <backend_filter_set+0x2c>)
6000337c:	460f      	mov	r7, r1
		for (int i = 0; i < log_sources_count(); i++) {
6000337e:	2500      	movs	r5, #0
60003380:	1ae4      	subs	r4, r4, r3
60003382:	08e4      	lsrs	r4, r4, #3
60003384:	42a5      	cmp	r5, r4
60003386:	d100      	bne.n	6000338a <backend_filter_set+0x16>
}
60003388:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
6000338a:	2100      	movs	r1, #0
6000338c:	b22a      	sxth	r2, r5
6000338e:	463b      	mov	r3, r7
60003390:	4630      	mov	r0, r6
		for (int i = 0; i < log_sources_count(); i++) {
60003392:	3501      	adds	r5, #1
60003394:	f7ff ff9a 	bl	600032cc <z_impl_log_filter_set>
60003398:	e7f4      	b.n	60003384 <backend_filter_set+0x10>
6000339a:	bf00      	nop
6000339c:	6000cee8 	.word	0x6000cee8
600033a0:	6000ceb8 	.word	0x6000ceb8

600033a4 <log_backend_enable>:
	id += backend - log_backend_get(0);
600033a4:	4b0c      	ldr	r3, [pc, #48]	; (600033d8 <log_backend_enable+0x34>)
600033a6:	1ac3      	subs	r3, r0, r3
600033a8:	111b      	asrs	r3, r3, #4
{
600033aa:	b570      	push	{r4, r5, r6, lr}
	id += backend - log_backend_get(0);
600033ac:	3301      	adds	r3, #1
	backend->cb->id = id;
600033ae:	6846      	ldr	r6, [r0, #4]
{
600033b0:	4604      	mov	r4, r0
600033b2:	460d      	mov	r5, r1
	log_backend_id_set(backend, id);
600033b4:	7133      	strb	r3, [r6, #4]
	backend_filter_set(backend, level);
600033b6:	4611      	mov	r1, r2
600033b8:	f7ff ffdc 	bl	60003374 <backend_filter_set>
	backend->cb->ctx = ctx;
600033bc:	6863      	ldr	r3, [r4, #4]
	backend->cb->active = true;
600033be:	2201      	movs	r2, #1
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
600033c0:	4c06      	ldr	r4, [pc, #24]	; (600033dc <log_backend_enable+0x38>)
	backend->cb->ctx = ctx;
600033c2:	601d      	str	r5, [r3, #0]
	backend->cb->active = true;
600033c4:	715a      	strb	r2, [r3, #5]
600033c6:	7823      	ldrb	r3, [r4, #0]
600033c8:	b913      	cbnz	r3, 600033d0 <log_backend_enable+0x2c>
600033ca:	4805      	ldr	r0, [pc, #20]	; (600033e0 <log_backend_enable+0x3c>)
600033cc:	f005 fa10 	bl	600087f0 <z_impl_k_sem_give>
	backend_attached = true;
600033d0:	2301      	movs	r3, #1
600033d2:	7023      	strb	r3, [r4, #0]
}
600033d4:	bd70      	pop	{r4, r5, r6, pc}
600033d6:	bf00      	nop
600033d8:	6000cee8 	.word	0x6000cee8
600033dc:	80000f3c 	.word	0x80000f3c
600033e0:	80000290 	.word	0x80000290

600033e4 <log_init>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
600033e4:	4b12      	ldr	r3, [pc, #72]	; (60003430 <log_init+0x4c>)
{
600033e6:	b570      	push	{r4, r5, r6, lr}
600033e8:	f3bf 8f5b 	dmb	ish
600033ec:	e853 5f00 	ldrex	r5, [r3]
600033f0:	1c6a      	adds	r2, r5, #1
600033f2:	e843 2100 	strex	r1, r2, [r3]
600033f6:	2900      	cmp	r1, #0
600033f8:	d1f8      	bne.n	600033ec <log_init+0x8>
600033fa:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
600033fe:	b92d      	cbnz	r5, 6000340c <log_init+0x28>
	return __log_backends_end - __log_backends_start;
60003400:	4c0c      	ldr	r4, [pc, #48]	; (60003434 <log_init+0x50>)
60003402:	4e0d      	ldr	r6, [pc, #52]	; (60003438 <log_init+0x54>)
60003404:	1b36      	subs	r6, r6, r4
60003406:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
60003408:	42b5      	cmp	r5, r6
6000340a:	db00      	blt.n	6000340e <log_init+0x2a>
}
6000340c:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
6000340e:	7b23      	ldrb	r3, [r4, #12]
60003410:	b153      	cbz	r3, 60003428 <log_init+0x44>
			if (backend->api->init != NULL) {
60003412:	6823      	ldr	r3, [r4, #0]
60003414:	699b      	ldr	r3, [r3, #24]
60003416:	b10b      	cbz	r3, 6000341c <log_init+0x38>
				backend->api->init(backend);
60003418:	4620      	mov	r0, r4
6000341a:	4798      	blx	r3
			log_backend_enable(backend,
6000341c:	6863      	ldr	r3, [r4, #4]
6000341e:	2204      	movs	r2, #4
60003420:	4620      	mov	r0, r4
60003422:	6819      	ldr	r1, [r3, #0]
60003424:	f7ff ffbe 	bl	600033a4 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
60003428:	3501      	adds	r5, #1
6000342a:	3410      	adds	r4, #16
6000342c:	e7ec      	b.n	60003408 <log_init+0x24>
6000342e:	bf00      	nop
60003430:	80000a94 	.word	0x80000a94
60003434:	6000cee8 	.word	0x6000cee8
60003438:	6000cf08 	.word	0x6000cf08

6000343c <log_filter_get>:
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
6000343c:	b163      	cbz	r3, 60003458 <log_filter_get+0x1c>
		if (source_id < 0) {
6000343e:	2a00      	cmp	r2, #0
60003440:	db0f      	blt.n	60003462 <log_filter_get+0x26>
	return backend->cb->id;
60003442:	6843      	ldr	r3, [r0, #4]
		return LOG_FILTER_SLOT_GET(filters,
60003444:	4908      	ldr	r1, [pc, #32]	; (60003468 <log_filter_get+0x2c>)
60003446:	7918      	ldrb	r0, [r3, #4]
60003448:	eb00 0340 	add.w	r3, r0, r0, lsl #1
6000344c:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
60003450:	40d8      	lsrs	r0, r3
60003452:	f000 0007 	and.w	r0, r0, #7
60003456:	4770      	bx	lr
	return __log_const_start[source_id].level;
60003458:	4b04      	ldr	r3, [pc, #16]	; (6000346c <log_filter_get+0x30>)
6000345a:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
	return log_compiled_level_get(source_id);
6000345e:	7910      	ldrb	r0, [r2, #4]
60003460:	4770      	bx	lr
			return LOG_LEVEL_DBG;
60003462:	2004      	movs	r0, #4
}
60003464:	4770      	bx	lr
60003466:	bf00      	nop
60003468:	80000234 	.word	0x80000234
6000346c:	6000ceb8 	.word	0x6000ceb8

60003470 <z_log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
60003470:	4b16      	ldr	r3, [pc, #88]	; (600034cc <z_log_strdup+0x5c>)
60003472:	4298      	cmp	r0, r3
{
60003474:	b537      	push	{r0, r1, r2, r4, r5, lr}
60003476:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
60003478:	d302      	bcc.n	60003480 <z_log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
6000347a:	4b15      	ldr	r3, [pc, #84]	; (600034d0 <z_log_strdup+0x60>)
6000347c:	4298      	cmp	r0, r3
6000347e:	d31f      	bcc.n	600034c0 <z_log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
60003480:	2200      	movs	r2, #0
60003482:	2300      	movs	r3, #0
60003484:	a901      	add	r1, sp, #4
60003486:	4813      	ldr	r0, [pc, #76]	; (600034d4 <z_log_strdup+0x64>)
60003488:	f004 fe64 	bl	60008154 <k_mem_slab_alloc>
	if (err != 0) {
6000348c:	4605      	mov	r5, r0
6000348e:	b9d0      	cbnz	r0, 600034c6 <z_log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
60003490:	2201      	movs	r2, #1
60003492:	9b01      	ldr	r3, [sp, #4]
60003494:	f3bf 8f5b 	dmb	ish
60003498:	e853 1f00 	ldrex	r1, [r3]
6000349c:	e843 2000 	strex	r0, r2, [r3]
600034a0:	2800      	cmp	r0, #0
600034a2:	d1f9      	bne.n	60003498 <z_log_strdup+0x28>
600034a4:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
600034a8:	4621      	mov	r1, r4
600034aa:	9801      	ldr	r0, [sp, #4]
600034ac:	221f      	movs	r2, #31
600034ae:	3004      	adds	r0, #4
600034b0:	f008 f9da 	bl	6000b868 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
600034b4:	9c01      	ldr	r4, [sp, #4]
600034b6:	237e      	movs	r3, #126	; 0x7e
	dup->buf[sizeof(dup->buf) - 1] = '\0';
600034b8:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
600034bc:	3404      	adds	r4, #4
	dup->buf[sizeof(dup->buf) - 2] = '~';
600034be:	77e3      	strb	r3, [r4, #31]
}
600034c0:	4620      	mov	r0, r4
600034c2:	b003      	add	sp, #12
600034c4:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
600034c6:	4c04      	ldr	r4, [pc, #16]	; (600034d8 <z_log_strdup+0x68>)
600034c8:	e7fa      	b.n	600034c0 <z_log_strdup+0x50>
600034ca:	bf00      	nop
600034cc:	6000c920 	.word	0x6000c920
600034d0:	6000ec68 	.word	0x6000ec68
600034d4:	80000aa0 	.word	0x80000aa0
600034d8:	6000d76b 	.word	0x6000d76b

600034dc <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
600034dc:	b148      	cbz	r0, 600034f2 <log_is_strdup+0x16>
600034de:	4b05      	ldr	r3, [pc, #20]	; (600034f4 <log_is_strdup+0x18>)
600034e0:	4298      	cmp	r0, r3
600034e2:	d305      	bcc.n	600034f0 <log_is_strdup+0x14>
600034e4:	33a0      	adds	r3, #160	; 0xa0
600034e6:	4298      	cmp	r0, r3
600034e8:	bf2c      	ite	cs
600034ea:	2000      	movcs	r0, #0
600034ec:	2001      	movcc	r0, #1
600034ee:	4770      	bx	lr
600034f0:	2000      	movs	r0, #0
}
600034f2:	4770      	bx	lr
600034f4:	80003e20 	.word	0x80003e20

600034f8 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
600034f8:	4b54      	ldr	r3, [pc, #336]	; (6000364c <z_impl_log_process+0x154>)
600034fa:	781b      	ldrb	r3, [r3, #0]
{
600034fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003500:	4605      	mov	r5, r0
60003502:	b085      	sub	sp, #20
	if (!backend_attached && !bypass) {
60003504:	b903      	cbnz	r3, 60003508 <z_impl_log_process+0x10>
60003506:	b300      	cbz	r0, 6000354a <z_impl_log_process+0x52>
	msg = get_msg();
60003508:	f7ff fe82 	bl	60003210 <get_msg>
	if (msg.msg) {
6000350c:	4604      	mov	r4, r0
6000350e:	b178      	cbz	r0, 60003530 <z_impl_log_process+0x38>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
60003510:	4b4f      	ldr	r3, [pc, #316]	; (60003650 <z_impl_log_process+0x158>)
60003512:	f3bf 8f5b 	dmb	ish
60003516:	e853 2f00 	ldrex	r2, [r3]
6000351a:	3a01      	subs	r2, #1
6000351c:	e843 2100 	strex	r1, r2, [r3]
60003520:	2900      	cmp	r1, #0
60003522:	d1f8      	bne.n	60003516 <z_impl_log_process+0x1e>
60003524:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
60003528:	b19d      	cbz	r5, 60003552 <z_impl_log_process+0x5a>
			log_msg_put(msg.msg);
6000352a:	4620      	mov	r0, r4
6000352c:	f006 fe63 	bl	6000a1f6 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
60003530:	b92d      	cbnz	r5, 6000353e <z_impl_log_process+0x46>
	return dropped_cnt > 0;
60003532:	4b48      	ldr	r3, [pc, #288]	; (60003654 <z_impl_log_process+0x15c>)
	if (!bypass && z_log_dropped_pending()) {
60003534:	681b      	ldr	r3, [r3, #0]
60003536:	2b00      	cmp	r3, #0
60003538:	dd01      	ble.n	6000353e <z_impl_log_process+0x46>
		dropped_notify();
6000353a:	f7ff fe9d 	bl	60003278 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
6000353e:	4846      	ldr	r0, [pc, #280]	; (60003658 <z_impl_log_process+0x160>)
60003540:	f006 fd24 	bl	60009f8c <log_list_head_peek>
60003544:	1e05      	subs	r5, r0, #0
60003546:	bf18      	it	ne
60003548:	2501      	movne	r5, #1
}
6000354a:	4628      	mov	r0, r5
6000354c:	b005      	add	sp, #20
6000354e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
60003552:	4b42      	ldr	r3, [pc, #264]	; (6000365c <z_impl_log_process+0x164>)
		if (!IS_ENABLED(CONFIG_LOG2) &&
60003554:	781b      	ldrb	r3, [r3, #0]
60003556:	b9f3      	cbnz	r3, 60003596 <z_impl_log_process+0x9e>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
60003558:	7a23      	ldrb	r3, [r4, #8]
	if (!log_msg_is_std(msg)) {
6000355a:	07da      	lsls	r2, r3, #31
6000355c:	d41b      	bmi.n	60003596 <z_impl_log_process+0x9e>
	msg_str = log_msg_str_get(msg);
6000355e:	f006 fe5d 	bl	6000a21c <log_msg_str_get>
60003562:	4607      	mov	r7, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
60003564:	4620      	mov	r0, r4
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
60003566:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 60003660 <z_impl_log_process+0x168>
6000356a:	f006 fe22 	bl	6000a1b2 <log_msg_nargs_get>
6000356e:	4601      	mov	r1, r0
60003570:	4638      	mov	r0, r7
 *
 * @return Source ID.
 */
static inline uint32_t log_dynamic_source_id(struct log_source_dynamic_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
60003572:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 60003664 <z_impl_log_process+0x16c>
60003576:	f006 fd24 	bl	60009fc2 <z_log_get_s_mask>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
6000357a:	4b3b      	ldr	r3, [pc, #236]	; (60003668 <z_impl_log_process+0x170>)
6000357c:	4606      	mov	r6, r0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
6000357e:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 6000366c <z_impl_log_process+0x174>
60003582:	eba3 0308 	sub.w	r3, r3, r8
60003586:	08db      	lsrs	r3, r3, #3
60003588:	9302      	str	r3, [sp, #8]
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
6000358a:	4b39      	ldr	r3, [pc, #228]	; (60003670 <z_impl_log_process+0x178>)
6000358c:	eba9 0303 	sub.w	r3, r9, r3
60003590:	089b      	lsrs	r3, r3, #2
60003592:	9303      	str	r3, [sp, #12]
	while (mask) {
60003594:	b946      	cbnz	r6, 600035a8 <z_impl_log_process+0xb0>
	return __log_backends_end - __log_backends_start;
60003596:	4e37      	ldr	r6, [pc, #220]	; (60003674 <z_impl_log_process+0x17c>)
60003598:	f04f 0800 	mov.w	r8, #0
6000359c:	4f36      	ldr	r7, [pc, #216]	; (60003678 <z_impl_log_process+0x180>)
		return LOG_FILTER_SLOT_GET(filters,
6000359e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 60003670 <z_impl_log_process+0x178>
600035a2:	1bbf      	subs	r7, r7, r6
600035a4:	113f      	asrs	r7, r7, #4
600035a6:	e04e      	b.n	60003646 <z_impl_log_process+0x14e>
		idx = 31 - __builtin_clz(mask);
600035a8:	fab6 f186 	clz	r1, r6
		str = (const char *)log_msg_arg_get(msg, idx);
600035ac:	4620      	mov	r0, r4
		idx = 31 - __builtin_clz(mask);
600035ae:	f1c1 0a1f 	rsb	sl, r1, #31
		str = (const char *)log_msg_arg_get(msg, idx);
600035b2:	4651      	mov	r1, sl
600035b4:	f006 fe00 	bl	6000a1b8 <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
600035b8:	4b30      	ldr	r3, [pc, #192]	; (6000367c <z_impl_log_process+0x184>)
		str = (const char *)log_msg_arg_get(msg, idx);
600035ba:	4601      	mov	r1, r0
	return (((const char *)addr >= (const char *)RO_START) &&
600035bc:	4298      	cmp	r0, r3
600035be:	d302      	bcc.n	600035c6 <z_impl_log_process+0xce>
		if (!is_rodata(str) && !log_is_strdup(str) &&
600035c0:	4a2f      	ldr	r2, [pc, #188]	; (60003680 <z_impl_log_process+0x188>)
600035c2:	4290      	cmp	r0, r2
600035c4:	d31e      	bcc.n	60003604 <z_impl_log_process+0x10c>
600035c6:	4608      	mov	r0, r1
600035c8:	f7ff ff88 	bl	600034dc <log_is_strdup>
600035cc:	4602      	mov	r2, r0
600035ce:	b9c8      	cbnz	r0, 60003604 <z_impl_log_process+0x10c>
600035d0:	4b2c      	ldr	r3, [pc, #176]	; (60003684 <z_impl_log_process+0x18c>)
600035d2:	4299      	cmp	r1, r3
600035d4:	d016      	beq.n	60003604 <z_impl_log_process+0x10c>
	return msg->hdr.ids.source_id;
600035d6:	8963      	ldrh	r3, [r4, #10]
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
600035d8:	9902      	ldr	r1, [sp, #8]
600035da:	f3c3 1389 	ubfx	r3, r3, #6, #10
600035de:	428b      	cmp	r3, r1
	return __log_const_start[source_id].name;
600035e0:	bf38      	it	cc
600035e2:	f858 2033 	ldrcc.w	r2, [r8, r3, lsl #3]
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
600035e6:	f8d9 3000 	ldr.w	r3, [r9]
600035ea:	075b      	lsls	r3, r3, #29
600035ec:	d00a      	beq.n	60003604 <z_impl_log_process+0x10c>
600035ee:	9b03      	ldr	r3, [sp, #12]
600035f0:	4651      	mov	r1, sl
600035f2:	4658      	mov	r0, fp
600035f4:	019b      	lsls	r3, r3, #6
600035f6:	f043 0301 	orr.w	r3, r3, #1
600035fa:	f8ad 3000 	strh.w	r3, [sp]
600035fe:	463b      	mov	r3, r7
60003600:	f006 fd40 	bl	6000a084 <log_3>
		mask &= ~BIT(idx);
60003604:	2301      	movs	r3, #1
60003606:	fa03 f10a 	lsl.w	r1, r3, sl
6000360a:	ea26 0601 	bic.w	r6, r6, r1
6000360e:	e7c1      	b.n	60003594 <z_impl_log_process+0x9c>
	return backend->cb->active;
60003610:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
60003612:	795a      	ldrb	r2, [r3, #5]
60003614:	b1a2      	cbz	r2, 60003640 <z_impl_log_process+0x148>
60003616:	8960      	ldrh	r0, [r4, #10]
		return LOG_FILTER_SLOT_GET(filters,
60003618:	791b      	ldrb	r3, [r3, #4]
		uint32_t *filters = log_dynamic_filters_get(source_id);
6000361a:	f3c0 1089 	ubfx	r0, r0, #6, #10
	return msg->hdr.ids.level;
6000361e:	7aa1      	ldrb	r1, [r4, #10]
		return LOG_FILTER_SLOT_GET(filters,
60003620:	eb03 0243 	add.w	r2, r3, r3, lsl #1
60003624:	f859 3020 	ldr.w	r3, [r9, r0, lsl #2]
60003628:	f001 0107 	and.w	r1, r1, #7
6000362c:	40d3      	lsrs	r3, r2
6000362e:	f003 0307 	and.w	r3, r3, #7
			if (log_backend_is_active(backend) &&
60003632:	4299      	cmp	r1, r3
60003634:	d804      	bhi.n	60003640 <z_impl_log_process+0x148>
	backend->api->put(backend, msg);
60003636:	6833      	ldr	r3, [r6, #0]
60003638:	4621      	mov	r1, r4
6000363a:	4630      	mov	r0, r6
6000363c:	685b      	ldr	r3, [r3, #4]
6000363e:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
60003640:	f108 0801 	add.w	r8, r8, #1
60003644:	3610      	adds	r6, #16
60003646:	45b8      	cmp	r8, r7
60003648:	dbe2      	blt.n	60003610 <z_impl_log_process+0x118>
6000364a:	e76e      	b.n	6000352a <z_impl_log_process+0x32>
6000364c:	80000f3c 	.word	0x80000f3c
60003650:	80000a8c 	.word	0x80000a8c
60003654:	80000a90 	.word	0x80000a90
60003658:	80000a98 	.word	0x80000a98
6000365c:	80000f3d 	.word	0x80000f3d
60003660:	6000ceb8 	.word	0x6000ceb8
60003664:	80000238 	.word	0x80000238
60003668:	6000cee8 	.word	0x6000cee8
6000366c:	6000d785 	.word	0x6000d785
60003670:	80000234 	.word	0x80000234
60003674:	6000cee8 	.word	0x6000cee8
60003678:	6000cf08 	.word	0x6000cf08
6000367c:	6000c920 	.word	0x6000c920
60003680:	6000ec68 	.word	0x6000ec68
60003684:	6000d76b 	.word	0x6000d76b

60003688 <log_process_thread_func>:
{
60003688:	b510      	push	{r4, lr}
	log_init();
6000368a:	f7ff feab 	bl	600033e4 <log_init>
	return z_impl_k_current_get();
6000368e:	f005 fc3d 	bl	60008f0c <z_impl_k_current_get>
	proc_tid = process_tid;
60003692:	4b0c      	ldr	r3, [pc, #48]	; (600036c4 <log_process_thread_func+0x3c>)
60003694:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
60003696:	b130      	cbz	r0, 600036a6 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
60003698:	4b0b      	ldr	r3, [pc, #44]	; (600036c8 <log_process_thread_func+0x40>)
	    process_tid &&
6000369a:	681b      	ldr	r3, [r3, #0]
6000369c:	2b09      	cmp	r3, #9
6000369e:	dd02      	ble.n	600036a6 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
600036a0:	480a      	ldr	r0, [pc, #40]	; (600036cc <log_process_thread_func+0x44>)
600036a2:	f005 f8a5 	bl	600087f0 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
600036a6:	4c09      	ldr	r4, [pc, #36]	; (600036cc <log_process_thread_func+0x44>)
	return z_impl_log_process(bypass);
600036a8:	2000      	movs	r0, #0
600036aa:	f7ff ff25 	bl	600034f8 <z_impl_log_process>
		if (log_process(false) == false) {
600036ae:	2800      	cmp	r0, #0
600036b0:	d1fa      	bne.n	600036a8 <log_process_thread_func+0x20>
600036b2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
600036b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
600036ba:	4620      	mov	r0, r4
600036bc:	f005 f8c6 	bl	6000884c <z_impl_k_sem_take>
600036c0:	e7f2      	b.n	600036a8 <log_process_thread_func+0x20>
600036c2:	bf00      	nop
600036c4:	80000abc 	.word	0x80000abc
600036c8:	80000a8c 	.word	0x80000a8c
600036cc:	80000290 	.word	0x80000290

600036d0 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
600036d0:	4b29      	ldr	r3, [pc, #164]	; (60003778 <msg_finalize+0xa8>)
{
600036d2:	b537      	push	{r0, r1, r2, r4, r5, lr}
600036d4:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
600036d6:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
600036d8:	8141      	strh	r1, [r0, #10]
	msg->hdr.timestamp = timestamp_func();
600036da:	4798      	blx	r3
600036dc:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
600036de:	f04f 0310 	mov.w	r3, #16
600036e2:	f3ef 8511 	mrs	r5, BASEPRI
600036e6:	f383 8811 	msr	BASEPRI, r3
600036ea:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
600036ee:	4823      	ldr	r0, [pc, #140]	; (6000377c <msg_finalize+0xac>)
600036f0:	4621      	mov	r1, r4
600036f2:	f006 fc41 	bl	60009f78 <log_list_add_tail>
	__asm__ volatile(
600036f6:	f385 8811 	msr	BASEPRI, r5
600036fa:	f3bf 8f6f 	isb	sy
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
600036fe:	4b20      	ldr	r3, [pc, #128]	; (60003780 <msg_finalize+0xb0>)
60003700:	f3bf 8f5b 	dmb	ish
60003704:	e853 2f00 	ldrex	r2, [r3]
60003708:	3201      	adds	r2, #1
6000370a:	e843 2100 	strex	r1, r2, [r3]
6000370e:	2900      	cmp	r1, #0
60003710:	d1f8      	bne.n	60003704 <msg_finalize+0x34>
	if (panic_mode) {
60003712:	4a1c      	ldr	r2, [pc, #112]	; (60003784 <msg_finalize+0xb4>)
60003714:	f3bf 8f5b 	dmb	ish
60003718:	7812      	ldrb	r2, [r2, #0]
6000371a:	b182      	cbz	r2, 6000373e <msg_finalize+0x6e>
	__asm__ volatile(
6000371c:	f04f 0310 	mov.w	r3, #16
60003720:	f3ef 8411 	mrs	r4, BASEPRI
60003724:	f383 8811 	msr	BASEPRI, r3
60003728:	f3bf 8f6f 	isb	sy
6000372c:	2000      	movs	r0, #0
6000372e:	f7ff fee3 	bl	600034f8 <z_impl_log_process>
	__asm__ volatile(
60003732:	f384 8811 	msr	BASEPRI, r4
60003736:	f3bf 8f6f 	isb	sy
}
6000373a:	b003      	add	sp, #12
6000373c:	bd30      	pop	{r4, r5, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
6000373e:	4a12      	ldr	r2, [pc, #72]	; (60003788 <msg_finalize+0xb8>)
60003740:	681b      	ldr	r3, [r3, #0]
60003742:	6812      	ldr	r2, [r2, #0]
60003744:	2a00      	cmp	r2, #0
60003746:	d0f8      	beq.n	6000373a <msg_finalize+0x6a>
60003748:	2b01      	cmp	r3, #1
6000374a:	d10a      	bne.n	60003762 <msg_finalize+0x92>
	z_impl_k_timer_start(timer, duration, period);
6000374c:	2200      	movs	r2, #0
6000374e:	2300      	movs	r3, #0
60003750:	480e      	ldr	r0, [pc, #56]	; (6000378c <msg_finalize+0xbc>)
60003752:	e9cd 2300 	strd	r2, r3, [sp]
60003756:	f242 7210 	movw	r2, #10000	; 0x2710
6000375a:	2300      	movs	r3, #0
6000375c:	f005 fe64 	bl	60009428 <z_impl_k_timer_start>
60003760:	e7eb      	b.n	6000373a <msg_finalize+0x6a>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
60003762:	2b0a      	cmp	r3, #10
60003764:	d1e9      	bne.n	6000373a <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
60003766:	4809      	ldr	r0, [pc, #36]	; (6000378c <msg_finalize+0xbc>)
60003768:	f008 ff00 	bl	6000c56c <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
6000376c:	4808      	ldr	r0, [pc, #32]	; (60003790 <msg_finalize+0xc0>)
}
6000376e:	b003      	add	sp, #12
60003770:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
60003774:	f005 b83c 	b.w	600087f0 <z_impl_k_sem_give>
60003778:	800000e4 	.word	0x800000e4
6000377c:	80000a98 	.word	0x80000a98
60003780:	80000a8c 	.word	0x80000a8c
60003784:	80000f3d 	.word	0x80000f3d
60003788:	80000abc 	.word	0x80000abc
6000378c:	800005a8 	.word	0x800005a8
60003790:	80000290 	.word	0x80000290

60003794 <z_impl_log_panic>:
{
60003794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
60003796:	4f0e      	ldr	r7, [pc, #56]	; (600037d0 <z_impl_log_panic+0x3c>)
60003798:	783d      	ldrb	r5, [r7, #0]
6000379a:	b975      	cbnz	r5, 600037ba <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
6000379c:	4c0d      	ldr	r4, [pc, #52]	; (600037d4 <z_impl_log_panic+0x40>)
	log_init();
6000379e:	f7ff fe21 	bl	600033e4 <log_init>
600037a2:	4e0d      	ldr	r6, [pc, #52]	; (600037d8 <z_impl_log_panic+0x44>)
600037a4:	1b36      	subs	r6, r6, r4
600037a6:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
600037a8:	42b5      	cmp	r5, r6
600037aa:	db07      	blt.n	600037bc <z_impl_log_panic+0x28>
600037ac:	2000      	movs	r0, #0
600037ae:	f7ff fea3 	bl	600034f8 <z_impl_log_process>
		while (log_process(false) == true) {
600037b2:	2800      	cmp	r0, #0
600037b4:	d1fa      	bne.n	600037ac <z_impl_log_panic+0x18>
	panic_mode = true;
600037b6:	2301      	movs	r3, #1
600037b8:	703b      	strb	r3, [r7, #0]
}
600037ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
600037bc:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
600037be:	795b      	ldrb	r3, [r3, #5]
600037c0:	b11b      	cbz	r3, 600037ca <z_impl_log_panic+0x36>
	backend->api->panic(backend);
600037c2:	6823      	ldr	r3, [r4, #0]
600037c4:	4620      	mov	r0, r4
600037c6:	695b      	ldr	r3, [r3, #20]
600037c8:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
600037ca:	3501      	adds	r5, #1
600037cc:	3410      	adds	r4, #16
600037ce:	e7eb      	b.n	600037a8 <z_impl_log_panic+0x14>
600037d0:	80000f3d 	.word	0x80000f3d
600037d4:	6000cee8 	.word	0x6000cee8
600037d8:	6000cf08 	.word	0x6000cf08

600037dc <log_free>:
{
600037dc:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
600037de:	3804      	subs	r0, #4
600037e0:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
600037e2:	f3bf 8f5b 	dmb	ish
600037e6:	e850 3f00 	ldrex	r3, [r0]
600037ea:	1e5a      	subs	r2, r3, #1
600037ec:	e840 2100 	strex	r1, r2, [r0]
600037f0:	2900      	cmp	r1, #0
600037f2:	d1f8      	bne.n	600037e6 <log_free+0xa>
	if (atomic_dec(&dup->refcount) == 1) {
600037f4:	2b01      	cmp	r3, #1
600037f6:	f3bf 8f5b 	dmb	ish
600037fa:	d103      	bne.n	60003804 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
600037fc:	a901      	add	r1, sp, #4
600037fe:	4803      	ldr	r0, [pc, #12]	; (6000380c <log_free+0x30>)
60003800:	f008 fcad 	bl	6000c15e <k_mem_slab_free>
}
60003804:	b003      	add	sp, #12
60003806:	f85d fb04 	ldr.w	pc, [sp], #4
6000380a:	bf00      	nop
6000380c:	80000aa0 	.word	0x80000aa0

60003810 <log_msg_pool_init>:
static uint8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
60003810:	2320      	movs	r3, #32
60003812:	4902      	ldr	r1, [pc, #8]	; (6000381c <log_msg_pool_init+0xc>)
60003814:	4802      	ldr	r0, [pc, #8]	; (60003820 <log_msg_pool_init+0x10>)
60003816:	461a      	mov	r2, r3
60003818:	f008 bc81 	b.w	6000c11e <k_mem_slab_init>
6000381c:	80003ec0 	.word	0x80003ec0
60003820:	80000ac0 	.word	0x80000ac0

60003824 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
60003824:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
60003826:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
60003828:	4d09      	ldr	r5, [pc, #36]	; (60003850 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
6000382a:	9301      	str	r3, [sp, #4]
6000382c:	2001      	movs	r0, #1
6000382e:	f7ff fe63 	bl	600034f8 <z_impl_log_process>
60003832:	4604      	mov	r4, r0
			z_log_dropped();
60003834:	f7ff fd00 	bl	60003238 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
60003838:	2200      	movs	r2, #0
6000383a:	2300      	movs	r3, #0
6000383c:	a901      	add	r1, sp, #4
6000383e:	4628      	mov	r0, r5
60003840:	f004 fc88 	bl	60008154 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
60003844:	b108      	cbz	r0, 6000384a <log_msg_no_space_handle+0x26>
60003846:	2c00      	cmp	r4, #0
60003848:	d1f0      	bne.n	6000382c <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
6000384a:	9801      	ldr	r0, [sp, #4]
6000384c:	b003      	add	sp, #12
6000384e:	bd30      	pop	{r4, r5, pc}
60003850:	80000ac0 	.word	0x80000ac0

60003854 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
60003854:	2300      	movs	r3, #0
{
60003856:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
60003858:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
6000385a:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
6000385c:	a901      	add	r1, sp, #4
6000385e:	2300      	movs	r3, #0
60003860:	4805      	ldr	r0, [pc, #20]	; (60003878 <log_msg_chunk_alloc+0x24>)
60003862:	f004 fc77 	bl	60008154 <k_mem_slab_alloc>
	if (err != 0) {
60003866:	b110      	cbz	r0, 6000386e <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
60003868:	f7ff ffdc 	bl	60003824 <log_msg_no_space_handle>
6000386c:	9001      	str	r0, [sp, #4]
}
6000386e:	9801      	ldr	r0, [sp, #4]
60003870:	b003      	add	sp, #12
60003872:	f85d fb04 	ldr.w	pc, [sp], #4
60003876:	bf00      	nop
60003878:	80000ac0 	.word	0x80000ac0

6000387c <msg_free>:
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
6000387c:	7a03      	ldrb	r3, [r0, #8]
{
6000387e:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (log_msg_is_std(msg) && nargs) {
60003880:	07dc      	lsls	r4, r3, #31
{
60003882:	b085      	sub	sp, #20
60003884:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
60003886:	d41e      	bmi.n	600038c6 <msg_free+0x4a>
	}
}

uint32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
60003888:	7a45      	ldrb	r5, [r0, #9]
	if (log_msg_is_std(msg) && nargs) {
6000388a:	092d      	lsrs	r5, r5, #4
6000388c:	d01b      	beq.n	600038c6 <msg_free+0x4a>
		uint32_t smask = 0U;
6000388e:	2400      	movs	r4, #0
		for (i = 0U; i < nargs; i++) {
60003890:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
60003892:	4631      	mov	r1, r6
60003894:	9801      	ldr	r0, [sp, #4]
60003896:	f006 fc8f 	bl	6000a1b8 <log_msg_arg_get>
6000389a:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
6000389c:	f7ff fe1e 	bl	600034dc <log_is_strdup>
600038a0:	b170      	cbz	r0, 600038c0 <msg_free+0x44>
				if (smask == 0U) {
600038a2:	b934      	cbnz	r4, 600038b2 <msg_free+0x36>
					smask = z_log_get_s_mask(
600038a4:	9b01      	ldr	r3, [sp, #4]
600038a6:	4629      	mov	r1, r5
600038a8:	6918      	ldr	r0, [r3, #16]
600038aa:	f006 fb8a 	bl	60009fc2 <z_log_get_s_mask>
					if (smask == 0U) {
600038ae:	4604      	mov	r4, r0
600038b0:	b148      	cbz	r0, 600038c6 <msg_free+0x4a>
				if (smask & BIT(i)) {
600038b2:	fa24 f306 	lsr.w	r3, r4, r6
600038b6:	07d9      	lsls	r1, r3, #31
600038b8:	d502      	bpl.n	600038c0 <msg_free+0x44>
					log_free(buf);
600038ba:	4638      	mov	r0, r7
600038bc:	f7ff ff8e 	bl	600037dc <log_free>
		for (i = 0U; i < nargs; i++) {
600038c0:	3601      	adds	r6, #1
600038c2:	42ae      	cmp	r6, r5
600038c4:	d3e5      	bcc.n	60003892 <msg_free+0x16>
	if (msg->hdr.params.generic.ext == 1) {
600038c6:	9b01      	ldr	r3, [sp, #4]
600038c8:	7a1a      	ldrb	r2, [r3, #8]
600038ca:	0792      	lsls	r2, r2, #30
600038cc:	d504      	bpl.n	600038d8 <msg_free+0x5c>
		cont_free(msg->payload.ext.next);
600038ce:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
600038d0:	4c08      	ldr	r4, [pc, #32]	; (600038f4 <msg_free+0x78>)
600038d2:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
600038d4:	9b03      	ldr	r3, [sp, #12]
600038d6:	b92b      	cbnz	r3, 600038e4 <msg_free+0x68>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
600038d8:	a901      	add	r1, sp, #4
600038da:	4806      	ldr	r0, [pc, #24]	; (600038f4 <msg_free+0x78>)
600038dc:	f008 fc3f 	bl	6000c15e <k_mem_slab_free>
}
600038e0:	b005      	add	sp, #20
600038e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
600038e4:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
600038e6:	a903      	add	r1, sp, #12
600038e8:	4620      	mov	r0, r4
600038ea:	f008 fc38 	bl	6000c15e <k_mem_slab_free>
		cont = next;
600038ee:	9503      	str	r5, [sp, #12]
600038f0:	e7f0      	b.n	600038d4 <msg_free+0x58>
600038f2:	bf00      	nop
600038f4:	80000ac0 	.word	0x80000ac0

600038f8 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
600038f8:	b40e      	push	{r1, r2, r3}
600038fa:	b503      	push	{r0, r1, lr}
600038fc:	ab03      	add	r3, sp, #12
600038fe:	4601      	mov	r1, r0
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
60003900:	4805      	ldr	r0, [pc, #20]	; (60003918 <print_formatted+0x20>)
{
60003902:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
60003906:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
60003908:	f7fe ff62 	bl	600027d0 <cbvprintf>
	va_end(args);

	return length;
}
6000390c:	b002      	add	sp, #8
6000390e:	f85d eb04 	ldr.w	lr, [sp], #4
60003912:	b003      	add	sp, #12
60003914:	4770      	bx	lr
60003916:	bf00      	nop
60003918:	6000a5c9 	.word	0x6000a5c9

6000391c <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
6000391c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
60003920:	461d      	mov	r5, r3
60003922:	9b08      	ldr	r3, [sp, #32]
60003924:	4617      	mov	r7, r2
60003926:	4604      	mov	r4, r0
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
60003928:	06da      	lsls	r2, r3, #27
{
6000392a:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
6000392c:	d405      	bmi.n	6000393a <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
6000392e:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
60003930:	bf4c      	ite	mi
60003932:	492a      	ldrmi	r1, [pc, #168]	; (600039dc <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
60003934:	492a      	ldrpl	r1, [pc, #168]	; (600039e0 <hexdump_line_print+0xc4>)
60003936:	f7ff ffdf 	bl	600038f8 <print_formatted>
{
6000393a:	f04f 0800 	mov.w	r8, #0
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
6000393e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 600039e4 <hexdump_line_print+0xc8>
	for (int i = 0; i < prefix_offset; i++) {
60003942:	45a8      	cmp	r8, r5
60003944:	db2a      	blt.n	6000399c <hexdump_line_print+0x80>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
60003946:	2500      	movs	r5, #0
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
60003948:	f8df 809c 	ldr.w	r8, [pc, #156]	; 600039e8 <hexdump_line_print+0xcc>
			print_formatted(output, "%02x ", data[i]);
6000394c:	f8df 909c 	ldr.w	r9, [pc, #156]	; 600039ec <hexdump_line_print+0xd0>
			print_formatted(output, " ");
60003950:	f8df a090 	ldr.w	sl, [pc, #144]	; 600039e4 <hexdump_line_print+0xc8>
		if (i < length) {
60003954:	42bd      	cmp	r5, r7
60003956:	d22f      	bcs.n	600039b8 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
60003958:	5d72      	ldrb	r2, [r6, r5]
6000395a:	4649      	mov	r1, r9
6000395c:	4620      	mov	r0, r4
6000395e:	f7ff ffcb 	bl	600038f8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
60003962:	3501      	adds	r5, #1
60003964:	2d10      	cmp	r5, #16
60003966:	d120      	bne.n	600039aa <hexdump_line_print+0x8e>
		}
	}

	print_formatted(output, "|");

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
60003968:	2500      	movs	r5, #0
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
6000396a:	f8df 8078 	ldr.w	r8, [pc, #120]	; 600039e4 <hexdump_line_print+0xc8>
			print_formatted(output, "%c",
6000396e:	f8df 9080 	ldr.w	r9, [pc, #128]	; 600039f0 <hexdump_line_print+0xd4>
	print_formatted(output, "|");
60003972:	4620      	mov	r0, r4
60003974:	491f      	ldr	r1, [pc, #124]	; (600039f4 <hexdump_line_print+0xd8>)
60003976:	f7ff ffbf 	bl	600038f8 <print_formatted>
		if (i < length) {
6000397a:	42af      	cmp	r7, r5
6000397c:	d928      	bls.n	600039d0 <hexdump_line_print+0xb4>
			char c = (char)data[i];
6000397e:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(output, "%c",
60003980:	4649      	mov	r1, r9
60003982:	4620      	mov	r0, r4
	return (int)((((unsigned)c) >= ' ') &&
60003984:	f1a2 0320 	sub.w	r3, r2, #32
60003988:	2b5f      	cmp	r3, #95	; 0x5f
6000398a:	bf28      	it	cs
6000398c:	222e      	movcs	r2, #46	; 0x2e
6000398e:	f7ff ffb3 	bl	600038f8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
60003992:	3501      	adds	r5, #1
60003994:	2d10      	cmp	r5, #16
60003996:	d114      	bne.n	600039c2 <hexdump_line_print+0xa6>
		}
	}
}
60003998:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
6000399c:	4649      	mov	r1, r9
6000399e:	4620      	mov	r0, r4
	for (int i = 0; i < prefix_offset; i++) {
600039a0:	f108 0801 	add.w	r8, r8, #1
		print_formatted(output, " ");
600039a4:	f7ff ffa8 	bl	600038f8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
600039a8:	e7cb      	b.n	60003942 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
600039aa:	076a      	lsls	r2, r5, #29
600039ac:	d1d2      	bne.n	60003954 <hexdump_line_print+0x38>
			print_formatted(output, " ");
600039ae:	4651      	mov	r1, sl
600039b0:	4620      	mov	r0, r4
600039b2:	f7ff ffa1 	bl	600038f8 <print_formatted>
600039b6:	e7cd      	b.n	60003954 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
600039b8:	4641      	mov	r1, r8
600039ba:	4620      	mov	r0, r4
600039bc:	f7ff ff9c 	bl	600038f8 <print_formatted>
600039c0:	e7cf      	b.n	60003962 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
600039c2:	076b      	lsls	r3, r5, #29
600039c4:	d1d9      	bne.n	6000397a <hexdump_line_print+0x5e>
			print_formatted(output, " ");
600039c6:	4641      	mov	r1, r8
600039c8:	4620      	mov	r0, r4
600039ca:	f7ff ff95 	bl	600038f8 <print_formatted>
600039ce:	e7d4      	b.n	6000397a <hexdump_line_print+0x5e>
			print_formatted(output, " ");
600039d0:	4641      	mov	r1, r8
600039d2:	4620      	mov	r0, r4
600039d4:	f7ff ff90 	bl	600038f8 <print_formatted>
600039d8:	e7db      	b.n	60003992 <hexdump_line_print+0x76>
600039da:	bf00      	nop
600039dc:	6000dc94 	.word	0x6000dc94
600039e0:	6000d886 	.word	0x6000d886
600039e4:	6000d7d0 	.word	0x6000d7d0
600039e8:	6000d7ce 	.word	0x6000d7ce
600039ec:	6000d7c8 	.word	0x6000d7c8
600039f0:	6000e145 	.word	0x6000e145
600039f4:	6000d7d2 	.word	0x6000d7d2

600039f8 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
600039f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
600039fc:	f011 0602 	ands.w	r6, r1, #2
{
60003a00:	b087      	sub	sp, #28
60003a02:	4607      	mov	r7, r0
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
60003a04:	f001 0a01 	and.w	sl, r1, #1
{
60003a08:	9205      	str	r2, [sp, #20]
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
60003a0a:	f001 0508 	and.w	r5, r1, #8
{
60003a0e:	461a      	mov	r2, r3
60003a10:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
60003a14:	f9bd 9048 	ldrsh.w	r9, [sp, #72]	; 0x48
	if (stamp) {
60003a18:	d006      	beq.n	60003a28 <prefix_print+0x30>
	if (!format) {
60003a1a:	f011 0f44 	tst.w	r1, #68	; 0x44
60003a1e:	d138      	bne.n	60003a92 <prefix_print+0x9a>
		length = print_formatted(output, "[%08lu] ", timestamp);
60003a20:	4933      	ldr	r1, [pc, #204]	; (60003af0 <prefix_print+0xf8>)
60003a22:	f7ff ff69 	bl	600038f8 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
60003a26:	4606      	mov	r6, r0
	if (color) {
60003a28:	f1ba 0f00 	cmp.w	sl, #0
60003a2c:	d00a      	beq.n	60003a44 <prefix_print+0x4c>
		const char *log_color = start && (colors[level] != NULL) ?
60003a2e:	4b31      	ldr	r3, [pc, #196]	; (60003af4 <prefix_print+0xfc>)
		print_formatted(output, "%s", log_color);
60003a30:	4638      	mov	r0, r7
60003a32:	4931      	ldr	r1, [pc, #196]	; (60003af8 <prefix_print+0x100>)
		const char *log_color = start && (colors[level] != NULL) ?
60003a34:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
		print_formatted(output, "%s", log_color);
60003a38:	4b30      	ldr	r3, [pc, #192]	; (60003afc <prefix_print+0x104>)
60003a3a:	2a00      	cmp	r2, #0
60003a3c:	bf08      	it	eq
60003a3e:	461a      	moveq	r2, r3
60003a40:	f7ff ff5a 	bl	600038f8 <print_formatted>
	if (level_on) {
60003a44:	b13d      	cbz	r5, 60003a56 <prefix_print+0x5e>
		total += print_formatted(output, "<%s> ", severity[level]);
60003a46:	4b2e      	ldr	r3, [pc, #184]	; (60003b00 <prefix_print+0x108>)
60003a48:	4638      	mov	r0, r7
60003a4a:	492e      	ldr	r1, [pc, #184]	; (60003b04 <prefix_print+0x10c>)
60003a4c:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
60003a50:	f7ff ff52 	bl	600038f8 <print_formatted>
60003a54:	4605      	mov	r5, r0
	if (source_id >= 0) {
60003a56:	f1b9 0f00 	cmp.w	r9, #0
60003a5a:	db16      	blt.n	60003a8a <prefix_print+0x92>
		total += print_formatted(output,
60003a5c:	9b05      	ldr	r3, [sp, #20]
60003a5e:	2b00      	cmp	r3, #0
60003a60:	d043      	beq.n	60003aea <prefix_print+0xf2>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
60003a62:	2301      	movs	r3, #1
		total += print_formatted(output,
60003a64:	4c28      	ldr	r4, [pc, #160]	; (60003b08 <prefix_print+0x110>)
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
60003a66:	fa03 f808 	lsl.w	r8, r3, r8
		total += print_formatted(output,
60003a6a:	4b28      	ldr	r3, [pc, #160]	; (60003b0c <prefix_print+0x114>)
60003a6c:	f018 0f10 	tst.w	r8, #16
60003a70:	bf18      	it	ne
60003a72:	461c      	movne	r4, r3
60003a74:	4649      	mov	r1, r9
60003a76:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
60003a7a:	f7ff fc19 	bl	600032b0 <log_source_name_get>
60003a7e:	4621      	mov	r1, r4
60003a80:	4602      	mov	r2, r0
60003a82:	4638      	mov	r0, r7
60003a84:	f7ff ff38 	bl	600038f8 <print_formatted>
60003a88:	4405      	add	r5, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
60003a8a:	19a8      	adds	r0, r5, r6
60003a8c:	b007      	add	sp, #28
60003a8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
60003a92:	4b1f      	ldr	r3, [pc, #124]	; (60003b10 <prefix_print+0x118>)
60003a94:	6819      	ldr	r1, [r3, #0]
60003a96:	b331      	cbz	r1, 60003ae6 <prefix_print+0xee>
		timestamp /= timestamp_div;
60003a98:	4b1e      	ldr	r3, [pc, #120]	; (60003b14 <prefix_print+0x11c>)
60003a9a:	f44f 6661 	mov.w	r6, #3600	; 0xe10
		ms = (remainder * 1000U) / freq;
60003a9e:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
		mins = seconds / 60U;
60003aa2:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
		timestamp /= timestamp_div;
60003aa6:	681b      	ldr	r3, [r3, #0]
60003aa8:	fbb2 f3f3 	udiv	r3, r2, r3
		total_seconds = timestamp / freq;
60003aac:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
60003ab0:	fbb4 f2f6 	udiv	r2, r4, r6
60003ab4:	fb06 4612 	mls	r6, r6, r2, r4
		remainder = timestamp % freq;
60003ab8:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
60003abc:	fb0b f404 	mul.w	r4, fp, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
60003ac0:	fbb4 fef1 	udiv	lr, r4, r1
60003ac4:	fb01 441e 	mls	r4, r1, lr, r4
		mins = seconds / 60U;
60003ac8:	fbb6 f3fc 	udiv	r3, r6, ip
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
60003acc:	fb0b f404 	mul.w	r4, fp, r4
			length = print_formatted(output,
60003ad0:	fb0c 6613 	mls	r6, ip, r3, r6
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
60003ad4:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(output,
60003ad8:	9600      	str	r6, [sp, #0]
60003ada:	e9cd e101 	strd	lr, r1, [sp, #4]
60003ade:	490e      	ldr	r1, [pc, #56]	; (60003b18 <prefix_print+0x120>)
60003ae0:	f7ff ff0a 	bl	600038f8 <print_formatted>
60003ae4:	e79f      	b.n	60003a26 <prefix_print+0x2e>
		length = 0;
60003ae6:	4608      	mov	r0, r1
60003ae8:	e79d      	b.n	60003a26 <prefix_print+0x2e>
		total += print_formatted(output,
60003aea:	4c07      	ldr	r4, [pc, #28]	; (60003b08 <prefix_print+0x110>)
60003aec:	e7c2      	b.n	60003a74 <prefix_print+0x7c>
60003aee:	bf00      	nop
60003af0:	6000d7e2 	.word	0x6000d7e2
60003af4:	6000d048 	.word	0x6000d048
60003af8:	6000ddaf 	.word	0x6000ddaf
60003afc:	6000d7d4 	.word	0x6000d7d4
60003b00:	6000d05c 	.word	0x6000d05c
60003b04:	6000d807 	.word	0x6000d807
60003b08:	6000d7d9 	.word	0x6000d7d9
60003b0c:	6000d7de 	.word	0x6000d7de
60003b10:	80000adc 	.word	0x80000adc
60003b14:	80000ae0 	.word	0x80000ae0
60003b18:	6000d7eb 	.word	0x6000d7eb

60003b1c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
60003b1c:	b538      	push	{r3, r4, r5, lr}
60003b1e:	460c      	mov	r4, r1
60003b20:	4605      	mov	r5, r0
	if (color) {
60003b22:	07e1      	lsls	r1, r4, #31
60003b24:	d503      	bpl.n	60003b2e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
60003b26:	4a08      	ldr	r2, [pc, #32]	; (60003b48 <postfix_print+0x2c>)
60003b28:	4908      	ldr	r1, [pc, #32]	; (60003b4c <postfix_print+0x30>)
60003b2a:	f7ff fee5 	bl	600038f8 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
60003b2e:	06e2      	lsls	r2, r4, #27
60003b30:	d408      	bmi.n	60003b44 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
60003b32:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
60003b34:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
60003b36:	bf4c      	ite	mi
60003b38:	4905      	ldrmi	r1, [pc, #20]	; (60003b50 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
60003b3a:	4906      	ldrpl	r1, [pc, #24]	; (60003b54 <postfix_print+0x38>)
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
60003b3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
60003b40:	f7ff beda 	b.w	600038f8 <print_formatted>
}
60003b44:	bd38      	pop	{r3, r4, r5, pc}
60003b46:	bf00      	nop
60003b48:	6000d7d4 	.word	0x6000d7d4
60003b4c:	6000ddaf 	.word	0x6000ddaf
60003b50:	6000dc94 	.word	0x6000dc94
60003b54:	6000d886 	.word	0x6000d886

60003b58 <log_output_msg_process>:
	return msg->hdr.ids.level;
60003b58:	7a8b      	ldrb	r3, [r1, #10]

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
60003b5a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
60003b5e:	f013 0807 	ands.w	r8, r3, #7
{
60003b62:	b08a      	sub	sp, #40	; 0x28
60003b64:	4605      	mov	r5, r0
60003b66:	460e      	mov	r6, r1
60003b68:	4617      	mov	r7, r2
			0 : prefix_print(output, flags, std_msg, timestamp,
60003b6a:	d022      	beq.n	60003bb2 <log_output_msg_process+0x5a>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
60003b6c:	7a0a      	ldrb	r2, [r1, #8]
60003b6e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
	return msg->hdr.ids.source_id;
60003b72:	8949      	ldrh	r1, [r1, #10]
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
60003b74:	43d2      	mvns	r2, r2
60003b76:	f3c1 1189 	ubfx	r1, r1, #6, #10
60003b7a:	f002 0201 	and.w	r2, r2, #1
60003b7e:	9102      	str	r1, [sp, #8]
60003b80:	4639      	mov	r1, r7
60003b82:	e9cd 8300 	strd	r8, r3, [sp]
60003b86:	68f3      	ldr	r3, [r6, #12]
60003b88:	f7ff ff36 	bl	600039f8 <prefix_print>
60003b8c:	4681      	mov	r9, r0
60003b8e:	7a34      	ldrb	r4, [r6, #8]
60003b90:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
60003b92:	f014 0401 	ands.w	r4, r4, #1
60003b96:	d00e      	beq.n	60003bb6 <log_output_msg_process+0x5e>
		std_print(msg, output);
60003b98:	4629      	mov	r1, r5
60003b9a:	4630      	mov	r0, r6
60003b9c:	f006 fbaa 	bl	6000a2f4 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
60003ba0:	f1b8 0f00 	cmp.w	r8, #0
60003ba4:	d02b      	beq.n	60003bfe <log_output_msg_process+0xa6>
		postfix_print(output, flags, level);
60003ba6:	4642      	mov	r2, r8
60003ba8:	4639      	mov	r1, r7
60003baa:	4628      	mov	r0, r5
60003bac:	f7ff ffb6 	bl	60003b1c <postfix_print>
60003bb0:	e025      	b.n	60003bfe <log_output_msg_process+0xa6>
			0 : prefix_print(output, flags, std_msg, timestamp,
60003bb2:	46c1      	mov	r9, r8
60003bb4:	e7eb      	b.n	60003b8e <log_output_msg_process+0x36>
	} else if (raw_string) {
60003bb6:	f1b8 0f00 	cmp.w	r8, #0
60003bba:	d126      	bne.n	60003c0a <log_output_msg_process+0xb2>
	size_t offset = 0;
60003bbc:	4627      	mov	r7, r4
		length = output->size;
60003bbe:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
60003bc0:	aa06      	add	r2, sp, #24
60003bc2:	68a9      	ldr	r1, [r5, #8]
60003bc4:	4630      	mov	r0, r6
		length = output->size;
60003bc6:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
60003bc8:	463b      	mov	r3, r7
60003bca:	f006 fb7f 	bl	6000a2cc <log_msg_hexdump_data_get>
		output->control_block->offset = length;
60003bce:	9a06      	ldr	r2, [sp, #24]
60003bd0:	686b      	ldr	r3, [r5, #4]
60003bd2:	601a      	str	r2, [r3, #0]
		if (length != 0) {
60003bd4:	b13a      	cbz	r2, 60003be6 <log_output_msg_process+0x8e>
			eol = (output->buf[length - 1] == '\n');
60003bd6:	68ab      	ldr	r3, [r5, #8]
60003bd8:	4413      	add	r3, r2
60003bda:	f813 4c01 	ldrb.w	r4, [r3, #-1]
60003bde:	f1a4 030a 	sub.w	r3, r4, #10
60003be2:	425c      	negs	r4, r3
60003be4:	415c      	adcs	r4, r3
		log_output_flush(output);
60003be6:	4628      	mov	r0, r5
60003be8:	f006 fce1 	bl	6000a5ae <log_output_flush>
		offset += length;
60003bec:	9b06      	ldr	r3, [sp, #24]
60003bee:	441f      	add	r7, r3
	} while (length > 0);
60003bf0:	2b00      	cmp	r3, #0
60003bf2:	d1e4      	bne.n	60003bbe <log_output_msg_process+0x66>
	if (eol) {
60003bf4:	b11c      	cbz	r4, 60003bfe <log_output_msg_process+0xa6>
		print_formatted(output, "\r");
60003bf6:	4914      	ldr	r1, [pc, #80]	; (60003c48 <log_output_msg_process+0xf0>)
60003bf8:	4628      	mov	r0, r5
60003bfa:	f7ff fe7d 	bl	600038f8 <print_formatted>
	}

	log_output_flush(output);
60003bfe:	4628      	mov	r0, r5
}
60003c00:	b00a      	add	sp, #40	; 0x28
60003c02:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(output);
60003c06:	f006 bcd2 	b.w	6000a5ae <log_output_flush>
	print_formatted(output, "%s", log_msg_str_get(msg));
60003c0a:	4630      	mov	r0, r6
		length = sizeof(buf);
60003c0c:	f04f 0a10 	mov.w	sl, #16
	print_formatted(output, "%s", log_msg_str_get(msg));
60003c10:	f006 fb04 	bl	6000a21c <log_msg_str_get>
60003c14:	490d      	ldr	r1, [pc, #52]	; (60003c4c <log_output_msg_process+0xf4>)
60003c16:	4602      	mov	r2, r0
60003c18:	4628      	mov	r0, r5
60003c1a:	f7ff fe6d 	bl	600038f8 <print_formatted>
		log_msg_hexdump_data_get(msg, buf, &length, offset);
60003c1e:	aa05      	add	r2, sp, #20
60003c20:	4623      	mov	r3, r4
60003c22:	a906      	add	r1, sp, #24
60003c24:	4630      	mov	r0, r6
		length = sizeof(buf);
60003c26:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
60003c2a:	f006 fb4f 	bl	6000a2cc <log_msg_hexdump_data_get>
		if (length) {
60003c2e:	9a05      	ldr	r2, [sp, #20]
60003c30:	2a00      	cmp	r2, #0
60003c32:	d0b8      	beq.n	60003ba6 <log_output_msg_process+0x4e>
			hexdump_line_print(output, buf, length,
60003c34:	464b      	mov	r3, r9
60003c36:	a906      	add	r1, sp, #24
60003c38:	4628      	mov	r0, r5
60003c3a:	9700      	str	r7, [sp, #0]
60003c3c:	f7ff fe6e 	bl	6000391c <hexdump_line_print>
			offset += length;
60003c40:	9b05      	ldr	r3, [sp, #20]
60003c42:	441c      	add	r4, r3
		length = sizeof(buf);
60003c44:	e7eb      	b.n	60003c1e <log_output_msg_process+0xc6>
60003c46:	bf00      	nop
60003c48:	6000d80d 	.word	0x6000d80d
60003c4c:	6000ddaf 	.word	0x6000ddaf

60003c50 <log_output_dropped_process>:
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
60003c50:	f242 730f 	movw	r3, #9999	; 0x270f
60003c54:	4a11      	ldr	r2, [pc, #68]	; (60003c9c <log_output_dropped_process+0x4c>)
60003c56:	428b      	cmp	r3, r1
{
60003c58:	b573      	push	{r0, r1, r4, r5, r6, lr}
60003c5a:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
60003c5c:	bf28      	it	cs
60003c5e:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
60003c60:	6805      	ldr	r5, [r0, #0]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
60003c62:	2105      	movs	r1, #5
60003c64:	4668      	mov	r0, sp
60003c66:	f005 fe43 	bl	600098f0 <snprintk>

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
60003c6a:	6863      	ldr	r3, [r4, #4]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
60003c6c:	4606      	mov	r6, r0
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
60003c6e:	220b      	movs	r2, #11
60003c70:	4628      	mov	r0, r5
60003c72:	685b      	ldr	r3, [r3, #4]
60003c74:	490a      	ldr	r1, [pc, #40]	; (60003ca0 <log_output_dropped_process+0x50>)
60003c76:	f006 fb30 	bl	6000a2da <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
60003c7a:	6863      	ldr	r3, [r4, #4]
60003c7c:	4632      	mov	r2, r6
60003c7e:	4669      	mov	r1, sp
60003c80:	4628      	mov	r0, r5
60003c82:	685b      	ldr	r3, [r3, #4]
60003c84:	f006 fb29 	bl	6000a2da <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
60003c88:	6863      	ldr	r3, [r4, #4]
60003c8a:	221b      	movs	r2, #27
60003c8c:	4905      	ldr	r1, [pc, #20]	; (60003ca4 <log_output_dropped_process+0x54>)
60003c8e:	685b      	ldr	r3, [r3, #4]
60003c90:	4628      	mov	r0, r5
60003c92:	f006 fb22 	bl	6000a2da <buffer_write>
		     output->control_block->ctx);
}
60003c96:	b002      	add	sp, #8
60003c98:	bd70      	pop	{r4, r5, r6, pc}
60003c9a:	bf00      	nop
60003c9c:	6000df77 	.word	0x6000df77
60003ca0:	6000d84b 	.word	0x6000d84b
60003ca4:	6000d82f 	.word	0x6000d82f

60003ca8 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
60003ca8:	b510      	push	{r4, lr}
	timestamp_div = 1U;
60003caa:	4a08      	ldr	r2, [pc, #32]	; (60003ccc <log_output_timestamp_freq_set+0x24>)
60003cac:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
60003cae:	2100      	movs	r1, #0
60003cb0:	4c07      	ldr	r4, [pc, #28]	; (60003cd0 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
60003cb2:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
60003cb4:	42a0      	cmp	r0, r4
60003cb6:	d804      	bhi.n	60003cc2 <log_output_timestamp_freq_set+0x1a>
60003cb8:	b101      	cbz	r1, 60003cbc <log_output_timestamp_freq_set+0x14>
60003cba:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
60003cbc:	4b05      	ldr	r3, [pc, #20]	; (60003cd4 <log_output_timestamp_freq_set+0x2c>)
60003cbe:	6018      	str	r0, [r3, #0]
}
60003cc0:	bd10      	pop	{r4, pc}
		frequency /= 2U;
60003cc2:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
60003cc4:	2101      	movs	r1, #1
60003cc6:	005b      	lsls	r3, r3, #1
60003cc8:	e7f4      	b.n	60003cb4 <log_output_timestamp_freq_set+0xc>
60003cca:	bf00      	nop
60003ccc:	80000ae0 	.word	0x80000ae0
60003cd0:	000f4240 	.word	0x000f4240
60003cd4:	80000adc 	.word	0x80000adc

60003cd8 <severity_lvl_get>:
}


static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
60003cd8:	2300      	movs	r3, #0
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
60003cda:	2804      	cmp	r0, #4
	entry->subcmd = &dsub_module_name;
60003cdc:	4a05      	ldr	r2, [pc, #20]	; (60003cf4 <severity_lvl_get+0x1c>)
	entry->handler = NULL;
60003cde:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
60003ce0:	604b      	str	r3, [r1, #4]
					severity_lvls_sorted[idx] : NULL;
60003ce2:	bf98      	it	ls
60003ce4:	4b04      	ldrls	r3, [pc, #16]	; (60003cf8 <severity_lvl_get+0x20>)
	entry->subcmd = &dsub_module_name;
60003ce6:	608a      	str	r2, [r1, #8]
					severity_lvls_sorted[idx] : NULL;
60003ce8:	bf98      	it	ls
60003cea:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
60003cee:	600b      	str	r3, [r1, #0]
}
60003cf0:	4770      	bx	lr
60003cf2:	bf00      	nop
60003cf4:	6000d08c 	.word	0x6000d08c
60003cf8:	6000d0b0 	.word	0x6000d0b0

60003cfc <backend_name_get>:
	SHELL_SUBCMD_SET_END
);

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
60003cfc:	2300      	movs	r3, #0
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
60003cfe:	4a08      	ldr	r2, [pc, #32]	; (60003d20 <backend_name_get+0x24>)
	entry->syntax  = NULL;
60003d00:	600b      	str	r3, [r1, #0]
	entry->handler = NULL;
60003d02:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
60003d04:	604b      	str	r3, [r1, #4]
	entry->subcmd = &sub_log_backend;
60003d06:	608a      	str	r2, [r1, #8]
	return __log_backends_end - __log_backends_start;
60003d08:	4b06      	ldr	r3, [pc, #24]	; (60003d24 <backend_name_get+0x28>)
60003d0a:	4a07      	ldr	r2, [pc, #28]	; (60003d28 <backend_name_get+0x2c>)
60003d0c:	1ad2      	subs	r2, r2, r3

	if (idx < log_backend_count_get()) {
60003d0e:	ebb0 1f22 	cmp.w	r0, r2, asr #4
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
60003d12:	bf3e      	ittt	cc
60003d14:	eb03 1300 	addcc.w	r3, r3, r0, lsl #4
60003d18:	689b      	ldrcc	r3, [r3, #8]
60003d1a:	600b      	strcc	r3, [r1, #0]
	}
}
60003d1c:	4770      	bx	lr
60003d1e:	bf00      	nop
60003d20:	6000d1f0 	.word	0x6000d1f0
60003d24:	6000cee8 	.word	0x6000cee8
60003d28:	6000cf08 	.word	0x6000cf08

60003d2c <cmd_log_backends_list>:
{
60003d2c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
60003d30:	4b12      	ldr	r3, [pc, #72]	; (60003d7c <cmd_log_backends_list+0x50>)
60003d32:	4607      	mov	r7, r0
60003d34:	4c12      	ldr	r4, [pc, #72]	; (60003d80 <cmd_log_backends_list+0x54>)
	for (int i = 0; i < backend_count; i++) {
60003d36:	2500      	movs	r5, #0
		shell_fprintf(shell, SHELL_NORMAL,
60003d38:	f8df 8048 	ldr.w	r8, [pc, #72]	; 60003d84 <cmd_log_backends_list+0x58>
60003d3c:	1b1b      	subs	r3, r3, r4
60003d3e:	f8df 9048 	ldr.w	r9, [pc, #72]	; 60003d88 <cmd_log_backends_list+0x5c>
60003d42:	f8df a048 	ldr.w	sl, [pc, #72]	; 60003d8c <cmd_log_backends_list+0x60>
60003d46:	111e      	asrs	r6, r3, #4
	for (int i = 0; i < backend_count; i++) {
60003d48:	42b5      	cmp	r5, r6
60003d4a:	db03      	blt.n	60003d54 <cmd_log_backends_list+0x28>
}
60003d4c:	2000      	movs	r0, #0
60003d4e:	b002      	add	sp, #8
60003d50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			      backend->cb->active ? "enabled" : "disabled",
60003d54:	6863      	ldr	r3, [r4, #4]
		shell_fprintf(shell, SHELL_NORMAL,
60003d56:	4638      	mov	r0, r7
	for (int i = 0; i < backend_count; i++) {
60003d58:	3501      	adds	r5, #1
60003d5a:	3410      	adds	r4, #16
		shell_fprintf(shell, SHELL_NORMAL,
60003d5c:	7959      	ldrb	r1, [r3, #5]
60003d5e:	791b      	ldrb	r3, [r3, #4]
60003d60:	2900      	cmp	r1, #0
60003d62:	bf14      	ite	ne
60003d64:	4642      	movne	r2, r8
60003d66:	464a      	moveq	r2, r9
60003d68:	2100      	movs	r1, #0
60003d6a:	e9cd 2300 	strd	r2, r3, [sp]
60003d6e:	f854 3c08 	ldr.w	r3, [r4, #-8]
60003d72:	4652      	mov	r2, sl
60003d74:	f006 fd91 	bl	6000a89a <shell_fprintf>
	for (int i = 0; i < backend_count; i++) {
60003d78:	e7e6      	b.n	60003d48 <cmd_log_backends_list+0x1c>
60003d7a:	bf00      	nop
60003d7c:	6000cf08 	.word	0x6000cf08
60003d80:	6000cee8 	.word	0x6000cee8
60003d84:	6000d857 	.word	0x6000d857
60003d88:	6000d85f 	.word	0x6000d85f
60003d8c:	6000d868 	.word	0x6000d868

60003d90 <log_status>:
{
60003d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
60003d94:	4b24      	ldr	r3, [pc, #144]	; (60003e28 <log_status+0x98>)
60003d96:	b085      	sub	sp, #20
60003d98:	4c24      	ldr	r4, [pc, #144]	; (60003e2c <log_status+0x9c>)
60003d9a:	4605      	mov	r5, r0
60003d9c:	460e      	mov	r6, r1
60003d9e:	1ae4      	subs	r4, r4, r3
	return backend->cb->active;
60003da0:	684b      	ldr	r3, [r1, #4]
	if (!log_backend_is_active(backend)) {
60003da2:	795b      	ldrb	r3, [r3, #5]
60003da4:	08e4      	lsrs	r4, r4, #3
60003da6:	b91b      	cbnz	r3, 60003db0 <log_status+0x20>
		shell_warn(shell, "Logs are halted!");
60003da8:	4a21      	ldr	r2, [pc, #132]	; (60003e30 <log_status+0xa0>)
60003daa:	2104      	movs	r1, #4
60003dac:	f006 fd75 	bl	6000a89a <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
60003db0:	4b20      	ldr	r3, [pc, #128]	; (60003e34 <log_status+0xa4>)
60003db2:	2100      	movs	r1, #0
60003db4:	4a20      	ldr	r2, [pc, #128]	; (60003e38 <log_status+0xa8>)
60003db6:	4628      	mov	r0, r5
	for (int16_t i = 0U; i < modules_cnt; i++) {
60003db8:	f04f 0800 	mov.w	r8, #0
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
60003dbc:	f8df a07c 	ldr.w	sl, [pc, #124]	; 60003e3c <log_status+0xac>
60003dc0:	f8df b07c 	ldr.w	fp, [pc, #124]	; 60003e40 <log_status+0xb0>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
60003dc4:	f006 fd69 	bl	6000a89a <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL,
60003dc8:	4a1e      	ldr	r2, [pc, #120]	; (60003e44 <log_status+0xb4>)
60003dca:	2100      	movs	r1, #0
60003dcc:	4628      	mov	r0, r5
60003dce:	f006 fd64 	bl	6000a89a <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
60003dd2:	fa0f f788 	sxth.w	r7, r8
60003dd6:	f108 0801 	add.w	r8, r8, #1
60003dda:	42a7      	cmp	r7, r4
60003ddc:	d303      	bcc.n	60003de6 <log_status+0x56>
}
60003dde:	2000      	movs	r0, #0
60003de0:	b005      	add	sp, #20
60003de2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
60003de6:	463a      	mov	r2, r7
60003de8:	2301      	movs	r3, #1
60003dea:	2100      	movs	r1, #0
60003dec:	4630      	mov	r0, r6
60003dee:	f7ff fb25 	bl	6000343c <log_filter_get>
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
60003df2:	2300      	movs	r3, #0
60003df4:	463a      	mov	r2, r7
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
60003df6:	4681      	mov	r9, r0
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
60003df8:	4619      	mov	r1, r3
60003dfa:	4630      	mov	r0, r6
60003dfc:	f7ff fb1e 	bl	6000343c <log_filter_get>
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
60003e00:	4639      	mov	r1, r7
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
60003e02:	9003      	str	r0, [sp, #12]
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
60003e04:	2000      	movs	r0, #0
60003e06:	f7ff fa53 	bl	600032b0 <log_source_name_get>
60003e0a:	9a03      	ldr	r2, [sp, #12]
60003e0c:	4603      	mov	r3, r0
60003e0e:	2100      	movs	r1, #0
60003e10:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
60003e14:	4628      	mov	r0, r5
60003e16:	9201      	str	r2, [sp, #4]
60003e18:	f85a 2029 	ldr.w	r2, [sl, r9, lsl #2]
60003e1c:	9200      	str	r2, [sp, #0]
60003e1e:	465a      	mov	r2, fp
60003e20:	f006 fd3b 	bl	6000a89a <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
60003e24:	e7d5      	b.n	60003dd2 <log_status+0x42>
60003e26:	bf00      	nop
60003e28:	6000ceb8 	.word	0x6000ceb8
60003e2c:	6000cee8 	.word	0x6000cee8
60003e30:	6000d889 	.word	0x6000d889
60003e34:	6000d89b 	.word	0x6000d89b
60003e38:	6000d8a7 	.word	0x6000d8a7
60003e3c:	6000d09c 	.word	0x6000d09c
60003e40:	6000d902 	.word	0x6000d902
60003e44:	6000d8c5 	.word	0x6000d8c5

60003e48 <module_name_get>:
	entry->handler = NULL;
60003e48:	2300      	movs	r3, #0
	entry->subcmd = &dsub_module_name;
60003e4a:	4a06      	ldr	r2, [pc, #24]	; (60003e64 <module_name_get+0x1c>)
{
60003e4c:	b510      	push	{r4, lr}
60003e4e:	460c      	mov	r4, r1
	entry->handler = NULL;
60003e50:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
60003e52:	604b      	str	r3, [r1, #4]
	entry->subcmd = &dsub_module_name;
60003e54:	608a      	str	r2, [r1, #8]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
60003e56:	4601      	mov	r1, r0
60003e58:	4618      	mov	r0, r3
60003e5a:	f7ff fa29 	bl	600032b0 <log_source_name_get>
60003e5e:	6020      	str	r0, [r4, #0]
}
60003e60:	bd10      	pop	{r4, pc}
60003e62:	bf00      	nop
60003e64:	6000d08c 	.word	0x6000d08c

60003e68 <shell_backend_cmd_execute>:
{
60003e68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char const *name = argv[-1];
60003e6c:	f852 ac04 	ldr.w	sl, [r2, #-4]
{
60003e70:	b085      	sub	sp, #20
60003e72:	4606      	mov	r6, r0
60003e74:	4689      	mov	r9, r1
	size_t slen = strlen(name);
60003e76:	4650      	mov	r0, sl
{
60003e78:	4690      	mov	r8, r2
	return __log_backends_end - __log_backends_start;
60003e7a:	4c16      	ldr	r4, [pc, #88]	; (60003ed4 <shell_backend_cmd_execute+0x6c>)
	for (int i = 0; i < log_backend_count_get(); i++) {
60003e7c:	2700      	movs	r7, #0
{
60003e7e:	9302      	str	r3, [sp, #8]
	size_t slen = strlen(name);
60003e80:	f007 fd11 	bl	6000b8a6 <strlen>
60003e84:	4914      	ldr	r1, [pc, #80]	; (60003ed8 <shell_backend_cmd_execute+0x70>)
60003e86:	4602      	mov	r2, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
60003e88:	46a3      	mov	fp, r4
60003e8a:	1b09      	subs	r1, r1, r4
60003e8c:	110b      	asrs	r3, r1, #4
60003e8e:	9301      	str	r3, [sp, #4]
60003e90:	9b01      	ldr	r3, [sp, #4]
60003e92:	429f      	cmp	r7, r3
60003e94:	db08      	blt.n	60003ea8 <shell_backend_cmd_execute+0x40>
		shell_error(shell, "Invalid backend: %s", name);
60003e96:	4653      	mov	r3, sl
60003e98:	4a10      	ldr	r2, [pc, #64]	; (60003edc <shell_backend_cmd_execute+0x74>)
60003e9a:	2102      	movs	r1, #2
60003e9c:	4630      	mov	r0, r6
		return -ENOEXEC;
60003e9e:	f06f 0507 	mvn.w	r5, #7
		shell_error(shell, "Invalid backend: %s", name);
60003ea2:	f006 fcfa 	bl	6000a89a <shell_fprintf>
		return -ENOEXEC;
60003ea6:	e00f      	b.n	60003ec8 <shell_backend_cmd_execute+0x60>
		if (strncmp(name, backend->name, slen) == 0) {
60003ea8:	68a1      	ldr	r1, [r4, #8]
60003eaa:	4650      	mov	r0, sl
60003eac:	9203      	str	r2, [sp, #12]
60003eae:	3410      	adds	r4, #16
60003eb0:	f007 fd15 	bl	6000b8de <strncmp>
60003eb4:	9a03      	ldr	r2, [sp, #12]
60003eb6:	4605      	mov	r5, r0
60003eb8:	b950      	cbnz	r0, 60003ed0 <shell_backend_cmd_execute+0x68>
		func(shell, backend, argc, argv);
60003eba:	4643      	mov	r3, r8
60003ebc:	464a      	mov	r2, r9
60003ebe:	eb0b 1107 	add.w	r1, fp, r7, lsl #4
60003ec2:	4630      	mov	r0, r6
60003ec4:	9c02      	ldr	r4, [sp, #8]
60003ec6:	47a0      	blx	r4
}
60003ec8:	4628      	mov	r0, r5
60003eca:	b005      	add	sp, #20
60003ecc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (int i = 0; i < log_backend_count_get(); i++) {
60003ed0:	3701      	adds	r7, #1
60003ed2:	e7dd      	b.n	60003e90 <shell_backend_cmd_execute+0x28>
60003ed4:	6000cee8 	.word	0x6000cee8
60003ed8:	6000cf08 	.word	0x6000cf08
60003edc:	6000d916 	.word	0x6000d916

60003ee0 <cmd_log_backend_status>:
{
60003ee0:	b508      	push	{r3, lr}
	shell_backend_cmd_execute(shell, argc, argv, log_status);
60003ee2:	4b02      	ldr	r3, [pc, #8]	; (60003eec <cmd_log_backend_status+0xc>)
60003ee4:	f7ff ffc0 	bl	60003e68 <shell_backend_cmd_execute>
}
60003ee8:	2000      	movs	r0, #0
60003eea:	bd08      	pop	{r3, pc}
60003eec:	60003d91 	.word	0x60003d91

60003ef0 <cmd_log_backend_halt>:
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
60003ef0:	4b01      	ldr	r3, [pc, #4]	; (60003ef8 <cmd_log_backend_halt+0x8>)
60003ef2:	f7ff bfb9 	b.w	60003e68 <shell_backend_cmd_execute>
60003ef6:	bf00      	nop
60003ef8:	6000a5ff 	.word	0x6000a5ff

60003efc <cmd_log_backend_go>:
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
60003efc:	4b01      	ldr	r3, [pc, #4]	; (60003f04 <cmd_log_backend_go+0x8>)
60003efe:	f7ff bfb3 	b.w	60003e68 <shell_backend_cmd_execute>
60003f02:	bf00      	nop
60003f04:	6000a607 	.word	0x6000a607

60003f08 <cmd_log_backend_enable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
60003f08:	4b01      	ldr	r3, [pc, #4]	; (60003f10 <cmd_log_backend_enable+0x8>)
60003f0a:	f7ff bfad 	b.w	60003e68 <shell_backend_cmd_execute>
60003f0e:	bf00      	nop
60003f10:	60004015 	.word	0x60004015

60003f14 <cmd_log_backend_disable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
60003f14:	4b01      	ldr	r3, [pc, #4]	; (60003f1c <cmd_log_backend_disable+0x8>)
60003f16:	f7ff bfa7 	b.w	60003e68 <shell_backend_cmd_execute>
60003f1a:	bf00      	nop
60003f1c:	6000a653 	.word	0x6000a653

60003f20 <shell_state_precheck>:
	if (shell->log_backend->control_block->state
60003f20:	69c3      	ldr	r3, [r0, #28]
60003f22:	68db      	ldr	r3, [r3, #12]
{
60003f24:	b510      	push	{r4, lr}
	if (shell->log_backend->control_block->state
60003f26:	791c      	ldrb	r4, [r3, #4]
60003f28:	b92c      	cbnz	r4, 60003f36 <shell_state_precheck+0x16>
		shell_error(shell, "Shell log backend not initialized.");
60003f2a:	4a04      	ldr	r2, [pc, #16]	; (60003f3c <shell_state_precheck+0x1c>)
60003f2c:	2102      	movs	r1, #2
60003f2e:	f006 fcb4 	bl	6000a89a <shell_fprintf>
60003f32:	4620      	mov	r0, r4
}
60003f34:	bd10      	pop	{r4, pc}
	return true;
60003f36:	2001      	movs	r0, #1
60003f38:	e7fc      	b.n	60003f34 <shell_state_precheck+0x14>
60003f3a:	bf00      	nop
60003f3c:	6000d92b 	.word	0x6000d92b

60003f40 <filters_set>:
{
60003f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003f44:	461f      	mov	r7, r3
60003f46:	4e2d      	ldr	r6, [pc, #180]	; (60003ffc <filters_set+0xbc>)
60003f48:	4b2d      	ldr	r3, [pc, #180]	; (60004000 <filters_set+0xc0>)
	int cnt = all ? log_sources_count() : argc;
60003f4a:	1e15      	subs	r5, r2, #0
{
60003f4c:	b085      	sub	sp, #20
60003f4e:	4680      	mov	r8, r0
60003f50:	eba6 0603 	sub.w	r6, r6, r3
	int cnt = all ? log_sources_count() : argc;
60003f54:	bf18      	it	ne
60003f56:	462b      	movne	r3, r5
{
60003f58:	4689      	mov	r9, r1
60003f5a:	ea4f 06d6 	mov.w	r6, r6, lsr #3
	int cnt = all ? log_sources_count() : argc;
60003f5e:	bf08      	it	eq
60003f60:	4633      	moveq	r3, r6
60003f62:	9302      	str	r3, [sp, #8]
	if (!backend->cb->active) {
60003f64:	684b      	ldr	r3, [r1, #4]
60003f66:	795b      	ldrb	r3, [r3, #5]
60003f68:	b91b      	cbnz	r3, 60003f72 <filters_set+0x32>
		shell_warn(shell, "Backend not active.");
60003f6a:	4a26      	ldr	r2, [pc, #152]	; (60004004 <filters_set+0xc4>)
60003f6c:	2104      	movs	r1, #4
60003f6e:	f006 fc94 	bl	6000a89a <shell_fprintf>
	for (i = 0U; i < modules_cnt; i++) {
60003f72:	2400      	movs	r4, #0
				shell_warn(shell, "%s: level set to %s.",
60003f74:	f8df a090 	ldr.w	sl, [pc, #144]	; 60004008 <filters_set+0xc8>
	for (i = 0; i < cnt; i++) {
60003f78:	9b02      	ldr	r3, [sp, #8]
60003f7a:	429c      	cmp	r4, r3
60003f7c:	db02      	blt.n	60003f84 <filters_set+0x44>
}
60003f7e:	b005      	add	sp, #20
60003f80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		id = all ? i : module_id_get(argv[i]);
60003f84:	b3bd      	cbz	r5, 60003ff6 <filters_set+0xb6>
60003f86:	f857 b024 	ldr.w	fp, [r7, r4, lsl #2]
	for (i = 0U; i < modules_cnt; i++) {
60003f8a:	2300      	movs	r3, #0
60003f8c:	429e      	cmp	r6, r3
60003f8e:	d107      	bne.n	60003fa0 <filters_set+0x60>
			shell_error(shell, "%s: unknown source name.", argv[i]);
60003f90:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
60003f94:	2102      	movs	r1, #2
60003f96:	4a1d      	ldr	r2, [pc, #116]	; (6000400c <filters_set+0xcc>)
60003f98:	4640      	mov	r0, r8
60003f9a:	f006 fc7e 	bl	6000a89a <shell_fprintf>
60003f9e:	e023      	b.n	60003fe8 <filters_set+0xa8>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
60003fa0:	4619      	mov	r1, r3
60003fa2:	2000      	movs	r0, #0
60003fa4:	9303      	str	r3, [sp, #12]
60003fa6:	f7ff f983 	bl	600032b0 <log_source_name_get>
		if (strncmp(tmp_name, name, 64) == 0) {
60003faa:	2240      	movs	r2, #64	; 0x40
60003fac:	4659      	mov	r1, fp
60003fae:	f007 fc96 	bl	6000b8de <strncmp>
60003fb2:	9b03      	ldr	r3, [sp, #12]
60003fb4:	b9d0      	cbnz	r0, 60003fec <filters_set+0xac>
			return i;
60003fb6:	461a      	mov	r2, r3
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
60003fb8:	2100      	movs	r1, #0
60003fba:	9b0e      	ldr	r3, [sp, #56]	; 0x38
60003fbc:	b212      	sxth	r2, r2
60003fbe:	4648      	mov	r0, r9
60003fc0:	f7ff f984 	bl	600032cc <z_impl_log_filter_set>
			if (set_lvl != level) {
60003fc4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
60003fc6:	4683      	mov	fp, r0
60003fc8:	4283      	cmp	r3, r0
60003fca:	d00d      	beq.n	60003fe8 <filters_set+0xa8>
						CONFIG_LOG_DOMAIN_ID, i) :
60003fcc:	b985      	cbnz	r5, 60003ff0 <filters_set+0xb0>
					log_source_name_get(
60003fce:	4621      	mov	r1, r4
60003fd0:	4628      	mov	r0, r5
60003fd2:	f7ff f96d 	bl	600032b0 <log_source_name_get>
60003fd6:	4603      	mov	r3, r0
				shell_warn(shell, "%s: level set to %s.",
60003fd8:	f85a 202b 	ldr.w	r2, [sl, fp, lsl #2]
60003fdc:	2104      	movs	r1, #4
60003fde:	4640      	mov	r0, r8
60003fe0:	9200      	str	r2, [sp, #0]
60003fe2:	4a0b      	ldr	r2, [pc, #44]	; (60004010 <filters_set+0xd0>)
60003fe4:	f006 fc59 	bl	6000a89a <shell_fprintf>
	for (i = 0; i < cnt; i++) {
60003fe8:	3401      	adds	r4, #1
60003fea:	e7c5      	b.n	60003f78 <filters_set+0x38>
	for (i = 0U; i < modules_cnt; i++) {
60003fec:	3301      	adds	r3, #1
60003fee:	e7cd      	b.n	60003f8c <filters_set+0x4c>
						CONFIG_LOG_DOMAIN_ID, i) :
60003ff0:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
60003ff4:	e7f0      	b.n	60003fd8 <filters_set+0x98>
60003ff6:	4622      	mov	r2, r4
60003ff8:	e7de      	b.n	60003fb8 <filters_set+0x78>
60003ffa:	bf00      	nop
60003ffc:	6000cee8 	.word	0x6000cee8
60004000:	6000ceb8 	.word	0x6000ceb8
60004004:	6000d94f 	.word	0x6000d94f
60004008:	6000d09c 	.word	0x6000d09c
6000400c:	6000d97a 	.word	0x6000d97a
60004010:	6000d964 	.word	0x6000d964

60004014 <log_enable>:
{
60004014:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
60004018:	4606      	mov	r6, r0
6000401a:	4688      	mov	r8, r1
6000401c:	4691      	mov	r9, r2
6000401e:	461d      	mov	r5, r3
	severity_level = severity_level_get(argv[1]);
60004020:	f8d3 b004 	ldr.w	fp, [r3, #4]
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
60004024:	2700      	movs	r7, #0
60004026:	f8df a044 	ldr.w	sl, [pc, #68]	; 6000406c <log_enable+0x58>
		if (strncmp(str, severity_lvls[i], 4) == 0) {
6000402a:	2204      	movs	r2, #4
6000402c:	f85a 1b04 	ldr.w	r1, [sl], #4
60004030:	4658      	mov	r0, fp
60004032:	f007 fc54 	bl	6000b8de <strncmp>
60004036:	4604      	mov	r4, r0
60004038:	b170      	cbz	r0, 60004058 <log_enable+0x44>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
6000403a:	3701      	adds	r7, #1
6000403c:	2f05      	cmp	r7, #5
6000403e:	d1f4      	bne.n	6000402a <log_enable+0x16>
		shell_error(shell, "Invalid severity: %s", argv[1]);
60004040:	f06f 0407 	mvn.w	r4, #7
60004044:	686b      	ldr	r3, [r5, #4]
60004046:	4a0a      	ldr	r2, [pc, #40]	; (60004070 <log_enable+0x5c>)
60004048:	2102      	movs	r1, #2
6000404a:	4630      	mov	r0, r6
6000404c:	f006 fc25 	bl	6000a89a <shell_fprintf>
}
60004050:	4620      	mov	r0, r4
60004052:	b003      	add	sp, #12
60004054:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
60004058:	f105 0308 	add.w	r3, r5, #8
6000405c:	f1a9 0202 	sub.w	r2, r9, #2
60004060:	4641      	mov	r1, r8
60004062:	4630      	mov	r0, r6
60004064:	9700      	str	r7, [sp, #0]
60004066:	f7ff ff6b 	bl	60003f40 <filters_set>
	return 0;
6000406a:	e7f1      	b.n	60004050 <log_enable+0x3c>
6000406c:	6000d09c 	.word	0x6000d09c
60004070:	6000d994 	.word	0x6000d994

60004074 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
60004074:	4b01      	ldr	r3, [pc, #4]	; (6000407c <log_backend_rtt_init+0x8>)
60004076:	2201      	movs	r2, #1
60004078:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
6000407a:	4770      	bx	lr
6000407c:	80000f4e 	.word	0x80000f4e

60004080 <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
60004080:	4b02      	ldr	r3, [pc, #8]	; (6000408c <panic+0xc>)
60004082:	2201      	movs	r2, #1
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
60004084:	4802      	ldr	r0, [pc, #8]	; (60004090 <panic+0x10>)
60004086:	701a      	strb	r2, [r3, #0]
60004088:	f006 ba91 	b.w	6000a5ae <log_output_flush>
6000408c:	80000f4f 	.word	0x80000f4f
60004090:	6000d21c 	.word	0x6000d21c

60004094 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
60004094:	4801      	ldr	r0, [pc, #4]	; (6000409c <dropped+0x8>)
60004096:	f7ff bddb 	b.w	60003c50 <log_output_dropped_process>
6000409a:	bf00      	nop
6000409c:	6000d21c 	.word	0x6000d21c

600040a0 <put>:
{
600040a0:	b510      	push	{r4, lr}
600040a2:	460c      	mov	r4, r1
	log_msg_get(msg);
600040a4:	4608      	mov	r0, r1
600040a6:	f006 f877 	bl	6000a198 <log_msg_get>
	log_output_msg_process(output, msg, flags);
600040aa:	4805      	ldr	r0, [pc, #20]	; (600040c0 <put+0x20>)
600040ac:	4621      	mov	r1, r4
600040ae:	220f      	movs	r2, #15
600040b0:	f7ff fd52 	bl	60003b58 <log_output_msg_process>
	log_msg_put(msg);
600040b4:	4620      	mov	r0, r4
}
600040b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
600040ba:	f006 b89c 	b.w	6000a1f6 <log_msg_put>
600040be:	bf00      	nop
600040c0:	6000d21c 	.word	0x6000d21c

600040c4 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
600040c4:	4b05      	ldr	r3, [pc, #20]	; (600040dc <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
600040c6:	781b      	ldrb	r3, [r3, #0]
600040c8:	b11b      	cbz	r3, 600040d2 <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
600040ca:	f241 3088 	movw	r0, #5000	; 0x1388
600040ce:	f005 b95f 	b.w	60009390 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
600040d2:	2032      	movs	r0, #50	; 0x32
600040d4:	2100      	movs	r1, #0
600040d6:	f004 beeb 	b.w	60008eb0 <z_impl_k_sleep>
600040da:	bf00      	nop
600040dc:	80000f4f 	.word	0x80000f4f

600040e0 <data_out_block_mode>:
{
600040e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
600040e4:	4680      	mov	r8, r0
600040e6:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
600040e8:	2404      	movs	r4, #4
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
600040ea:	f8df 9088 	ldr.w	r9, [pc, #136]	; 60004174 <data_out_block_mode+0x94>
	return z_impl_k_mutex_lock(mutex, timeout);
600040ee:	f8df a088 	ldr.w	sl, [pc, #136]	; 60004178 <data_out_block_mode+0x98>
		if (!is_sync_mode()) {
600040f2:	f899 5000 	ldrb.w	r5, [r9]
600040f6:	b9cd      	cbnz	r5, 6000412c <data_out_block_mode+0x4c>
600040f8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
600040fc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60004100:	4650      	mov	r0, sl
60004102:	f004 fa97 	bl	60008634 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
60004106:	463a      	mov	r2, r7
60004108:	4641      	mov	r1, r8
6000410a:	4628      	mov	r0, r5
6000410c:	f003 f83c 	bl	60007188 <SEGGER_RTT_WriteSkipNoLock>
60004110:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
60004112:	4650      	mov	r0, sl
60004114:	f004 fb18 	bl	60008748 <z_impl_k_mutex_unlock>
		if (ret) {
60004118:	4d18      	ldr	r5, [pc, #96]	; (6000417c <data_out_block_mode+0x9c>)
6000411a:	b1fe      	cbz	r6, 6000415c <data_out_block_mode+0x7c>
	host_present = true;
6000411c:	2301      	movs	r3, #1
6000411e:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
60004120:	f899 3000 	ldrb.w	r3, [r9]
60004124:	b96b      	cbnz	r3, 60004142 <data_out_block_mode+0x62>
}
60004126:	4638      	mov	r0, r7
60004128:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
6000412c:	463a      	mov	r2, r7
6000412e:	4641      	mov	r1, r8
60004130:	2000      	movs	r0, #0
60004132:	f003 f829 	bl	60007188 <SEGGER_RTT_WriteSkipNoLock>
60004136:	4606      	mov	r6, r0
60004138:	e7ee      	b.n	60004118 <data_out_block_mode+0x38>
	if (retry_cnt == 0) {
6000413a:	b95c      	cbnz	r4, 60004154 <data_out_block_mode+0x74>
		host_present = false;
6000413c:	702c      	strb	r4, [r5, #0]
6000413e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
60004142:	2000      	movs	r0, #0
60004144:	f003 f89c 	bl	60007280 <SEGGER_RTT_HasDataUp>
60004148:	2800      	cmp	r0, #0
6000414a:	d0ec      	beq.n	60004126 <data_out_block_mode+0x46>
6000414c:	782b      	ldrb	r3, [r5, #0]
6000414e:	2b00      	cmp	r3, #0
60004150:	d1f3      	bne.n	6000413a <data_out_block_mode+0x5a>
60004152:	e7e8      	b.n	60004126 <data_out_block_mode+0x46>
			on_failed_write(retry_cnt--);
60004154:	3c01      	subs	r4, #1
60004156:	f7ff ffb5 	bl	600040c4 <on_failed_write.part.0>
6000415a:	e7f2      	b.n	60004142 <data_out_block_mode+0x62>
		} else if (host_present) {
6000415c:	782b      	ldrb	r3, [r5, #0]
6000415e:	b113      	cbz	r3, 60004166 <data_out_block_mode+0x86>
	if (retry_cnt == 0) {
60004160:	3c01      	subs	r4, #1
60004162:	d104      	bne.n	6000416e <data_out_block_mode+0x8e>
		host_present = false;
60004164:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
60004166:	782b      	ldrb	r3, [r5, #0]
60004168:	2b00      	cmp	r3, #0
6000416a:	d1c2      	bne.n	600040f2 <data_out_block_mode+0x12>
6000416c:	e7db      	b.n	60004126 <data_out_block_mode+0x46>
6000416e:	f7ff ffa9 	bl	600040c4 <on_failed_write.part.0>
60004172:	e7f8      	b.n	60004166 <data_out_block_mode+0x86>
60004174:	80000f4f 	.word	0x80000f4f
60004178:	8000024c 	.word	0x8000024c
6000417c:	80000f4e 	.word	0x80000f4e

60004180 <cmd_kernel_version>:
#include <drivers/timer/system_timer.h>
#include <kernel.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
60004180:	b513      	push	{r0, r1, r4, lr}
60004182:	4604      	mov	r4, r0
	uint32_t version = sys_kernel_version_get();
60004184:	f004 f9a2 	bl	600084cc <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
60004188:	f3c0 2307 	ubfx	r3, r0, #8, #8
6000418c:	4a06      	ldr	r2, [pc, #24]	; (600041a8 <cmd_kernel_version+0x28>)
6000418e:	2100      	movs	r1, #0
60004190:	9301      	str	r3, [sp, #4]
60004192:	f3c0 4307 	ubfx	r3, r0, #16, #8
60004196:	9300      	str	r3, [sp, #0]
60004198:	0e03      	lsrs	r3, r0, #24
6000419a:	4620      	mov	r0, r4
6000419c:	f006 fb7d 	bl	6000a89a <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
600041a0:	2000      	movs	r0, #0
600041a2:	b002      	add	sp, #8
600041a4:	bd10      	pop	{r4, pc}
600041a6:	bf00      	nop
600041a8:	6000db4b 	.word	0x6000db4b

600041ac <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
600041ac:	b510      	push	{r4, lr}
600041ae:	4604      	mov	r4, r0
	return z_impl_k_uptime_ticks();
600041b0:	f008 f9c8 	bl	6000c544 <z_impl_k_uptime_ticks>
			return t / (from_hz / to_hz);
600041b4:	220a      	movs	r2, #10
600041b6:	2300      	movs	r3, #0
600041b8:	f7fe f882 	bl	600022c0 <__aeabi_uldivmod>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
600041bc:	4a03      	ldr	r2, [pc, #12]	; (600041cc <cmd_kernel_uptime+0x20>)
600041be:	4603      	mov	r3, r0
600041c0:	2100      	movs	r1, #0
600041c2:	4620      	mov	r0, r4
600041c4:	f006 fb69 	bl	6000a89a <shell_fprintf>
	return 0;
}
600041c8:	2000      	movs	r0, #0
600041ca:	bd10      	pop	{r4, pc}
600041cc:	6000db64 	.word	0x6000db64

600041d0 <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
600041d0:	b510      	push	{r4, lr}
600041d2:	4604      	mov	r4, r0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", sys_clock_elapsed());
600041d4:	f001 feca 	bl	60005f6c <sys_clock_elapsed>
600041d8:	4a08      	ldr	r2, [pc, #32]	; (600041fc <cmd_kernel_threads+0x2c>)
600041da:	4603      	mov	r3, r0
600041dc:	2100      	movs	r1, #0
600041de:	4620      	mov	r0, r4
600041e0:	f006 fb5b 	bl	6000a89a <shell_fprintf>
	shell_print(shell, "Threads:");
600041e4:	4a06      	ldr	r2, [pc, #24]	; (60004200 <cmd_kernel_threads+0x30>)
600041e6:	4620      	mov	r0, r4
600041e8:	2100      	movs	r1, #0
600041ea:	f006 fb56 	bl	6000a89a <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)shell);
600041ee:	4621      	mov	r1, r4
600041f0:	4804      	ldr	r0, [pc, #16]	; (60004204 <cmd_kernel_threads+0x34>)
600041f2:	f003 fff3 	bl	600081dc <k_thread_foreach>
	return 0;
}
600041f6:	2000      	movs	r0, #0
600041f8:	bd10      	pop	{r4, pc}
600041fa:	bf00      	nop
600041fc:	6000db73 	.word	0x6000db73
60004200:	6000db92 	.word	0x6000db92
60004204:	60004269 	.word	0x60004269

60004208 <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
60004208:	b530      	push	{r4, r5, lr}
	uint8_t *buf;
	size_t size, unused;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
6000420a:	4601      	mov	r1, r0
{
6000420c:	b087      	sub	sp, #28
6000420e:	4604      	mov	r4, r0
	k_thread_foreach(shell_stack_dump, (void *)shell);
60004210:	4811      	ldr	r0, [pc, #68]	; (60004258 <cmd_kernel_stacks+0x50>)
60004212:	f003 ffe3 	bl	600081dc <k_thread_foreach>
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		unused = 0;
		for (size_t i = 0; i < size; i++) {
60004216:	4a11      	ldr	r2, [pc, #68]	; (6000425c <cmd_kernel_stacks+0x54>)
		unused = 0;
60004218:	2300      	movs	r3, #0
			if (buf[i] == 0xAAU) {
6000421a:	f812 1b01 	ldrb.w	r1, [r2], #1
6000421e:	29aa      	cmp	r1, #170	; 0xaa
60004220:	d103      	bne.n	6000422a <cmd_kernel_stacks+0x22>
				unused++;
60004222:	3301      	adds	r3, #1
		for (size_t i = 0; i < size; i++) {
60004224:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
60004228:	d1f7      	bne.n	6000421a <cmd_kernel_stacks+0x12>
			} else {
				break;
			}
		}

		shell_print(shell,
6000422a:	f5c3 6100 	rsb	r1, r3, #2048	; 0x800
6000422e:	2264      	movs	r2, #100	; 0x64
60004230:	2500      	movs	r5, #0
60004232:	4620      	mov	r0, r4
60004234:	434a      	muls	r2, r1
60004236:	9500      	str	r5, [sp, #0]
60004238:	0ad2      	lsrs	r2, r2, #11
6000423a:	9205      	str	r2, [sp, #20]
6000423c:	f44f 6200 	mov.w	r2, #2048	; 0x800
60004240:	e9cd 1203 	strd	r1, r2, [sp, #12]
60004244:	e9cd 2301 	strd	r2, r3, [sp, #4]
60004248:	4629      	mov	r1, r5
6000424a:	4b05      	ldr	r3, [pc, #20]	; (60004260 <cmd_kernel_stacks+0x58>)
6000424c:	4a05      	ldr	r2, [pc, #20]	; (60004264 <cmd_kernel_stacks+0x5c>)
6000424e:	f006 fb24 	bl	6000a89a <shell_fprintf>
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
60004252:	4628      	mov	r0, r5
60004254:	b007      	add	sp, #28
60004256:	bd30      	pop	{r4, r5, pc}
60004258:	60004351 	.word	0x60004351
6000425c:	80003200 	.word	0x80003200
60004260:	800031e0 	.word	0x800031e0
60004264:	6000db9c 	.word	0x6000db9c

60004268 <shell_tdata_dump>:
{
60004268:	b5f0      	push	{r4, r5, r6, r7, lr}
6000426a:	b087      	sub	sp, #28
6000426c:	4604      	mov	r4, r0
6000426e:	460d      	mov	r5, r1
	size_t size = thread->stack_info.size;
60004270:	f8d0 70a8 	ldr.w	r7, [r0, #168]	; 0xa8
	tname = k_thread_name_get(thread);
60004274:	f007 ffb5 	bl	6000c1e2 <k_thread_name_get>
60004278:	4606      	mov	r6, r0
	return z_impl_k_current_get();
6000427a:	f004 fe47 	bl	60008f0c <z_impl_k_current_get>
	shell_print(shell, "%s%p %-10s",
6000427e:	4b25      	ldr	r3, [pc, #148]	; (60004314 <shell_tdata_dump+0xac>)
60004280:	4a25      	ldr	r2, [pc, #148]	; (60004318 <shell_tdata_dump+0xb0>)
60004282:	2100      	movs	r1, #0
60004284:	2e00      	cmp	r6, #0
60004286:	bf08      	it	eq
60004288:	461e      	moveq	r6, r3
6000428a:	4b24      	ldr	r3, [pc, #144]	; (6000431c <shell_tdata_dump+0xb4>)
6000428c:	e9cd 4600 	strd	r4, r6, [sp]
60004290:	4284      	cmp	r4, r0
60004292:	bf18      	it	ne
60004294:	4613      	movne	r3, r2
60004296:	4628      	mov	r0, r5
60004298:	4a21      	ldr	r2, [pc, #132]	; (60004320 <shell_tdata_dump+0xb8>)
6000429a:	f006 fafe 	bl	6000a89a <shell_fprintf>
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %d",
6000429e:	2100      	movs	r1, #0
600042a0:	4628      	mov	r0, r5
600042a2:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
600042a6:	e9cd 2302 	strd	r2, r3, [sp, #8]
600042aa:	f994 300e 	ldrsb.w	r3, [r4, #14]
600042ae:	4a1d      	ldr	r2, [pc, #116]	; (60004324 <shell_tdata_dump+0xbc>)
600042b0:	9300      	str	r3, [sp, #0]
600042b2:	7b23      	ldrb	r3, [r4, #12]
600042b4:	f006 faf1 	bl	6000a89a <shell_fprintf>
	shell_print(shell, "\tstate: %s, entry: %p", k_thread_state_str(thread),
600042b8:	4620      	mov	r0, r4
600042ba:	f003 ffe5 	bl	60008288 <k_thread_state_str>
600042be:	f104 036c 	add.w	r3, r4, #108	; 0x6c
600042c2:	4606      	mov	r6, r0
600042c4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
600042c6:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
600042ca:	4633      	mov	r3, r6
600042cc:	4a16      	ldr	r2, [pc, #88]	; (60004328 <shell_tdata_dump+0xc0>)
600042ce:	2100      	movs	r1, #0
600042d0:	4628      	mov	r0, r5
600042d2:	f006 fae2 	bl	6000a89a <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
600042d6:	a905      	add	r1, sp, #20
600042d8:	4620      	mov	r0, r4
600042da:	f007 ff8f 	bl	6000c1fc <z_impl_k_thread_stack_space_get>
	if (ret) {
600042de:	4601      	mov	r1, r0
600042e0:	b138      	cbz	r0, 600042f2 <shell_tdata_dump+0x8a>
		shell_print(shell,
600042e2:	4603      	mov	r3, r0
600042e4:	4a11      	ldr	r2, [pc, #68]	; (6000432c <shell_tdata_dump+0xc4>)
600042e6:	2100      	movs	r1, #0
600042e8:	4628      	mov	r0, r5
600042ea:	f006 fad6 	bl	6000a89a <shell_fprintf>
}
600042ee:	b007      	add	sp, #28
600042f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pcnt = ((size - unused) * 100U) / size;
600042f2:	9a05      	ldr	r2, [sp, #20]
600042f4:	2364      	movs	r3, #100	; 0x64
600042f6:	1ab8      	subs	r0, r7, r2
600042f8:	4343      	muls	r3, r0
600042fa:	fbb3 f3f7 	udiv	r3, r3, r7
		shell_print(shell,
600042fe:	e9cd 2000 	strd	r2, r0, [sp]
60004302:	e9cd 7302 	strd	r7, r3, [sp, #8]
60004306:	4a0a      	ldr	r2, [pc, #40]	; (60004330 <shell_tdata_dump+0xc8>)
60004308:	463b      	mov	r3, r7
6000430a:	4628      	mov	r0, r5
6000430c:	f006 fac5 	bl	6000a89a <shell_fprintf>
}
60004310:	e7ed      	b.n	600042ee <shell_tdata_dump+0x86>
60004312:	bf00      	nop
60004314:	6000dbe2 	.word	0x6000dbe2
60004318:	6000d7d0 	.word	0x6000d7d0
6000431c:	6000ea71 	.word	0x6000ea71
60004320:	6000dbe5 	.word	0x6000dbe5
60004324:	6000dbf1 	.word	0x6000dbf1
60004328:	6000dc1b 	.word	0x6000dc1b
6000432c:	6000dc32 	.word	0x6000dc32
60004330:	6000dc5f 	.word	0x6000dc5f

60004334 <cmd_kernel_cycles>:
{
60004334:	b510      	push	{r4, lr}
60004336:	4604      	mov	r4, r0
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
60004338:	f001 fe36 	bl	60005fa8 <sys_clock_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
6000433c:	4a03      	ldr	r2, [pc, #12]	; (6000434c <cmd_kernel_cycles+0x18>)
6000433e:	4603      	mov	r3, r0
60004340:	2100      	movs	r1, #0
60004342:	4620      	mov	r0, r4
60004344:	f006 faa9 	bl	6000a89a <shell_fprintf>
}
60004348:	2000      	movs	r0, #0
6000434a:	bd10      	pop	{r4, pc}
6000434c:	6000dc96 	.word	0x6000dc96

60004350 <shell_stack_dump>:
{
60004350:	b5f0      	push	{r4, r5, r6, r7, lr}
60004352:	4605      	mov	r5, r0
60004354:	b089      	sub	sp, #36	; 0x24
60004356:	460e      	mov	r6, r1
	size_t size = thread->stack_info.size;
60004358:	f8d0 70a8 	ldr.w	r7, [r0, #168]	; 0xa8
6000435c:	a907      	add	r1, sp, #28
6000435e:	f007 ff4d 	bl	6000c1fc <z_impl_k_thread_stack_space_get>
	if (ret) {
60004362:	4604      	mov	r4, r0
60004364:	b138      	cbz	r0, 60004376 <shell_stack_dump+0x26>
		shell_print(shell,
60004366:	4603      	mov	r3, r0
60004368:	4a11      	ldr	r2, [pc, #68]	; (600043b0 <shell_stack_dump+0x60>)
6000436a:	2100      	movs	r1, #0
6000436c:	4630      	mov	r0, r6
6000436e:	f006 fa94 	bl	6000a89a <shell_fprintf>
}
60004372:	b009      	add	sp, #36	; 0x24
60004374:	bdf0      	pop	{r4, r5, r6, r7, pc}
	tname = k_thread_name_get((struct k_thread *)thread);
60004376:	4628      	mov	r0, r5
60004378:	f007 ff33 	bl	6000c1e2 <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
6000437c:	9907      	ldr	r1, [sp, #28]
6000437e:	2364      	movs	r3, #100	; 0x64
	shell_print((const struct shell *)user_data,
60004380:	4a0c      	ldr	r2, [pc, #48]	; (600043b4 <shell_stack_dump+0x64>)
	pcnt = ((size - unused) * 100U) / size;
60004382:	eba7 0c01 	sub.w	ip, r7, r1
	shell_print((const struct shell *)user_data,
60004386:	2800      	cmp	r0, #0
60004388:	bf18      	it	ne
6000438a:	4602      	movne	r2, r0
6000438c:	4630      	mov	r0, r6
	pcnt = ((size - unused) * 100U) / size;
6000438e:	fb03 f30c 	mul.w	r3, r3, ip
60004392:	fbb3 f3f7 	udiv	r3, r3, r7
	shell_print((const struct shell *)user_data,
60004396:	e9cd 1c02 	strd	r1, ip, [sp, #8]
6000439a:	e9cd 7304 	strd	r7, r3, [sp, #16]
6000439e:	e9cd 2700 	strd	r2, r7, [sp]
600043a2:	462b      	mov	r3, r5
600043a4:	4a04      	ldr	r2, [pc, #16]	; (600043b8 <shell_stack_dump+0x68>)
600043a6:	4621      	mov	r1, r4
600043a8:	f006 fa77 	bl	6000a89a <shell_fprintf>
600043ac:	e7e1      	b.n	60004372 <shell_stack_dump+0x22>
600043ae:	bf00      	nop
600043b0:	6000dc32 	.word	0x6000dc32
600043b4:	6000dbe2 	.word	0x6000dbe2
600043b8:	6000dcac 	.word	0x6000dcac

600043bc <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
600043bc:	4603      	mov	r3, r0
	const char *name = dev->name;
600043be:	6800      	ldr	r0, [r0, #0]
{
600043c0:	b510      	push	{r4, lr}
600043c2:	460c      	mov	r4, r1
600043c4:	4611      	mov	r1, r2

	if ((name == NULL) || (name[0] == 0)) {
600043c6:	b108      	cbz	r0, 600043cc <get_device_name+0x10>
600043c8:	7802      	ldrb	r2, [r0, #0]
600043ca:	b922      	cbnz	r2, 600043d6 <get_device_name+0x1a>
		snprintf(buf, len, "[%p]", dev);
600043cc:	4a02      	ldr	r2, [pc, #8]	; (600043d8 <get_device_name+0x1c>)
600043ce:	4620      	mov	r0, r4
600043d0:	f002 fb84 	bl	60006adc <snprintf>
		name = buf;
600043d4:	4620      	mov	r0, r4
	}

	return name;
}
600043d6:	bd10      	pop	{r4, pc}
600043d8:	6000dd7f 	.word	0x6000dd7f

600043dc <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
600043dc:	b510      	push	{r4, lr}
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
600043de:	680c      	ldr	r4, [r1, #0]
600043e0:	e9d1 1201 	ldrd	r1, r2, [r1, #4]
600043e4:	f7ff ffea 	bl	600043bc <get_device_name>
600043e8:	4a03      	ldr	r2, [pc, #12]	; (600043f8 <cmd_device_list_visitor+0x1c>)
600043ea:	4603      	mov	r3, r0
600043ec:	2100      	movs	r1, #0
600043ee:	4620      	mov	r0, r4
600043f0:	f006 fa53 	bl	6000a89a <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
600043f4:	2000      	movs	r0, #0
600043f6:	bd10      	pop	{r4, pc}
600043f8:	6000dd84 	.word	0x6000dd84

600043fc <cmd_device_list>:

static int cmd_device_list(const struct shell *shell,
			   size_t argc, char **argv)
{
600043fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
60004400:	b08a      	sub	sp, #40	; 0x28
60004402:	4605      	mov	r5, r0
	for (dev = devlist; dev < devlist_end; dev++) {
		char buf[20];
		const char *name = get_device_name(dev, buf, sizeof(buf));
		const char *state = "READY";

		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
60004404:	f8df 8074 	ldr.w	r8, [pc, #116]	; 6000447c <cmd_device_list+0x80>
	size_t devcnt = z_device_get_all_static(&devlist);
60004408:	a801      	add	r0, sp, #4
		if (!device_is_ready(dev)) {
			state = "DISABLED";
6000440a:	f8df 9074 	ldr.w	r9, [pc, #116]	; 60004480 <cmd_device_list+0x84>
	size_t devcnt = z_device_get_all_static(&devlist);
6000440e:	f003 fcb7 	bl	60007d80 <z_device_get_all_static>
	const struct device *devlist_end = devlist + devcnt;
60004412:	2318      	movs	r3, #24
60004414:	9e01      	ldr	r6, [sp, #4]
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
60004416:	2100      	movs	r1, #0
60004418:	4a1a      	ldr	r2, [pc, #104]	; (60004484 <cmd_device_list+0x88>)
	const struct device *devlist_end = devlist + devcnt;
6000441a:	fb03 6600 	mla	r6, r3, r0, r6
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
6000441e:	4628      	mov	r0, r5
60004420:	f006 fa3b 	bl	6000a89a <shell_fprintf>
			state = "DISABLED";
60004424:	f8df a060 	ldr.w	sl, [pc, #96]	; 60004488 <cmd_device_list+0x8c>
	for (dev = devlist; dev < devlist_end; dev++) {
60004428:	9c01      	ldr	r4, [sp, #4]
6000442a:	42b4      	cmp	r4, r6
6000442c:	d303      	bcc.n	60004436 <cmd_device_list+0x3a>
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
		}
	}

	return 0;
}
6000442e:	2000      	movs	r0, #0
60004430:	b00a      	add	sp, #40	; 0x28
60004432:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const char *name = get_device_name(dev, buf, sizeof(buf));
60004436:	af05      	add	r7, sp, #20
60004438:	2214      	movs	r2, #20
6000443a:	4620      	mov	r0, r4
6000443c:	4639      	mov	r1, r7
6000443e:	f7ff ffbd 	bl	600043bc <get_device_name>
		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
60004442:	4642      	mov	r2, r8
		const char *name = get_device_name(dev, buf, sizeof(buf));
60004444:	4603      	mov	r3, r0
		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
60004446:	2100      	movs	r1, #0
60004448:	4628      	mov	r0, r5
6000444a:	f006 fa26 	bl	6000a89a <shell_fprintf>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
6000444e:	4620      	mov	r0, r4
60004450:	f007 fe52 	bl	6000c0f8 <z_device_ready>
		shell_fprintf(shell, SHELL_NORMAL, " (%s)\n", state);
60004454:	4a0d      	ldr	r2, [pc, #52]	; (6000448c <cmd_device_list+0x90>)
60004456:	2800      	cmp	r0, #0
60004458:	bf14      	ite	ne
6000445a:	464b      	movne	r3, r9
6000445c:	4653      	moveq	r3, sl
6000445e:	2100      	movs	r1, #0
60004460:	4628      	mov	r0, r5
60004462:	f006 fa1a 	bl	6000a89a <shell_fprintf>
			struct cmd_device_list_visitor_context ctx = {
60004466:	2314      	movs	r3, #20
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
60004468:	4620      	mov	r0, r4
6000446a:	aa02      	add	r2, sp, #8
6000446c:	4908      	ldr	r1, [pc, #32]	; (60004490 <cmd_device_list+0x94>)
	for (dev = devlist; dev < devlist_end; dev++) {
6000446e:	3418      	adds	r4, #24
			struct cmd_device_list_visitor_context ctx = {
60004470:	9304      	str	r3, [sp, #16]
60004472:	e9cd 5702 	strd	r5, r7, [sp, #8]
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
60004476:	f003 fcbb 	bl	60007df0 <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
6000447a:	e7d6      	b.n	6000442a <cmd_device_list+0x2e>
6000447c:	6000ddad 	.word	0x6000ddad
60004480:	6000dd94 	.word	0x6000dd94
60004484:	6000dda3 	.word	0x6000dda3
60004488:	6000dd9a 	.word	0x6000dd9a
6000448c:	6000ddb2 	.word	0x6000ddb2
60004490:	600043dd 	.word	0x600043dd

60004494 <device_get_config_level>:
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
60004494:	4b12      	ldr	r3, [pc, #72]	; (600044e0 <device_get_config_level+0x4c>)
{
60004496:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
6000449a:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
6000449e:	3101      	adds	r1, #1
{
600044a0:	b087      	sub	sp, #28
600044a2:	4606      	mov	r6, r0
	bool devices = false;
600044a4:	2700      	movs	r7, #0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
600044a6:	f853 8021 	ldr.w	r8, [r3, r1, lsl #2]
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
600044aa:	f8df 9038 	ldr.w	r9, [pc, #56]	; 600044e4 <device_get_config_level+0x50>
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
600044ae:	45a0      	cmp	r8, r4
600044b0:	d803      	bhi.n	600044ba <device_get_config_level+0x26>
}
600044b2:	4638      	mov	r0, r7
600044b4:	b007      	add	sp, #28
600044b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
600044ba:	4620      	mov	r0, r4
600044bc:	f007 fe1c 	bl	6000c0f8 <z_device_ready>
600044c0:	4605      	mov	r5, r0
600044c2:	b158      	cbz	r0, 600044dc <device_get_config_level+0x48>
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
600044c4:	2214      	movs	r2, #20
600044c6:	a901      	add	r1, sp, #4
600044c8:	4620      	mov	r0, r4
			devices = true;
600044ca:	462f      	mov	r7, r5
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
600044cc:	f7ff ff76 	bl	600043bc <get_device_name>
600044d0:	464a      	mov	r2, r9
600044d2:	4603      	mov	r3, r0
600044d4:	2100      	movs	r1, #0
600044d6:	4630      	mov	r0, r6
600044d8:	f006 f9df 	bl	6000a89a <shell_fprintf>
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
600044dc:	3418      	adds	r4, #24
600044de:	e7e6      	b.n	600044ae <device_get_config_level+0x1a>
600044e0:	6000d2d4 	.word	0x6000d2d4
600044e4:	6000ddb9 	.word	0x6000ddb9

600044e8 <cmd_device_levels>:
{
600044e8:	b510      	push	{r4, lr}
600044ea:	4604      	mov	r4, r0
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
600044ec:	4a1e      	ldr	r2, [pc, #120]	; (60004568 <cmd_device_levels+0x80>)
600044ee:	2100      	movs	r1, #0
600044f0:	f006 f9d3 	bl	6000a89a <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
600044f4:	2100      	movs	r1, #0
600044f6:	4620      	mov	r0, r4
600044f8:	f7ff ffcc 	bl	60004494 <device_get_config_level>
	if (ret == false) {
600044fc:	4601      	mov	r1, r0
600044fe:	b918      	cbnz	r0, 60004508 <cmd_device_levels+0x20>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
60004500:	4a1a      	ldr	r2, [pc, #104]	; (6000456c <cmd_device_levels+0x84>)
60004502:	4620      	mov	r0, r4
60004504:	f006 f9c9 	bl	6000a89a <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
60004508:	4a19      	ldr	r2, [pc, #100]	; (60004570 <cmd_device_levels+0x88>)
6000450a:	2100      	movs	r1, #0
6000450c:	4620      	mov	r0, r4
6000450e:	f006 f9c4 	bl	6000a89a <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
60004512:	2101      	movs	r1, #1
60004514:	4620      	mov	r0, r4
60004516:	f7ff ffbd 	bl	60004494 <device_get_config_level>
	if (ret == false) {
6000451a:	4601      	mov	r1, r0
6000451c:	b918      	cbnz	r0, 60004526 <cmd_device_levels+0x3e>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
6000451e:	4a13      	ldr	r2, [pc, #76]	; (6000456c <cmd_device_levels+0x84>)
60004520:	4620      	mov	r0, r4
60004522:	f006 f9ba 	bl	6000a89a <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
60004526:	4a13      	ldr	r2, [pc, #76]	; (60004574 <cmd_device_levels+0x8c>)
60004528:	2100      	movs	r1, #0
6000452a:	4620      	mov	r0, r4
6000452c:	f006 f9b5 	bl	6000a89a <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
60004530:	2102      	movs	r1, #2
60004532:	4620      	mov	r0, r4
60004534:	f7ff ffae 	bl	60004494 <device_get_config_level>
	if (ret == false) {
60004538:	4601      	mov	r1, r0
6000453a:	b918      	cbnz	r0, 60004544 <cmd_device_levels+0x5c>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
6000453c:	4a0b      	ldr	r2, [pc, #44]	; (6000456c <cmd_device_levels+0x84>)
6000453e:	4620      	mov	r0, r4
60004540:	f006 f9ab 	bl	6000a89a <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
60004544:	4a0c      	ldr	r2, [pc, #48]	; (60004578 <cmd_device_levels+0x90>)
60004546:	2100      	movs	r1, #0
60004548:	4620      	mov	r0, r4
6000454a:	f006 f9a6 	bl	6000a89a <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
6000454e:	2103      	movs	r1, #3
60004550:	4620      	mov	r0, r4
60004552:	f7ff ff9f 	bl	60004494 <device_get_config_level>
	if (ret == false) {
60004556:	4601      	mov	r1, r0
60004558:	b918      	cbnz	r0, 60004562 <cmd_device_levels+0x7a>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
6000455a:	4a04      	ldr	r2, [pc, #16]	; (6000456c <cmd_device_levels+0x84>)
6000455c:	4620      	mov	r0, r4
6000455e:	f006 f99c 	bl	6000a89a <shell_fprintf>
}
60004562:	2000      	movs	r0, #0
60004564:	bd10      	pop	{r4, pc}
60004566:	bf00      	nop
60004568:	6000ddbf 	.word	0x6000ddbf
6000456c:	6000ddce 	.word	0x6000ddce
60004570:	6000ddd6 	.word	0x6000ddd6
60004574:	6000dde5 	.word	0x6000dde5
60004578:	6000ddf3 	.word	0x6000ddf3

6000457c <shell_internal_help_print>:
{
	if (!IS_ENABLED(CONFIG_SHELL_HELP)) {
		return;
	}

	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
6000457c:	6881      	ldr	r1, [r0, #8]
{
6000457e:	b510      	push	{r4, lr}
60004580:	4604      	mov	r4, r0
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
60004582:	3108      	adds	r1, #8
60004584:	f001 f91a 	bl	600057bc <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
60004588:	4a03      	ldr	r2, [pc, #12]	; (60004598 <shell_internal_help_print+0x1c>)
6000458a:	68a1      	ldr	r1, [r4, #8]
6000458c:	4620      	mov	r0, r4
6000458e:	3108      	adds	r1, #8
				  "Subcommands:\n");
}
60004590:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
60004594:	f001 b8ba 	b.w	6000570c <z_shell_help_subcmd_print>
60004598:	6000de57 	.word	0x6000de57

6000459c <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n");
6000459c:	4901      	ldr	r1, [pc, #4]	; (600045a4 <z_cursor_next_line_move.isra.0+0x8>)
6000459e:	f006 b8c4 	b.w	6000a72a <z_shell_raw_fprintf>
600045a2:	bf00      	nop
600045a4:	6000dc94 	.word	0x6000dc94

600045a8 <history_handle>:

	z_shell_history_put(shell->history, line, length);
}

static void history_handle(const struct shell *shell, bool up)
{
600045a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
600045aa:	4604      	mov	r4, r0
	return ret;
}

static inline bool z_flag_history_exit_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.history_exit == 1;
600045ac:	6880      	ldr	r0, [r0, #8]
600045ae:	460d      	mov	r5, r1
600045b0:	f8d0 325c 	ldr.w	r3, [r0, #604]	; 0x25c
	if (!IS_ENABLED(CONFIG_SHELL_HISTORY)) {
		return;
	}

	/* Checking if history process has been stopped */
	if (z_flag_history_exit_get(shell)) {
600045b4:	061b      	lsls	r3, r3, #24
600045b6:	d505      	bpl.n	600045c4 <history_handle+0x1c>
		z_flag_history_exit_set(shell, false);
600045b8:	2100      	movs	r1, #0
600045ba:	f006 f8f7 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(shell->history);
600045be:	68e0      	ldr	r0, [r4, #12]
600045c0:	f006 fec6 	bl	6000b350 <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
600045c4:	68e3      	ldr	r3, [r4, #12]
	}

	/* Backup command if history is entered */
	if (!z_shell_history_active(shell->history)) {
600045c6:	68db      	ldr	r3, [r3, #12]
600045c8:	b963      	cbnz	r3, 600045e4 <history_handle+0x3c>
		if (up) {
600045ca:	b39d      	cbz	r5, 60004634 <history_handle+0x8c>
			uint16_t cmd_len = z_shell_strlen(shell->ctx->cmd_buff);
600045cc:	68a0      	ldr	r0, [r4, #8]
600045ce:	303e      	adds	r0, #62	; 0x3e
600045d0:	f006 f8a5 	bl	6000a71e <z_shell_strlen>

			if (cmd_len) {
600045d4:	68a3      	ldr	r3, [r4, #8]
600045d6:	b378      	cbz	r0, 60004638 <history_handle+0x90>
				strcpy(shell->ctx->temp_buff,
600045d8:	f103 013e 	add.w	r1, r3, #62	; 0x3e
600045dc:	f503 709f 	add.w	r0, r3, #318	; 0x13e
600045e0:	f007 f938 	bl	6000b854 <strcpy>
		}
	}

	/* Start by checking if history is not empty. */
	history_mode = z_shell_history_get(shell->history, up,
					   shell->ctx->cmd_buff, &len);
600045e4:	68a2      	ldr	r2, [r4, #8]
	history_mode = z_shell_history_get(shell->history, up,
600045e6:	f10d 0306 	add.w	r3, sp, #6
600045ea:	4629      	mov	r1, r5
600045ec:	68e0      	ldr	r0, [r4, #12]
600045ee:	323e      	adds	r2, #62	; 0x3e
600045f0:	f006 feb1 	bl	6000b356 <z_shell_history_get>

	/* On exiting history mode print backed up command. */
	if (!history_mode) {
600045f4:	b958      	cbnz	r0, 6000460e <history_handle+0x66>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
600045f6:	68a0      	ldr	r0, [r4, #8]
600045f8:	f500 719f 	add.w	r1, r0, #318	; 0x13e
600045fc:	303e      	adds	r0, #62	; 0x3e
600045fe:	f007 f929 	bl	6000b854 <strcpy>
		len = z_shell_strlen(shell->ctx->cmd_buff);
60004602:	68a0      	ldr	r0, [r4, #8]
60004604:	303e      	adds	r0, #62	; 0x3e
60004606:	f006 f88a 	bl	6000a71e <z_shell_strlen>
6000460a:	f8ad 0006 	strh.w	r0, [sp, #6]
	}

	z_shell_op_cursor_home_move(shell);
6000460e:	4620      	mov	r0, r4
60004610:	f006 fc20 	bl	6000ae54 <z_shell_op_cursor_home_move>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
60004614:	4a0a      	ldr	r2, [pc, #40]	; (60004640 <history_handle+0x98>)
60004616:	490b      	ldr	r1, [pc, #44]	; (60004644 <history_handle+0x9c>)
60004618:	6960      	ldr	r0, [r4, #20]
6000461a:	f006 f886 	bl	6000a72a <z_shell_raw_fprintf>
	z_clear_eos(shell);
	z_shell_print_cmd(shell);
6000461e:	4620      	mov	r0, r4
60004620:	f000 fe5a 	bl	600052d8 <z_shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
60004624:	68a3      	ldr	r3, [r4, #8]
60004626:	f8bd 2006 	ldrh.w	r2, [sp, #6]
	shell->ctx->cmd_buff_len = len;
	z_shell_op_cond_next_line(shell);
6000462a:	4620      	mov	r0, r4
	shell->ctx->cmd_buff_pos = len;
6000462c:	875a      	strh	r2, [r3, #58]	; 0x3a
	shell->ctx->cmd_buff_len = len;
6000462e:	871a      	strh	r2, [r3, #56]	; 0x38
	z_shell_op_cond_next_line(shell);
60004630:	f006 fb7e 	bl	6000ad30 <z_shell_op_cond_next_line>
}
60004634:	b003      	add	sp, #12
60004636:	bd30      	pop	{r4, r5, pc}
				shell->ctx->temp_buff[0] = '\0';
60004638:	f883 013e 	strb.w	r0, [r3, #318]	; 0x13e
6000463c:	e7d2      	b.n	600045e4 <history_handle+0x3c>
6000463e:	bf00      	nop
60004640:	6000e134 	.word	0x6000e134
60004644:	6000ddaf 	.word	0x6000ddaf

60004648 <state_set.constprop.0>:
	shell->ctx->state = state;
60004648:	6883      	ldr	r3, [r0, #8]
6000464a:	2202      	movs	r2, #2
static inline void state_set(const struct shell *shell, enum shell_state state)
6000464c:	b510      	push	{r4, lr}
	shell->ctx->state = state;
6000464e:	711a      	strb	r2, [r3, #4]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
60004650:	2200      	movs	r2, #0
static inline void state_set(const struct shell *shell, enum shell_state state)
60004652:	4604      	mov	r4, r0
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
60004654:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
	shell->ctx->cmd_buff_len = 0;
60004658:	639a      	str	r2, [r3, #56]	; 0x38
	shell->ctx->internal.flags.last_nl = val;
}

static inline bool z_flag_print_noinit_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.print_noinit == 1;
6000465a:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
		if (z_flag_print_noinit_get(shell)) {
6000465e:	039b      	lsls	r3, r3, #14
60004660:	d50b      	bpl.n	6000467a <state_set.constprop.0+0x32>
			z_shell_fprintf(shell, SHELL_WARNING, "%s",
60004662:	2104      	movs	r1, #4
60004664:	4b07      	ldr	r3, [pc, #28]	; (60004684 <state_set.constprop.0+0x3c>)
60004666:	4a08      	ldr	r2, [pc, #32]	; (60004688 <state_set.constprop.0+0x40>)
60004668:	f006 fca1 	bl	6000afae <z_shell_fprintf>

static inline bool z_flag_print_noinit_set(const struct shell *shell, bool val)
{
	bool ret;

	Z_SHELL_SET_FLAG_ATOMIC(shell, print_noinit, val, ret);
6000466c:	68a0      	ldr	r0, [r4, #8]
6000466e:	f46f 3100 	mvn.w	r1, #131072	; 0x20000
60004672:	f500 7017 	add.w	r0, r0, #604	; 0x25c
60004676:	f006 f82e 	bl	6000a6d6 <atomic_and>
		z_shell_print_prompt_and_cmd(shell);
6000467a:	4620      	mov	r0, r4
}
6000467c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_print_prompt_and_cmd(shell);
60004680:	f000 bf5a 	b.w	60005538 <z_shell_print_prompt_and_cmd>
60004684:	6000de65 	.word	0x6000de65
60004688:	6000ddaf 	.word	0x6000ddaf

6000468c <execute>:
 * the command handler without any preprocessing.
 * Because of that feature, command buffer is processed argument by argument and
 * decision on further processing is based on currently processed command.
 */
static int execute(const struct shell *shell)
{
6000468c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct shell_static_entry dloc; /* Memory for dynamic commands. */
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1]; /* +1 reserved for NULL */
	const struct shell_static_entry *parent = selected_cmd_get(shell);
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry help_entry;
	size_t cmd_lvl = 0;
60004690:	2300      	movs	r3, #0
{
60004692:	b09f      	sub	sp, #124	; 0x7c
60004694:	4604      	mov	r4, r0
	size_t cmd_with_handler_lvl = 0;
	bool wildcard_found = false;
	size_t argc = 0, args_left = SIZE_MAX;
60004696:	e9cd 3305 	strd	r3, r3, [sp, #20]
	char quote;
	const char **argvp;
	char *cmd_buf = shell->ctx->cmd_buff;
6000469a:	6883      	ldr	r3, [r0, #8]
6000469c:	333e      	adds	r3, #62	; 0x3e
6000469e:	9303      	str	r3, [sp, #12]
	bool has_last_handler = false;

	z_shell_op_cursor_end_move(shell);
600046a0:	f006 fbde 	bl	6000ae60 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(shell)) {
600046a4:	4620      	mov	r0, r4
600046a6:	f006 fb2f 	bl	6000ad08 <z_shell_cursor_in_empty_line>
600046aa:	b910      	cbnz	r0, 600046b2 <execute+0x26>
		z_cursor_next_line_move(shell);
600046ac:	6960      	ldr	r0, [r4, #20]
600046ae:	f7ff ff75 	bl	6000459c <z_cursor_next_line_move.isra.0>
	}

	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
600046b2:	68a0      	ldr	r0, [r4, #8]
600046b4:	2214      	movs	r2, #20
600046b6:	2100      	movs	r1, #0
		argvp = &argv[1];
		active_cmd_prepare(parent, &shell->ctx->active_cmd, &help_entry,
				   &cmd_lvl, &cmd_with_handler_lvl, &args_left);
		cmd_lvl++;
	} else {
		help_entry.help = NULL;
600046b8:	2600      	movs	r6, #0
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
600046ba:	3008      	adds	r0, #8
	size_t argc = 0, args_left = SIZE_MAX;
600046bc:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
600046c0:	f007 f972 	bl	6000b9a8 <memset>
		z_shell_cmd_trim(shell);
600046c4:	4620      	mov	r0, r4
600046c6:	f006 facc 	bl	6000ac62 <z_shell_cmd_trim>
		history_put(shell, shell->ctx->cmd_buff,
600046ca:	68a1      	ldr	r1, [r4, #8]
	z_shell_history_put(shell->history, line, length);
600046cc:	68e0      	ldr	r0, [r4, #12]
	size_t cmd_with_handler_lvl = 0;
600046ce:	46b1      	mov	r9, r6
	z_shell_history_put(shell->history, line, length);
600046d0:	8f0a      	ldrh	r2, [r1, #56]	; 0x38
		z_shell_wildcard_prepare(shell);
600046d2:	46b2      	mov	sl, r6
	z_shell_history_put(shell->history, line, length);
600046d4:	313e      	adds	r1, #62	; 0x3e
		z_shell_wildcard_prepare(shell);
600046d6:	af11      	add	r7, sp, #68	; 0x44
600046d8:	4635      	mov	r5, r6
600046da:	46b3      	mov	fp, r6
	z_shell_history_put(shell->history, line, length);
600046dc:	f006 fe72 	bl	6000b3c4 <z_shell_history_put>
		z_shell_wildcard_prepare(shell);
600046e0:	4620      	mov	r0, r4
600046e2:	f007 f825 	bl	6000b730 <z_shell_wildcard_prepare>
600046e6:	9602      	str	r6, [sp, #8]
		argvp = &argv[0];
	}

	/* Below loop is analyzing subcommands of found root command. */
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
600046e8:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
600046ec:	2a01      	cmp	r2, #1
600046ee:	f000 80d6 	beq.w	6000489e <execute+0x212>
600046f2:	2b0b      	cmp	r3, #11
600046f4:	f240 80ae 	bls.w	60004854 <execute+0x1c8>
			cmd_lvl++;
		}

	}

	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
600046f8:	9906      	ldr	r1, [sp, #24]
600046fa:	2902      	cmp	r1, #2
600046fc:	f040 80ae 	bne.w	6000485c <execute+0x1d0>
		/* argc == 2 indicates that when command string was parsed
		 * there was more characters remaining. It means that number of
		 * arguments exceeds the limit.
		 */
		z_shell_fprintf(shell, SHELL_ERROR, "%s\n",
60004700:	4b89      	ldr	r3, [pc, #548]	; (60004928 <execute+0x29c>)
60004702:	4a8a      	ldr	r2, [pc, #552]	; (6000492c <execute+0x2a0>)
60004704:	e015      	b.n	60004732 <execute+0xa6>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
60004706:	2302      	movs	r3, #2
60004708:	9a03      	ldr	r2, [sp, #12]
6000470a:	4639      	mov	r1, r7
6000470c:	a806      	add	r0, sp, #24
6000470e:	f006 f939 	bl	6000a984 <z_shell_make_argv>
		cmd_buf = (char *)argvp[1];
60004712:	687a      	ldr	r2, [r7, #4]
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
60004714:	4603      	mov	r3, r0
		cmd_buf = (char *)argvp[1];
60004716:	9203      	str	r2, [sp, #12]
		if (argc == 0) {
60004718:	9a06      	ldr	r2, [sp, #24]
6000471a:	b92a      	cbnz	r2, 60004728 <execute+0x9c>
			return -ENOEXEC;
6000471c:	f06f 0507 	mvn.w	r5, #7
	/* terminate arguments with NULL */
	argv[cmd_lvl] = NULL;
	/* Executing the deepest found handler. */
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
			&argv[cmd_with_handler_lvl], &help_entry);
}
60004720:	4628      	mov	r0, r5
60004722:	b01f      	add	sp, #124	; 0x7c
60004724:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ((argc == 1) && (quote != 0)) {
60004728:	2a01      	cmp	r2, #1
6000472a:	d106      	bne.n	6000473a <execute+0xae>
6000472c:	b128      	cbz	r0, 6000473a <execute+0xae>
			z_shell_fprintf(shell, SHELL_ERROR,
6000472e:	4a80      	ldr	r2, [pc, #512]	; (60004930 <execute+0x2a4>)
60004730:	2102      	movs	r1, #2
60004732:	4620      	mov	r0, r4
60004734:	f006 fc3b 	bl	6000afae <z_shell_fprintf>
60004738:	e7f0      	b.n	6000471c <execute+0x90>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
6000473a:	9b05      	ldr	r3, [sp, #20]
6000473c:	b34b      	cbz	r3, 60004792 <execute+0x106>
		    z_shell_help_request(argvp[0])) {
6000473e:	6838      	ldr	r0, [r7, #0]
60004740:	f001 f860 	bl	60005804 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
60004744:	b198      	cbz	r0, 6000476e <execute+0xe2>
			if (help_entry.help) {
60004746:	b166      	cbz	r6, 60004762 <execute+0xd6>
				shell->ctx->active_cmd = help_entry;
60004748:	68a5      	ldr	r5, [r4, #8]
6000474a:	960d      	str	r6, [sp, #52]	; 0x34
6000474c:	3508      	adds	r5, #8
				shell->ctx->active_cmd = *help_entry;
6000474e:	ae0c      	add	r6, sp, #48	; 0x30
60004750:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
60004752:	c50f      	stmia	r5!, {r0, r1, r2, r3}
60004754:	6833      	ldr	r3, [r6, #0]
60004756:	602b      	str	r3, [r5, #0]
			shell_internal_help_print(shell);
60004758:	4620      	mov	r0, r4
			return SHELL_CMD_HELP_PRINTED;
6000475a:	2501      	movs	r5, #1
			shell_internal_help_print(shell);
6000475c:	f7ff ff0e 	bl	6000457c <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
60004760:	e7de      	b.n	60004720 <execute+0x94>
			z_shell_fprintf(shell, SHELL_ERROR,
60004762:	4a74      	ldr	r2, [pc, #464]	; (60004934 <execute+0x2a8>)
		z_shell_fprintf(shell, SHELL_ERROR,
60004764:	2102      	movs	r1, #2
60004766:	4620      	mov	r0, r4
60004768:	f006 fc21 	bl	6000afae <z_shell_fprintf>
		return false;
6000476c:	e7d6      	b.n	6000471c <execute+0x90>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
6000476e:	9b05      	ldr	r3, [sp, #20]
60004770:	b17b      	cbz	r3, 60004792 <execute+0x106>
			status = z_shell_wildcard_process(shell, entry,
60004772:	683a      	ldr	r2, [r7, #0]
60004774:	4629      	mov	r1, r5
60004776:	4620      	mov	r0, r4
60004778:	f001 f99c 	bl	60005ab4 <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
6000477c:	2802      	cmp	r0, #2
6000477e:	f000 808e 	beq.w	6000489e <execute+0x212>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
60004782:	2803      	cmp	r0, #3
60004784:	d005      	beq.n	60004792 <execute+0x106>
				++cmd_lvl;
60004786:	9b05      	ldr	r3, [sp, #20]
60004788:	3301      	adds	r3, #1
6000478a:	9305      	str	r3, [sp, #20]
				wildcard_found = true;
6000478c:	2301      	movs	r3, #1
6000478e:	9302      	str	r3, [sp, #8]
				continue;
60004790:	e7aa      	b.n	600046e8 <execute+0x5c>
		if (has_last_handler == false) {
60004792:	f1ba 0f00 	cmp.w	sl, #0
60004796:	d105      	bne.n	600047a4 <execute+0x118>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
60004798:	aa07      	add	r2, sp, #28
6000479a:	6839      	ldr	r1, [r7, #0]
6000479c:	4658      	mov	r0, fp
6000479e:	f006 f9dc 	bl	6000ab5a <z_shell_find_cmd>
600047a2:	4605      	mov	r5, r0
		argvp++;
600047a4:	3704      	adds	r7, #4
		args_left--;
600047a6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		if (entry) {
600047aa:	2d00      	cmp	r5, #0
600047ac:	d040      	beq.n	60004830 <execute+0x1a4>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
600047ae:	9a02      	ldr	r2, [sp, #8]
600047b0:	68eb      	ldr	r3, [r5, #12]
600047b2:	b142      	cbz	r2, 600047c6 <execute+0x13a>
600047b4:	b313      	cbz	r3, 600047fc <execute+0x170>
		z_shell_op_cursor_end_move(shell);
600047b6:	4620      	mov	r0, r4
600047b8:	f006 fb52 	bl	6000ae60 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(shell);
600047bc:	4620      	mov	r0, r4
600047be:	f006 fab7 	bl	6000ad30 <z_shell_op_cond_next_line>
		z_shell_fprintf(shell, SHELL_ERROR,
600047c2:	4a5d      	ldr	r2, [pc, #372]	; (60004938 <execute+0x2ac>)
600047c4:	e7ce      	b.n	60004764 <execute+0xd8>
	if (entry->handler) {
600047c6:	b1cb      	cbz	r3, 600047fc <execute+0x170>
		*active_cmd = *entry;
600047c8:	68a3      	ldr	r3, [r4, #8]
600047ca:	46ae      	mov	lr, r5
		*handler_lvl = *lvl;
600047cc:	f8dd 9014 	ldr.w	r9, [sp, #20]
		*active_cmd = *entry;
600047d0:	f103 0c08 	add.w	ip, r3, #8
600047d4:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
600047d8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
600047dc:	f8de 3000 	ldr.w	r3, [lr]
600047e0:	f8cc 3000 	str.w	r3, [ip]
		if ((entry->subcmd == NULL)
600047e4:	68ab      	ldr	r3, [r5, #8]
600047e6:	b94b      	cbnz	r3, 600047fc <execute+0x170>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
600047e8:	7c6b      	ldrb	r3, [r5, #17]
600047ea:	2bfe      	cmp	r3, #254	; 0xfe
			*args_left = entry->args.mandatory - 1;
600047ec:	bf01      	itttt	eq
600047ee:	f895 8010 	ldrbeq.w	r8, [r5, #16]
			*lvl = *lvl + 1;
600047f2:	f109 0301 	addeq.w	r3, r9, #1
			*args_left = entry->args.mandatory - 1;
600047f6:	f108 38ff 	addeq.w	r8, r8, #4294967295	; 0xffffffff
			*lvl = *lvl + 1;
600047fa:	9305      	streq	r3, [sp, #20]
	if (entry->help) {
600047fc:	f8d5 c004 	ldr.w	ip, [r5, #4]
60004800:	f1bc 0f00 	cmp.w	ip, #0
60004804:	d008      	beq.n	60004818 <execute+0x18c>
		*help_entry = *entry;
60004806:	46ae      	mov	lr, r5
60004808:	ae0c      	add	r6, sp, #48	; 0x30
6000480a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
6000480e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
60004810:	f8de 3000 	ldr.w	r3, [lr]
60004814:	6033      	str	r3, [r6, #0]
60004816:	4666      	mov	r6, ip
60004818:	46ab      	mov	fp, r5
		if (args_left || (argc == 2)) {
6000481a:	f1b8 0f00 	cmp.w	r8, #0
6000481e:	d103      	bne.n	60004828 <execute+0x19c>
60004820:	9b06      	ldr	r3, [sp, #24]
60004822:	2b02      	cmp	r3, #2
60004824:	f47f af60 	bne.w	600046e8 <execute+0x5c>
			cmd_lvl++;
60004828:	9b05      	ldr	r3, [sp, #20]
6000482a:	3301      	adds	r3, #1
6000482c:	9305      	str	r3, [sp, #20]
6000482e:	e75b      	b.n	600046e8 <execute+0x5c>
			if (cmd_lvl == 0 &&
60004830:	9b05      	ldr	r3, [sp, #20]
60004832:	b963      	cbnz	r3, 6000484e <execute+0x1c2>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
60004834:	68a3      	ldr	r3, [r4, #8]
60004836:	69db      	ldr	r3, [r3, #28]
60004838:	b10b      	cbz	r3, 6000483e <execute+0x1b2>
				(!z_shell_in_select_mode(shell) ||
6000483a:	68db      	ldr	r3, [r3, #12]
6000483c:	b93b      	cbnz	r3, 6000484e <execute+0x1c2>
				z_shell_fprintf(shell, SHELL_ERROR,
6000483e:	4b3f      	ldr	r3, [pc, #252]	; (6000493c <execute+0x2b0>)
60004840:	2102      	movs	r1, #2
60004842:	4a3f      	ldr	r2, [pc, #252]	; (60004940 <execute+0x2b4>)
60004844:	4620      	mov	r0, r4
60004846:	9300      	str	r3, [sp, #0]
60004848:	9b11      	ldr	r3, [sp, #68]	; 0x44
6000484a:	f006 fbb0 	bl	6000afae <z_shell_fprintf>
			has_last_handler = true;
6000484e:	f04f 0a01 	mov.w	sl, #1
60004852:	e7e2      	b.n	6000481a <execute+0x18e>
		&& args_left > 0) {
60004854:	f1b8 0f00 	cmp.w	r8, #0
60004858:	f47f af55 	bne.w	60004706 <execute+0x7a>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
6000485c:	9b02      	ldr	r3, [sp, #8]
6000485e:	b14b      	cbz	r3, 60004874 <execute+0x1e8>
		z_shell_wildcard_finalize(shell);
60004860:	4620      	mov	r0, r4
60004862:	f006 ff89 	bl	6000b778 <z_shell_wildcard_finalize>
					shell->ctx->cmd_buff,
60004866:	68a2      	ldr	r2, [r4, #8]
		(void)z_shell_make_argv(&cmd_lvl,
60004868:	230c      	movs	r3, #12
6000486a:	a911      	add	r1, sp, #68	; 0x44
6000486c:	323e      	adds	r2, #62	; 0x3e
6000486e:	a805      	add	r0, sp, #20
60004870:	f006 f888 	bl	6000a984 <z_shell_make_argv>
	argv[cmd_lvl] = NULL;
60004874:	9d05      	ldr	r5, [sp, #20]
60004876:	ab1e      	add	r3, sp, #120	; 0x78
60004878:	2200      	movs	r2, #0
	if (shell->ctx->active_cmd.handler == NULL) {
6000487a:	68a0      	ldr	r0, [r4, #8]
	argv[cmd_lvl] = NULL;
6000487c:	eb03 0385 	add.w	r3, r3, r5, lsl #2
60004880:	f843 2c34 	str.w	r2, [r3, #-52]
	if (shell->ctx->active_cmd.handler == NULL) {
60004884:	6943      	ldr	r3, [r0, #20]
60004886:	b973      	cbnz	r3, 600048a6 <execute+0x21a>
			if (help_entry->help == NULL) {
60004888:	2e00      	cmp	r6, #0
6000488a:	f43f af47 	beq.w	6000471c <execute+0x90>
			if (help_entry->help != shell->ctx->active_cmd.help) {
6000488e:	68c3      	ldr	r3, [r0, #12]
60004890:	42b3      	cmp	r3, r6
60004892:	f43f af61 	beq.w	60004758 <execute+0xcc>
				shell->ctx->active_cmd = *help_entry;
60004896:	f100 0508 	add.w	r5, r0, #8
6000489a:	960d      	str	r6, [sp, #52]	; 0x34
6000489c:	e757      	b.n	6000474e <execute+0xc2>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
6000489e:	9b05      	ldr	r3, [sp, #20]
600048a0:	2b0b      	cmp	r3, #11
600048a2:	d9db      	bls.n	6000485c <execute+0x1d0>
600048a4:	e728      	b.n	600046f8 <execute+0x6c>
	if (shell->ctx->active_cmd.args.mandatory) {
600048a6:	7e03      	ldrb	r3, [r0, #24]
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
600048a8:	eba5 0509 	sub.w	r5, r5, r9
	if (shell->ctx->active_cmd.args.mandatory) {
600048ac:	b1b3      	cbz	r3, 600048dc <execute+0x250>
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
600048ae:	7e41      	ldrb	r1, [r0, #25]
				UINT16_MAX : opt8;
600048b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
600048b4:	29ff      	cmp	r1, #255	; 0xff
600048b6:	bf18      	it	ne
600048b8:	460a      	movne	r2, r1
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
600048ba:	429d      	cmp	r5, r3
600048bc:	d302      	bcc.n	600048c4 <execute+0x238>
600048be:	4413      	add	r3, r2
	if (!arg_cnt_ok) {
600048c0:	429d      	cmp	r5, r3
600048c2:	d90b      	bls.n	600048dc <execute+0x250>
		z_shell_fprintf(shell, SHELL_ERROR,
600048c4:	6883      	ldr	r3, [r0, #8]
600048c6:	2102      	movs	r1, #2
600048c8:	4a1e      	ldr	r2, [pc, #120]	; (60004944 <execute+0x2b8>)
600048ca:	4620      	mov	r0, r4
600048cc:	f006 fb6f 	bl	6000afae <z_shell_fprintf>
			shell_internal_help_print(shell);
600048d0:	4620      	mov	r0, r4
		return -EINVAL;
600048d2:	f06f 0515 	mvn.w	r5, #21
			shell_internal_help_print(shell);
600048d6:	f7ff fe51 	bl	6000457c <shell_internal_help_print>
	if (!ret_val) {
600048da:	e721      	b.n	60004720 <execute+0x94>
	Z_SHELL_SET_FLAG_ATOMIC(shell, cmd_ctx, val, ret);
600048dc:	f44f 3180 	mov.w	r1, #65536	; 0x10000
600048e0:	f500 7017 	add.w	r0, r0, #604	; 0x25c
600048e4:	f005 fee8 	bl	6000a6b8 <atomic_or>
		k_mutex_unlock(&shell->ctx->wr_mtx);
600048e8:	68a0      	ldr	r0, [r4, #8]
600048ea:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
600048ee:	f005 ff76 	bl	6000a7de <k_mutex_unlock.isra.0>
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
600048f2:	68a3      	ldr	r3, [r4, #8]
600048f4:	aa11      	add	r2, sp, #68	; 0x44
600048f6:	4629      	mov	r1, r5
600048f8:	695b      	ldr	r3, [r3, #20]
600048fa:	4620      	mov	r0, r4
600048fc:	eb02 0289 	add.w	r2, r2, r9, lsl #2
60004900:	4798      	blx	r3
60004902:	4605      	mov	r5, r0
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
60004904:	68a0      	ldr	r0, [r4, #8]
60004906:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
6000490a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
6000490e:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
60004912:	f005 ff17 	bl	6000a744 <k_mutex_lock.constprop.0.isra.0>
60004916:	68a0      	ldr	r0, [r4, #8]
60004918:	f46f 3180 	mvn.w	r1, #65536	; 0x10000
6000491c:	f500 7017 	add.w	r0, r0, #604	; 0x25c
60004920:	f005 fed9 	bl	6000a6d6 <atomic_and>
	return ret;
60004924:	e6fc      	b.n	60004720 <execute+0x94>
60004926:	bf00      	nop
60004928:	6000df1e 	.word	0x6000df1e
6000492c:	6000ddbb 	.word	0x6000ddbb
60004930:	6000dea9 	.word	0x6000dea9
60004934:	6000debd 	.word	0x6000debd
60004938:	6000dedb 	.word	0x6000dedb
6000493c:	6000df0a 	.word	0x6000df0a
60004940:	6000e1da 	.word	0x6000e1da
60004944:	6000df42 	.word	0x6000df42

60004948 <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
60004948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
6000494c:	4604      	mov	r4, r0
	Z_SHELL_SET_FLAG_ATOMIC(shell, processing, val, ret);
6000494e:	6880      	ldr	r0, [r0, #8]
60004950:	b0ab      	sub	sp, #172	; 0xac
60004952:	2110      	movs	r1, #16
60004954:	f500 7017 	add.w	r0, r0, #604	; 0x25c
60004958:	f005 feae 	bl	6000a6b8 <atomic_or>
	__ASSERT_NO_MSG(shell->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(shell, true);

	switch (shell->ctx->state) {
6000495c:	68a3      	ldr	r3, [r4, #8]
6000495e:	791b      	ldrb	r3, [r3, #4]
60004960:	2b02      	cmp	r3, #2
60004962:	f040 8308 	bne.w	60004f76 <shell_process+0x62e>
	size_t count = 0;
60004966:	2300      	movs	r3, #0
60004968:	930b      	str	r3, [sp, #44]	; 0x2c
		(void)shell->iface->api->read(shell->iface, &data,
6000496a:	6860      	ldr	r0, [r4, #4]
6000496c:	2201      	movs	r2, #1
6000496e:	f10d 012b 	add.w	r1, sp, #43	; 0x2b
60004972:	6803      	ldr	r3, [r0, #0]
60004974:	691d      	ldr	r5, [r3, #16]
60004976:	ab0b      	add	r3, sp, #44	; 0x2c
60004978:	47a8      	blx	r5
		if (count == 0) {
6000497a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
6000497c:	2b00      	cmp	r3, #0
6000497e:	f000 82fa 	beq.w	60004f76 <shell_process+0x62e>
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
60004982:	f99d 202b 	ldrsb.w	r2, [sp, #43]	; 0x2b
		if (ascii_filter(data) != 0) {
60004986:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
6000498a:	2a00      	cmp	r2, #0
6000498c:	dbed      	blt.n	6000496a <shell_process+0x22>
		switch (shell->ctx->receive_state) {
6000498e:	68a0      	ldr	r0, [r4, #8]
60004990:	7941      	ldrb	r1, [r0, #5]
60004992:	2901      	cmp	r1, #1
60004994:	f000 8267 	beq.w	60004e66 <shell_process+0x51e>
60004998:	2902      	cmp	r1, #2
6000499a:	f000 8287 	beq.w	60004eac <shell_process+0x564>
6000499e:	2900      	cmp	r1, #0
600049a0:	f040 82e7 	bne.w	60004f72 <shell_process+0x62a>
	if ((data != '\r') && (data != '\n')) {
600049a4:	2b0d      	cmp	r3, #13
	shell->ctx->internal.flags.last_nl = val;
600049a6:	f8d0 225c 	ldr.w	r2, [r0, #604]	; 0x25c
600049aa:	d018      	beq.n	600049de <shell_process+0x96>
600049ac:	2b0a      	cmp	r3, #10
600049ae:	d016      	beq.n	600049de <shell_process+0x96>
600049b0:	f361 220f 	bfi	r2, r1, #8, #8
600049b4:	f8c0 225c 	str.w	r2, [r0, #604]	; 0x25c
			switch (data) {
600049b8:	2b09      	cmp	r3, #9
600049ba:	d049      	beq.n	60004a50 <shell_process+0x108>
600049bc:	d830      	bhi.n	60004a20 <shell_process+0xd8>
600049be:	2b00      	cmp	r3, #0
600049c0:	d0d3      	beq.n	6000496a <shell_process+0x22>
600049c2:	2b08      	cmp	r3, #8
600049c4:	f000 81bf 	beq.w	60004d46 <shell_process+0x3fe>
600049c8:	f1a3 0220 	sub.w	r2, r3, #32
				if (isprint((int) data)) {
600049cc:	2a5e      	cmp	r2, #94	; 0x5e
600049ce:	f200 81c6 	bhi.w	60004d5e <shell_process+0x416>
					z_flag_history_exit_set(shell, true);
600049d2:	2101      	movs	r1, #1
600049d4:	f005 feea 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(shell, data);
600049d8:	f89d 102b 	ldrb.w	r1, [sp, #43]	; 0x2b
600049dc:	e0e3      	b.n	60004ba6 <shell_process+0x25e>
	if ((z_flag_last_nl_get(shell) == 0U) ||
600049de:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
600049e2:	d005      	beq.n	600049f0 <shell_process+0xa8>
	return shell->ctx->internal.flags.last_nl;
600049e4:	f8d0 225c 	ldr.w	r2, [r0, #604]	; 0x25c
600049e8:	f3c2 2207 	ubfx	r2, r2, #8, #8
600049ec:	4293      	cmp	r3, r2
600049ee:	d1e3      	bne.n	600049b8 <shell_process+0x70>
	shell->ctx->internal.flags.last_nl = val;
600049f0:	f8d0 225c 	ldr.w	r2, [r0, #604]	; 0x25c
				if (!shell->ctx->cmd_buff_len) {
600049f4:	8f01      	ldrh	r1, [r0, #56]	; 0x38
600049f6:	f363 220f 	bfi	r2, r3, #8, #8
600049fa:	f8c0 225c 	str.w	r2, [r0, #604]	; 0x25c
600049fe:	b959      	cbnz	r1, 60004a18 <shell_process+0xd0>
	z_flag_history_exit_set(shell, false);
60004a00:	f005 fed4 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(shell->history);
60004a04:	68e0      	ldr	r0, [r4, #12]
60004a06:	f006 fca3 	bl	6000b350 <z_shell_history_mode_exit>
					z_cursor_next_line_move(shell);
60004a0a:	6960      	ldr	r0, [r4, #20]
60004a0c:	f7ff fdc6 	bl	6000459c <z_cursor_next_line_move.isra.0>
		state_set(shell, SHELL_STATE_ACTIVE);
60004a10:	4620      	mov	r0, r4
60004a12:	f7ff fe19 	bl	60004648 <state_set.constprop.0>
		break;
60004a16:	e7a8      	b.n	6000496a <shell_process+0x22>
					(void)execute(shell);
60004a18:	4620      	mov	r0, r4
60004a1a:	f7ff fe37 	bl	6000468c <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
60004a1e:	e7f7      	b.n	60004a10 <shell_process+0xc8>
60004a20:	2b1b      	cmp	r3, #27
60004a22:	d012      	beq.n	60004a4a <shell_process+0x102>
60004a24:	2b7f      	cmp	r3, #127	; 0x7f
60004a26:	d1cf      	bne.n	600049c8 <shell_process+0x80>
	return shell->ctx->internal.flags.echo == 1;
60004a28:	f8d0 325c 	ldr.w	r3, [r0, #604]	; 0x25c
				if (z_flag_echo_get(shell)) {
60004a2c:	075f      	lsls	r7, r3, #29
60004a2e:	d59c      	bpl.n	6000496a <shell_process+0x22>
					z_flag_history_exit_set(shell, true);
60004a30:	2101      	movs	r1, #1
60004a32:	f005 febb 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
	return shell->ctx->internal.flags.mode_delete == 1;
60004a36:	68a3      	ldr	r3, [r4, #8]
60004a38:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
					if (z_flag_mode_delete_get(shell)) {
60004a3c:	065e      	lsls	r6, r3, #25
60004a3e:	f100 818a 	bmi.w	60004d56 <shell_process+0x40e>
		z_shell_op_char_delete(shell);
60004a42:	4620      	mov	r0, r4
60004a44:	f006 faf3 	bl	6000b02e <z_shell_op_char_delete>
		break;
60004a48:	e78f      	b.n	6000496a <shell_process+0x22>
	shell->ctx->receive_state = state;
60004a4a:	2301      	movs	r3, #1
60004a4c:	7143      	strb	r3, [r0, #5]
}
60004a4e:	e78c      	b.n	6000496a <shell_process+0x22>
	return shell->ctx->internal.flags.echo == 1;
60004a50:	f8d0 325c 	ldr.w	r3, [r0, #604]	; 0x25c
				if (z_flag_echo_get(shell) &&
60004a54:	0759      	lsls	r1, r3, #29
60004a56:	d588      	bpl.n	6000496a <shell_process+0x22>
					z_flag_history_exit_set(shell, true);
60004a58:	2101      	movs	r1, #1
60004a5a:	f005 fea7 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
			shell->ctx->cmd_buff_len;
60004a5e:	68a0      	ldr	r0, [r4, #8]
	if (compl_space == 0U) {
60004a60:	8f03      	ldrh	r3, [r0, #56]	; 0x38
60004a62:	2bff      	cmp	r3, #255	; 0xff
60004a64:	d081      	beq.n	6000496a <shell_process+0x22>
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
60004a66:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
60004a68:	f100 013e 	add.w	r1, r0, #62	; 0x3e
60004a6c:	f500 709f 	add.w	r0, r0, #318	; 0x13e
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
60004a70:	2500      	movs	r5, #0
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
60004a72:	f006 ff6e 	bl	6000b952 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
60004a76:	68a2      	ldr	r2, [r4, #8]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
60004a78:	a91d      	add	r1, sp, #116	; 0x74
60004a7a:	a80d      	add	r0, sp, #52	; 0x34
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
60004a7c:	8f53      	ldrh	r3, [r2, #58]	; 0x3a
60004a7e:	4413      	add	r3, r2
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
60004a80:	f502 729f 	add.w	r2, r2, #318	; 0x13e
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
60004a84:	f883 513e 	strb.w	r5, [r3, #318]	; 0x13e
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
60004a88:	230c      	movs	r3, #12
60004a8a:	f005 ff7b 	bl	6000a984 <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
60004a8e:	990d      	ldr	r1, [sp, #52]	; 0x34
60004a90:	290c      	cmp	r1, #12
60004a92:	f63f af6a 	bhi.w	6000496a <shell_process+0x22>
	(*argv)[*argc] = NULL;
60004a96:	ab2a      	add	r3, sp, #168	; 0xa8
60004a98:	eb03 0381 	add.w	r3, r3, r1, lsl #2
60004a9c:	f843 5c34 	str.w	r5, [r3, #-52]
	int space = isspace((int)shell->ctx->cmd_buff[
60004aa0:	68a3      	ldr	r3, [r4, #8]
						shell->ctx->cmd_buff_pos - 1]);
60004aa2:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
	int space = isspace((int)shell->ctx->cmd_buff[
60004aa4:	4413      	add	r3, r2
60004aa6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
60004aaa:	2b20      	cmp	r3, #32
60004aac:	f000 826d 	beq.w	60004f8a <shell_process+0x642>
60004ab0:	3b09      	subs	r3, #9
60004ab2:	2b04      	cmp	r3, #4
60004ab4:	f240 8269 	bls.w	60004f8a <shell_process+0x642>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
60004ab8:	2901      	cmp	r1, #1
60004aba:	d84f      	bhi.n	60004b5c <shell_process+0x214>
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
60004abc:	2500      	movs	r5, #0
60004abe:	950c      	str	r5, [sp, #48]	; 0x30
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
60004ac0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
60004ac2:	aa2a      	add	r2, sp, #168	; 0xa8
	*cnt = 0;
60004ac4:	2600      	movs	r6, #0
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
60004ac6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	size_t first = 0;
60004aca:	46b0      	mov	r8, r6
	size_t idx = 0;
60004acc:	4637      	mov	r7, r6
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
60004ace:	f853 ac34 	ldr.w	sl, [r3, #-52]
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
60004ad2:	4650      	mov	r0, sl
60004ad4:	f005 fe23 	bl	6000a71e <z_shell_strlen>
60004ad8:	4681      	mov	r9, r0
	*longest = 0U;
60004ada:	9604      	str	r6, [sp, #16]
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
60004adc:	aa18      	add	r2, sp, #96	; 0x60
60004ade:	4639      	mov	r1, r7
60004ae0:	4628      	mov	r0, r5
60004ae2:	f000 fba5 	bl	60005230 <z_shell_cmd_get>
60004ae6:	4683      	mov	fp, r0
60004ae8:	2800      	cmp	r0, #0
60004aea:	d144      	bne.n	60004b76 <shell_process+0x22e>
	if (cnt == 1) {
60004aec:	2e01      	cmp	r6, #1
60004aee:	d163      	bne.n	60004bb8 <shell_process+0x270>
		autocomplete(shell, cmd, argv[arg_idx], first);
60004af0:	aa2a      	add	r2, sp, #168	; 0xa8
60004af2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
60004af4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	uint16_t arg_len = z_shell_strlen(arg);
60004af8:	f853 0c34 	ldr.w	r0, [r3, #-52]
60004afc:	f005 fe0f 	bl	6000a71e <z_shell_strlen>
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
60004b00:	68a2      	ldr	r2, [r4, #8]
	uint16_t arg_len = z_shell_strlen(arg);
60004b02:	4606      	mov	r6, r0
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
60004b04:	4641      	mov	r1, r8
60004b06:	3208      	adds	r2, #8
60004b08:	4628      	mov	r0, r5
60004b0a:	f000 fb91 	bl	60005230 <z_shell_cmd_get>
60004b0e:	4605      	mov	r5, r0
	cmd_len = z_shell_strlen(match->syntax);
60004b10:	6800      	ldr	r0, [r0, #0]
60004b12:	f005 fe04 	bl	6000a71e <z_shell_strlen>
	if (cmd_len != arg_len) {
60004b16:	4286      	cmp	r6, r0
60004b18:	d006      	beq.n	60004b28 <shell_process+0x1e0>
		z_shell_op_completion_insert(shell,
60004b1a:	1b82      	subs	r2, r0, r6
60004b1c:	6829      	ldr	r1, [r5, #0]
60004b1e:	4620      	mov	r0, r4
60004b20:	b292      	uxth	r2, r2
60004b22:	4431      	add	r1, r6
60004b24:	f006 fa81 	bl	6000b02a <z_shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
60004b28:	68a0      	ldr	r0, [r4, #8]
					shell->ctx->cmd_buff_pos])) {
60004b2a:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
	if (!isspace((int) shell->ctx->cmd_buff[
60004b2c:	4403      	add	r3, r0
60004b2e:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
60004b32:	2b20      	cmp	r3, #32
60004b34:	d03b      	beq.n	60004bae <shell_process+0x266>
60004b36:	3b09      	subs	r3, #9
60004b38:	2b04      	cmp	r3, #4
60004b3a:	d938      	bls.n	60004bae <shell_process+0x266>
	return shell->ctx->internal.flags.insert_mode == 1;
60004b3c:	f8d0 325c 	ldr.w	r3, [r0, #604]	; 0x25c
		if (z_flag_insert_mode_get(shell)) {
60004b40:	07da      	lsls	r2, r3, #31
60004b42:	d52f      	bpl.n	60004ba4 <shell_process+0x25c>
			z_flag_insert_mode_set(shell, false);
60004b44:	2100      	movs	r1, #0
60004b46:	f005 fe3b 	bl	6000a7c0 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(shell, ' ');
60004b4a:	2120      	movs	r1, #32
60004b4c:	4620      	mov	r0, r4
60004b4e:	f000 fcbf 	bl	600054d0 <z_shell_op_char_insert>
			z_flag_insert_mode_set(shell, true);
60004b52:	2101      	movs	r1, #1
60004b54:	68a0      	ldr	r0, [r4, #8]
				z_flag_insert_mode_set(shell, !status);
60004b56:	f005 fe33 	bl	6000a7c0 <z_flag_insert_mode_set.isra.0>
				break;
60004b5a:	e706      	b.n	6000496a <shell_process+0x22>
	search_argc = space ? *argc : *argc - 1;
60004b5c:	3901      	subs	r1, #1
	*cmd = z_shell_get_last_command(selected_cmd_get(shell), search_argc,
60004b5e:	2000      	movs	r0, #0
60004b60:	ab0e      	add	r3, sp, #56	; 0x38
60004b62:	aa1d      	add	r2, sp, #116	; 0x74
60004b64:	9300      	str	r3, [sp, #0]
60004b66:	ab0c      	add	r3, sp, #48	; 0x30
60004b68:	9001      	str	r0, [sp, #4]
60004b6a:	f006 f816 	bl	6000ab9a <z_shell_get_last_command>
	if ((*cmd == NULL) && (search_argc != 0)) {
60004b6e:	4605      	mov	r5, r0
60004b70:	2800      	cmp	r0, #0
60004b72:	d1a5      	bne.n	60004ac0 <shell_process+0x178>
60004b74:	e6f9      	b.n	6000496a <shell_process+0x22>
	return (strncmp(candidate, str, len) == 0) ? true : false;
60004b76:	464a      	mov	r2, r9
60004b78:	4651      	mov	r1, sl
60004b7a:	f8db 0000 	ldr.w	r0, [fp]
60004b7e:	f006 feae 	bl	6000b8de <strncmp>
		if (is_candidate) {
60004b82:	b968      	cbnz	r0, 60004ba0 <shell_process+0x258>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
60004b84:	f8db 0000 	ldr.w	r0, [fp]
60004b88:	f006 fe8d 	bl	6000b8a6 <strlen>
60004b8c:	9b04      	ldr	r3, [sp, #16]
60004b8e:	4283      	cmp	r3, r0
60004b90:	bf38      	it	cc
60004b92:	4603      	movcc	r3, r0
				*first_idx = idx;
60004b94:	2e00      	cmp	r6, #0
60004b96:	bf08      	it	eq
60004b98:	46b8      	moveq	r8, r7
			(*cnt)++;
60004b9a:	3601      	adds	r6, #1
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
60004b9c:	b29b      	uxth	r3, r3
60004b9e:	9304      	str	r3, [sp, #16]
		idx++;
60004ba0:	3701      	adds	r7, #1
60004ba2:	e79b      	b.n	60004adc <shell_process+0x194>
			z_shell_op_char_insert(shell, ' ');
60004ba4:	2120      	movs	r1, #32
					z_shell_op_char_insert(shell, data);
60004ba6:	4620      	mov	r0, r4
60004ba8:	f000 fc92 	bl	600054d0 <z_shell_op_char_insert>
60004bac:	e6dd      	b.n	6000496a <shell_process+0x22>
		z_shell_op_cursor_move(shell, 1);
60004bae:	2101      	movs	r1, #1
60004bb0:	4620      	mov	r0, r4
60004bb2:	f006 f8f0 	bl	6000ad96 <z_shell_op_cursor_move>
60004bb6:	e6d8      	b.n	6000496a <shell_process+0x22>
	} else if (cnt > 1) {
60004bb8:	f67f aed7 	bls.w	6000496a <shell_process+0x22>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
60004bbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
60004bbe:	aa2a      	add	r2, sp, #168	; 0xa8
60004bc0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
60004bc4:	f853 ac34 	ldr.w	sl, [r3, #-52]
	size_t str_len = z_shell_strlen(str);
60004bc8:	4650      	mov	r0, sl
60004bca:	f005 fda8 	bl	6000a71e <z_shell_strlen>
		shell->ctx->vt100_ctx.printed_cmd = 0;
60004bce:	68a3      	ldr	r3, [r4, #8]
	size_t str_len = z_shell_strlen(str);
60004bd0:	9006      	str	r0, [sp, #24]
		shell->ctx->vt100_ctx.printed_cmd = 0;
60004bd2:	f8a3 b030 	strh.w	fp, [r3, #48]	; 0x30
	longest_option += z_shell_strlen(tab);
60004bd6:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 60004e94 <shell_process+0x54c>
		shell->ctx->vt100_ctx.printed_cmd = 0;
60004bda:	9605      	str	r6, [sp, #20]
60004bdc:	f8cd 800c 	str.w	r8, [sp, #12]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
60004be0:	68a2      	ldr	r2, [r4, #8]
60004be2:	4628      	mov	r0, r5
60004be4:	9903      	ldr	r1, [sp, #12]
60004be6:	3208      	adds	r2, #8
60004be8:	f000 fb22 	bl	60005230 <z_shell_cmd_get>
		idx++;
60004bec:	9b03      	ldr	r3, [sp, #12]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
60004bee:	4607      	mov	r7, r0
		idx++;
60004bf0:	3301      	adds	r3, #1
60004bf2:	9303      	str	r3, [sp, #12]
		if (str && match->syntax &&
60004bf4:	f1ba 0f00 	cmp.w	sl, #0
60004bf8:	d152      	bne.n	60004ca0 <shell_process+0x358>
		tab_item_print(shell, match->syntax, longest);
60004bfa:	683f      	ldr	r7, [r7, #0]
	if (option == NULL) {
60004bfc:	2f00      	cmp	r7, #0
60004bfe:	d159      	bne.n	60004cb4 <shell_process+0x36c>
		shell->ctx->vt100_ctx.printed_cmd = 0;
60004c00:	68a2      	ldr	r2, [r4, #8]
60004c02:	8617      	strh	r7, [r2, #48]	; 0x30
	while (cnt) {
60004c04:	9b05      	ldr	r3, [sp, #20]
60004c06:	3b01      	subs	r3, #1
60004c08:	9305      	str	r3, [sp, #20]
60004c0a:	d1e9      	bne.n	60004be0 <shell_process+0x298>
	z_cursor_next_line_move(shell);
60004c0c:	6960      	ldr	r0, [r4, #20]
	size_t idx = first + 1;
60004c0e:	f108 0901 	add.w	r9, r8, #1
	z_cursor_next_line_move(shell);
60004c12:	f7ff fcc3 	bl	6000459c <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(shell);
60004c16:	4620      	mov	r0, r4
60004c18:	f000 fc8e 	bl	60005538 <z_shell_print_prompt_and_cmd>
		partial_autocomplete(shell, cmd, argv[arg_idx], first, cnt);
60004c1c:	aa2a      	add	r2, sp, #168	; 0xa8
60004c1e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
60004c20:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	uint16_t arg_len = z_shell_strlen(arg);
60004c24:	f853 0c34 	ldr.w	r0, [r3, #-52]
60004c28:	f005 fd79 	bl	6000a71e <z_shell_strlen>
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
60004c2c:	4641      	mov	r1, r8
60004c2e:	aa13      	add	r2, sp, #76	; 0x4c
	uint16_t arg_len = z_shell_strlen(arg);
60004c30:	4607      	mov	r7, r0
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
60004c32:	4628      	mov	r0, r5
60004c34:	f000 fafc 	bl	60005230 <z_shell_cmd_get>
60004c38:	4680      	mov	r8, r0
	strncpy(shell->ctx->temp_buff, match->syntax,
60004c3a:	68a0      	ldr	r0, [r4, #8]
60004c3c:	22ff      	movs	r2, #255	; 0xff
60004c3e:	f8d8 1000 	ldr.w	r1, [r8]
60004c42:	f500 709f 	add.w	r0, r0, #318	; 0x13e
60004c46:	f006 fe0f 	bl	6000b868 <strncpy>
	*str = match->syntax;
60004c4a:	f8d8 a000 	ldr.w	sl, [r8]
	uint16_t common = UINT16_MAX;
60004c4e:	f64f 78ff 	movw	r8, #65535	; 0xffff
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
60004c52:	aa18      	add	r2, sp, #96	; 0x60
60004c54:	4649      	mov	r1, r9
60004c56:	4628      	mov	r0, r5
60004c58:	f109 0b01 	add.w	fp, r9, #1
60004c5c:	f000 fae8 	bl	60005230 <z_shell_cmd_get>
		if (match2 == NULL) {
60004c60:	2800      	cmp	r0, #0
60004c62:	d063      	beq.n	60004d2c <shell_process+0x3e4>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
60004c64:	68a3      	ldr	r3, [r4, #8]
	size_t common = 0;
60004c66:	2200      	movs	r2, #0
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
60004c68:	6800      	ldr	r0, [r0, #0]
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
60004c6a:	f503 739f 	add.w	r3, r3, #318	; 0x13e
60004c6e:	f813 cb01 	ldrb.w	ip, [r3], #1
60004c72:	5c81      	ldrb	r1, [r0, r2]
60004c74:	4561      	cmp	r1, ip
60004c76:	d105      	bne.n	60004c84 <shell_process+0x33c>
60004c78:	b121      	cbz	r1, 60004c84 <shell_process+0x33c>
		common++;
60004c7a:	3201      	adds	r2, #1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
60004c7c:	f64f 71ff 	movw	r1, #65535	; 0xffff
60004c80:	428a      	cmp	r2, r1
60004c82:	d1f4      	bne.n	60004c6e <shell_process+0x326>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
60004c84:	b10f      	cbz	r7, 60004c8a <shell_process+0x342>
60004c86:	42ba      	cmp	r2, r7
60004c88:	db08      	blt.n	60004c9c <shell_process+0x354>
			common = (curr_common < common) ? curr_common : common;
60004c8a:	4542      	cmp	r2, r8
			--cnt;
60004c8c:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
			common = (curr_common < common) ? curr_common : common;
60004c90:	bfa8      	it	ge
60004c92:	4642      	movge	r2, r8
	while (cnt > 1) {
60004c94:	2e01      	cmp	r6, #1
			common = (curr_common < common) ? curr_common : common;
60004c96:	fa1f f882 	uxth.w	r8, r2
	while (cnt > 1) {
60004c9a:	d047      	beq.n	60004d2c <shell_process+0x3e4>
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
60004c9c:	46d9      	mov	r9, fp
60004c9e:	e7d8      	b.n	60004c52 <shell_process+0x30a>
		if (str && match->syntax &&
60004ca0:	6800      	ldr	r0, [r0, #0]
60004ca2:	2800      	cmp	r0, #0
60004ca4:	d0a9      	beq.n	60004bfa <shell_process+0x2b2>
	return (strncmp(candidate, str, len) == 0) ? true : false;
60004ca6:	9a06      	ldr	r2, [sp, #24]
60004ca8:	4651      	mov	r1, sl
60004caa:	f006 fe18 	bl	6000b8de <strncmp>
		if (str && match->syntax &&
60004cae:	2800      	cmp	r0, #0
60004cb0:	d0a3      	beq.n	60004bfa <shell_process+0x2b2>
60004cb2:	e795      	b.n	60004be0 <shell_process+0x298>
	longest_option += z_shell_strlen(tab);
60004cb4:	4658      	mov	r0, fp
60004cb6:	f005 fd32 	bl	6000a71e <z_shell_strlen>
60004cba:	9b04      	ldr	r3, [sp, #16]
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
60004cbc:	68a1      	ldr	r1, [r4, #8]
	longest_option += z_shell_strlen(tab);
60004cbe:	18c2      	adds	r2, r0, r3
			- z_shell_strlen(tab)) / longest_option;
60004cc0:	4658      	mov	r0, fp
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
60004cc2:	8d4b      	ldrh	r3, [r1, #42]	; 0x2a
	longest_option += z_shell_strlen(tab);
60004cc4:	b292      	uxth	r2, r2
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
60004cc6:	9308      	str	r3, [sp, #32]
	longest_option += z_shell_strlen(tab);
60004cc8:	9209      	str	r2, [sp, #36]	; 0x24
			- z_shell_strlen(tab)) / longest_option;
60004cca:	f005 fd28 	bl	6000a71e <z_shell_strlen>
60004cce:	9007      	str	r0, [sp, #28]
	diff = longest_option - z_shell_strlen(option);
60004cd0:	4638      	mov	r0, r7
60004cd2:	f005 fd24 	bl	6000a71e <z_shell_strlen>
60004cd6:	9a09      	ldr	r2, [sp, #36]	; 0x24
			- z_shell_strlen(tab)) / longest_option;
60004cd8:	e9dd 1307 	ldrd	r1, r3, [sp, #28]
	diff = longest_option - z_shell_strlen(option);
60004cdc:	eba2 0900 	sub.w	r9, r2, r0
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
60004ce0:	68a0      	ldr	r0, [r4, #8]
			- z_shell_strlen(tab)) / longest_option;
60004ce2:	1a59      	subs	r1, r3, r1
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
60004ce4:	f8b0 c030 	ldrh.w	ip, [r0, #48]	; 0x30
	diff = longest_option - z_shell_strlen(option);
60004ce8:	fa1f f989 	uxth.w	r9, r9
			- z_shell_strlen(tab)) / longest_option;
60004cec:	fb91 f2f2 	sdiv	r2, r1, r2
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
60004cf0:	b292      	uxth	r2, r2
60004cf2:	f10c 0e01 	add.w	lr, ip, #1
60004cf6:	fbbc f1f2 	udiv	r1, ip, r2
60004cfa:	fb02 c211 	mls	r2, r2, r1, ip
60004cfe:	f8a0 e030 	strh.w	lr, [r0, #48]	; 0x30
60004d02:	b292      	uxth	r2, r2
60004d04:	b95a      	cbnz	r2, 60004d1e <shell_process+0x3d6>
		z_shell_fprintf(shell, SHELL_OPTION, "\n%s%s", tab, option);
60004d06:	465b      	mov	r3, fp
60004d08:	4a63      	ldr	r2, [pc, #396]	; (60004e98 <shell_process+0x550>)
60004d0a:	2107      	movs	r1, #7
60004d0c:	4620      	mov	r0, r4
60004d0e:	9700      	str	r7, [sp, #0]
60004d10:	f006 f94d 	bl	6000afae <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(shell, diff);
60004d14:	4649      	mov	r1, r9
60004d16:	4620      	mov	r0, r4
60004d18:	f000 face 	bl	600052b8 <z_shell_op_cursor_horiz_move>
60004d1c:	e772      	b.n	60004c04 <shell_process+0x2bc>
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
60004d1e:	463b      	mov	r3, r7
60004d20:	4a5e      	ldr	r2, [pc, #376]	; (60004e9c <shell_process+0x554>)
60004d22:	2107      	movs	r1, #7
60004d24:	4620      	mov	r0, r4
60004d26:	f006 f942 	bl	6000afae <z_shell_fprintf>
60004d2a:	e7f3      	b.n	60004d14 <shell_process+0x3cc>
	if (common) {
60004d2c:	f1b8 0f00 	cmp.w	r8, #0
60004d30:	f43f ae1b 	beq.w	6000496a <shell_process+0x22>
		z_shell_op_completion_insert(shell, &completion[arg_len],
60004d34:	eba8 0207 	sub.w	r2, r8, r7
60004d38:	eb0a 0107 	add.w	r1, sl, r7
60004d3c:	4620      	mov	r0, r4
60004d3e:	b292      	uxth	r2, r2
60004d40:	f006 f973 	bl	6000b02a <z_shell_op_completion_insert>
60004d44:	e611      	b.n	6000496a <shell_process+0x22>
	return shell->ctx->internal.flags.echo == 1;
60004d46:	f8d0 325c 	ldr.w	r3, [r0, #604]	; 0x25c
				if (z_flag_echo_get(shell)) {
60004d4a:	075b      	lsls	r3, r3, #29
60004d4c:	f57f ae0d 	bpl.w	6000496a <shell_process+0x22>
					z_flag_history_exit_set(shell, true);
60004d50:	2101      	movs	r1, #1
60004d52:	f005 fd2b 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(shell);
60004d56:	4620      	mov	r0, r4
60004d58:	f006 f984 	bl	6000b064 <z_shell_op_char_backspace>
60004d5c:	e605      	b.n	6000496a <shell_process+0x22>
60004d5e:	f8d0 225c 	ldr.w	r2, [r0, #604]	; 0x25c
				} else if (z_flag_echo_get(shell)) {
60004d62:	0755      	lsls	r5, r2, #29
60004d64:	f57f ae01 	bpl.w	6000496a <shell_process+0x22>
	switch (data) {
60004d68:	3b01      	subs	r3, #1
60004d6a:	2b16      	cmp	r3, #22
60004d6c:	f63f adfd 	bhi.w	6000496a <shell_process+0x22>
60004d70:	a201      	add	r2, pc, #4	; (adr r2, 60004d78 <shell_process+0x430>)
60004d72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
60004d76:	bf00      	nop
60004d78:	60004f49 	.word	0x60004f49
60004d7c:	60004dd5 	.word	0x60004dd5
60004d80:	60004ddd 	.word	0x60004ddd
60004d84:	60004a43 	.word	0x60004a43
60004d88:	60004f3d 	.word	0x60004f3d
60004d8c:	60004dfb 	.word	0x60004dfb
60004d90:	6000496b 	.word	0x6000496b
60004d94:	6000496b 	.word	0x6000496b
60004d98:	6000496b 	.word	0x6000496b
60004d9c:	6000496b 	.word	0x6000496b
60004da0:	60004e03 	.word	0x60004e03
60004da4:	60004e0b 	.word	0x60004e0b
60004da8:	6000496b 	.word	0x6000496b
60004dac:	60004e27 	.word	0x60004e27
60004db0:	6000496b 	.word	0x6000496b
60004db4:	60004e31 	.word	0x60004e31
60004db8:	6000496b 	.word	0x6000496b
60004dbc:	6000496b 	.word	0x6000496b
60004dc0:	6000496b 	.word	0x6000496b
60004dc4:	6000496b 	.word	0x6000496b
60004dc8:	60004e35 	.word	0x60004e35
60004dcc:	6000496b 	.word	0x6000496b
60004dd0:	60004e57 	.word	0x60004e57
		z_shell_op_left_arrow(shell);
60004dd4:	4620      	mov	r0, r4
60004dd6:	f006 f84a 	bl	6000ae6e <z_shell_op_left_arrow>
		break;
60004dda:	e5c6      	b.n	6000496a <shell_process+0x22>
		z_shell_op_cursor_end_move(shell);
60004ddc:	4620      	mov	r0, r4
60004dde:	f006 f83f 	bl	6000ae60 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(shell)) {
60004de2:	4620      	mov	r0, r4
60004de4:	f005 ff90 	bl	6000ad08 <z_shell_cursor_in_empty_line>
60004de8:	b910      	cbnz	r0, 60004df0 <shell_process+0x4a8>
			z_cursor_next_line_move(shell);
60004dea:	6960      	ldr	r0, [r4, #20]
60004dec:	f7ff fbd6 	bl	6000459c <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(shell, true);
60004df0:	2101      	movs	r1, #1
60004df2:	68a0      	ldr	r0, [r4, #8]
60004df4:	f005 fcda 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
60004df8:	e60a      	b.n	60004a10 <shell_process+0xc8>
		z_shell_op_right_arrow(shell);
60004dfa:	4620      	mov	r0, r4
60004dfc:	f006 f83f 	bl	6000ae7e <z_shell_op_right_arrow>
		break;
60004e00:	e5b3      	b.n	6000496a <shell_process+0x22>
		z_shell_op_delete_from_cursor(shell);
60004e02:	4620      	mov	r0, r4
60004e04:	f006 f844 	bl	6000ae90 <z_shell_op_delete_from_cursor>
		break;
60004e08:	e5af      	b.n	6000496a <shell_process+0x22>
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
60004e0a:	6960      	ldr	r0, [r4, #20]
60004e0c:	4a24      	ldr	r2, [pc, #144]	; (60004ea0 <shell_process+0x558>)
60004e0e:	4923      	ldr	r1, [pc, #140]	; (60004e9c <shell_process+0x554>)
60004e10:	f005 fc8b 	bl	6000a72a <z_shell_raw_fprintf>
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
60004e14:	6960      	ldr	r0, [r4, #20]
60004e16:	4a23      	ldr	r2, [pc, #140]	; (60004ea4 <shell_process+0x55c>)
60004e18:	4920      	ldr	r1, [pc, #128]	; (60004e9c <shell_process+0x554>)
60004e1a:	f005 fc86 	bl	6000a72a <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(shell);
60004e1e:	4620      	mov	r0, r4
60004e20:	f000 fb8a 	bl	60005538 <z_shell_print_prompt_and_cmd>
		break;
60004e24:	e5a1      	b.n	6000496a <shell_process+0x22>
		history_handle(shell, false);
60004e26:	2100      	movs	r1, #0
		history_handle(shell, true);
60004e28:	4620      	mov	r0, r4
60004e2a:	f7ff fbbd 	bl	600045a8 <history_handle>
		break;
60004e2e:	e59c      	b.n	6000496a <shell_process+0x22>
		history_handle(shell, true);
60004e30:	2101      	movs	r1, #1
60004e32:	e7f9      	b.n	60004e28 <shell_process+0x4e0>
		z_shell_op_cursor_home_move(shell);
60004e34:	4620      	mov	r0, r4
60004e36:	f006 f80d 	bl	6000ae54 <z_shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
60004e3a:	68a0      	ldr	r0, [r4, #8]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
60004e3c:	2300      	movs	r3, #0
		z_flag_history_exit_set(shell, true);
60004e3e:	2101      	movs	r1, #1
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
60004e40:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
	shell->ctx->cmd_buff_len = 0;
60004e44:	6383      	str	r3, [r0, #56]	; 0x38
		z_flag_history_exit_set(shell, true);
60004e46:	f005 fcb1 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
60004e4a:	4a17      	ldr	r2, [pc, #92]	; (60004ea8 <shell_process+0x560>)
60004e4c:	4913      	ldr	r1, [pc, #76]	; (60004e9c <shell_process+0x554>)
60004e4e:	6960      	ldr	r0, [r4, #20]
60004e50:	f005 fc6b 	bl	6000a72a <z_shell_raw_fprintf>
}
60004e54:	e589      	b.n	6000496a <shell_process+0x22>
		z_shell_op_word_remove(shell);
60004e56:	4620      	mov	r0, r4
60004e58:	f000 faa8 	bl	600053ac <z_shell_op_word_remove>
		z_flag_history_exit_set(shell, true);
60004e5c:	2101      	movs	r1, #1
60004e5e:	68a0      	ldr	r0, [r4, #8]
60004e60:	f005 fca4 	bl	6000a7ac <z_flag_history_exit_set.isra.0>
		break;
60004e64:	e581      	b.n	6000496a <shell_process+0x22>
			if (data == '[') {
60004e66:	2b5b      	cmp	r3, #91	; 0x5b
60004e68:	d101      	bne.n	60004e6e <shell_process+0x526>
	shell->ctx->receive_state = state;
60004e6a:	2302      	movs	r3, #2
60004e6c:	e5ee      	b.n	60004a4c <shell_process+0x104>
	return shell->ctx->internal.flags.echo == 1;
60004e6e:	f8d0 225c 	ldr.w	r2, [r0, #604]	; 0x25c
			} else if (z_flag_echo_get(shell)) {
60004e72:	0750      	lsls	r0, r2, #29
60004e74:	d509      	bpl.n	60004e8a <shell_process+0x542>
	if (data == SHELL_VT100_ASCII_ALT_B) {
60004e76:	2b62      	cmp	r3, #98	; 0x62
60004e78:	d105      	bne.n	60004e86 <shell_process+0x53e>
		z_shell_op_cursor_word_move(shell, -1);
60004e7a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
		z_shell_op_cursor_word_move(shell, 1);
60004e7e:	4620      	mov	r0, r4
60004e80:	f005 ffad 	bl	6000adde <z_shell_op_cursor_word_move>
60004e84:	e001      	b.n	60004e8a <shell_process+0x542>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
60004e86:	2b66      	cmp	r3, #102	; 0x66
60004e88:	d0f9      	beq.n	60004e7e <shell_process+0x536>
	shell->ctx->receive_state = state;
60004e8a:	68a3      	ldr	r3, [r4, #8]
60004e8c:	2200      	movs	r2, #0
60004e8e:	715a      	strb	r2, [r3, #5]
}
60004e90:	e56b      	b.n	6000496a <shell_process+0x22>
60004e92:	bf00      	nop
60004e94:	6000d7cf 	.word	0x6000d7cf
60004e98:	6000df5d 	.word	0x6000df5d
60004e9c:	6000ddaf 	.word	0x6000ddaf
60004ea0:	6000e13d 	.word	0x6000e13d
60004ea4:	6000e138 	.word	0x6000e138
60004ea8:	6000e134 	.word	0x6000e134
	shell->ctx->receive_state = state;
60004eac:	2200      	movs	r2, #0
60004eae:	7142      	strb	r2, [r0, #5]
60004eb0:	f8d0 225c 	ldr.w	r2, [r0, #604]	; 0x25c
			if (!z_flag_echo_get(shell)) {
60004eb4:	0752      	lsls	r2, r2, #29
60004eb6:	f57f ad58 	bpl.w	6000496a <shell_process+0x22>
			switch (data) {
60004eba:	3b31      	subs	r3, #49	; 0x31
60004ebc:	2b1b      	cmp	r3, #27
60004ebe:	f63f ad54 	bhi.w	6000496a <shell_process+0x22>
60004ec2:	a201      	add	r2, pc, #4	; (adr r2, 60004ec8 <shell_process+0x580>)
60004ec4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
60004ec8:	60004f45 	.word	0x60004f45
60004ecc:	60004f51 	.word	0x60004f51
60004ed0:	60004f63 	.word	0x60004f63
60004ed4:	60004f39 	.word	0x60004f39
60004ed8:	6000496b 	.word	0x6000496b
60004edc:	6000496b 	.word	0x6000496b
60004ee0:	6000496b 	.word	0x6000496b
60004ee4:	6000496b 	.word	0x6000496b
60004ee8:	6000496b 	.word	0x6000496b
60004eec:	6000496b 	.word	0x6000496b
60004ef0:	6000496b 	.word	0x6000496b
60004ef4:	6000496b 	.word	0x6000496b
60004ef8:	6000496b 	.word	0x6000496b
60004efc:	6000496b 	.word	0x6000496b
60004f00:	6000496b 	.word	0x6000496b
60004f04:	6000496b 	.word	0x6000496b
60004f08:	60004e31 	.word	0x60004e31
60004f0c:	60004e27 	.word	0x60004e27
60004f10:	60004dfb 	.word	0x60004dfb
60004f14:	60004dd5 	.word	0x60004dd5
60004f18:	6000496b 	.word	0x6000496b
60004f1c:	60004f3d 	.word	0x60004f3d
60004f20:	6000496b 	.word	0x6000496b
60004f24:	60004f49 	.word	0x60004f49
60004f28:	6000496b 	.word	0x6000496b
60004f2c:	6000496b 	.word	0x6000496b
60004f30:	6000496b 	.word	0x6000496b
60004f34:	60004f55 	.word	0x60004f55
	shell->ctx->receive_state = state;
60004f38:	2303      	movs	r3, #3
60004f3a:	7143      	strb	r3, [r0, #5]
		z_shell_op_cursor_end_move(shell);
60004f3c:	4620      	mov	r0, r4
60004f3e:	f005 ff8f 	bl	6000ae60 <z_shell_op_cursor_end_move>
		break;
60004f42:	e512      	b.n	6000496a <shell_process+0x22>
	shell->ctx->receive_state = state;
60004f44:	2303      	movs	r3, #3
60004f46:	7143      	strb	r3, [r0, #5]
		z_shell_op_cursor_home_move(shell);
60004f48:	4620      	mov	r0, r4
60004f4a:	f005 ff83 	bl	6000ae54 <z_shell_op_cursor_home_move>
		break;
60004f4e:	e50c      	b.n	6000496a <shell_process+0x22>
	shell->ctx->receive_state = state;
60004f50:	2303      	movs	r3, #3
60004f52:	7143      	strb	r3, [r0, #5]
	return shell->ctx->internal.flags.insert_mode == 1;
60004f54:	f8d0 125c 	ldr.w	r1, [r0, #604]	; 0x25c
60004f58:	f001 0101 	and.w	r1, r1, #1
				z_flag_insert_mode_set(shell, !status);
60004f5c:	f081 0101 	eor.w	r1, r1, #1
60004f60:	e5f9      	b.n	60004b56 <shell_process+0x20e>
	shell->ctx->receive_state = state;
60004f62:	2303      	movs	r3, #3
60004f64:	7143      	strb	r3, [r0, #5]
	return shell->ctx->internal.flags.echo == 1;
60004f66:	f8d0 325c 	ldr.w	r3, [r0, #604]	; 0x25c
				if (z_flag_echo_get(shell)) {
60004f6a:	075b      	lsls	r3, r3, #29
60004f6c:	f57f acfd 	bpl.w	6000496a <shell_process+0x22>
60004f70:	e567      	b.n	60004a42 <shell_process+0xfa>
	shell->ctx->receive_state = state;
60004f72:	2300      	movs	r3, #0
60004f74:	e56a      	b.n	60004a4c <shell_process+0x104>
	Z_SHELL_SET_FLAG_ATOMIC(shell, processing, val, ret);
60004f76:	68a0      	ldr	r0, [r4, #8]
60004f78:	f06f 0110 	mvn.w	r1, #16
60004f7c:	f500 7017 	add.w	r0, r0, #604	; 0x25c
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(shell, false);
}
60004f80:	b02b      	add	sp, #172	; 0xac
60004f82:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60004f86:	f005 bba6 	b.w	6000a6d6 <atomic_and>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
60004f8a:	2900      	cmp	r1, #0
60004f8c:	f43f ad96 	beq.w	60004abc <shell_process+0x174>
60004f90:	e5e5      	b.n	60004b5e <shell_process+0x216>
60004f92:	bf00      	nop

60004f94 <shell_init>:
{
60004f94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60004f98:	4604      	mov	r4, r0
	if (shell->ctx->tid) {
60004f9a:	6880      	ldr	r0, [r0, #8]
{
60004f9c:	460f      	mov	r7, r1
60004f9e:	b088      	sub	sp, #32
	if (shell->ctx->tid) {
60004fa0:	f8d0 1304 	ldr.w	r1, [r0, #772]	; 0x304
{
60004fa4:	461e      	mov	r6, r3
	if (shell->ctx->tid) {
60004fa6:	2900      	cmp	r1, #0
60004fa8:	d175      	bne.n	60005096 <shell_init+0x102>
	memset(shell->ctx, 0, sizeof(*shell->ctx));
60004faa:	f44f 7242 	mov.w	r2, #776	; 0x308
60004fae:	f006 fcfb 	bl	6000b9a8 <memset>
	shell->ctx->prompt = shell->default_prompt;
60004fb2:	68a3      	ldr	r3, [r4, #8]
60004fb4:	6822      	ldr	r2, [r4, #0]
	z_shell_history_init(shell->history);
60004fb6:	68e0      	ldr	r0, [r4, #12]
	shell->ctx->prompt = shell->default_prompt;
60004fb8:	601a      	str	r2, [r3, #0]
	z_shell_history_init(shell->history);
60004fba:	f006 fa6f 	bl	6000b49c <z_shell_history_init>
	k_mutex_init(&shell->ctx->wr_mtx);
60004fbe:	68a0      	ldr	r0, [r4, #8]
60004fc0:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
	return z_impl_k_mutex_init(mutex);
60004fc4:	f44f 7828 	mov.w	r8, #672	; 0x2a0
60004fc8:	f44f 7518 	mov.w	r5, #608	; 0x260
60004fcc:	f007 f956 	bl	6000c27c <z_impl_k_mutex_init>
		k_poll_signal_init(&shell->ctx->signals[i]);
60004fd0:	68a0      	ldr	r0, [r4, #8]
60004fd2:	4428      	add	r0, r5
		arch_syscall_invoke1(*(uintptr_t *)&sig, K_SYSCALL_K_POLL_SIGNAL_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_init(sig);
60004fd4:	f007 fc4c 	bl	6000c870 <z_impl_k_poll_signal_init>
		k_poll_event_init(&shell->ctx->events[i],
60004fd8:	68a0      	ldr	r0, [r4, #8]
60004fda:	2200      	movs	r2, #0
60004fdc:	2101      	movs	r1, #1
60004fde:	1943      	adds	r3, r0, r5
	for (int i = 0; i < SHELL_SIGNALS; i++) {
60004fe0:	3510      	adds	r5, #16
		k_poll_event_init(&shell->ctx->events[i],
60004fe2:	4440      	add	r0, r8
	for (int i = 0; i < SHELL_SIGNALS; i++) {
60004fe4:	f108 0814 	add.w	r8, r8, #20
		k_poll_event_init(&shell->ctx->events[i],
60004fe8:	f007 fc25 	bl	6000c836 <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
60004fec:	f5b5 7f28 	cmp.w	r5, #672	; 0x2a0
60004ff0:	d1ee      	bne.n	60004fd0 <shell_init+0x3c>
		shell->stats->log_lost_cnt = 0;
60004ff2:	69a3      	ldr	r3, [r4, #24]
60004ff4:	2200      	movs	r2, #0
	Z_SHELL_SET_FLAG_ATOMIC(shell, tx_rdy, val, ret);
60004ff6:	68a0      	ldr	r0, [r4, #8]
60004ff8:	2120      	movs	r1, #32
60004ffa:	601a      	str	r2, [r3, #0]
60004ffc:	f500 7017 	add.w	r0, r0, #604	; 0x25c
60005000:	f005 fb5a 	bl	6000a6b8 <atomic_or>
	Z_SHELL_SET_FLAG_ATOMIC(shell, echo, val, ret);
60005004:	68a0      	ldr	r0, [r4, #8]
60005006:	2104      	movs	r1, #4
60005008:	f500 7017 	add.w	r0, r0, #604	; 0x25c
6000500c:	f005 fb54 	bl	6000a6b8 <atomic_or>
	Z_SHELL_SET_FLAG_ATOMIC(shell, obscure, val, ret);
60005010:	68a0      	ldr	r0, [r4, #8]
60005012:	f06f 0108 	mvn.w	r1, #8
60005016:	f500 7017 	add.w	r0, r0, #604	; 0x25c
6000501a:	f005 fb5c 	bl	6000a6d6 <atomic_and>
	Z_SHELL_SET_FLAG_ATOMIC(shell, mode_delete, val, ret);
6000501e:	68a0      	ldr	r0, [r4, #8]
60005020:	2140      	movs	r1, #64	; 0x40
60005022:	f500 7017 	add.w	r0, r0, #604	; 0x25c
60005026:	f005 fb47 	bl	6000a6b8 <atomic_or>
	shell->ctx->vt100_ctx.cons.terminal_wid =
6000502a:	68a3      	ldr	r3, [r4, #8]
	shell->ctx->vt100_ctx.cons.terminal_hei =
6000502c:	4a1b      	ldr	r2, [pc, #108]	; (6000509c <shell_init+0x108>)
	shell->ctx->vt100_ctx.cons.name_len = z_shell_strlen(shell->ctx->prompt);
6000502e:	6818      	ldr	r0, [r3, #0]
	shell->ctx->vt100_ctx.cons.terminal_hei =
60005030:	629a      	str	r2, [r3, #40]	; 0x28
	shell->ctx->vt100_ctx.cons.name_len = z_shell_strlen(shell->ctx->prompt);
60005032:	f005 fb74 	bl	6000a71e <z_shell_strlen>
60005036:	68a3      	ldr	r3, [r4, #8]
	Z_SHELL_SET_FLAG_ATOMIC(shell, use_colors, val, ret);
60005038:	2102      	movs	r1, #2
6000503a:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
6000503e:	f503 7017 	add.w	r0, r3, #604	; 0x25c
60005042:	f005 fb39 	bl	6000a6b8 <atomic_or>
	int ret = shell->iface->api->init(shell->iface, p_config,
60005046:	6860      	ldr	r0, [r4, #4]
60005048:	4a15      	ldr	r2, [pc, #84]	; (600050a0 <shell_init+0x10c>)
6000504a:	4639      	mov	r1, r7
6000504c:	6803      	ldr	r3, [r0, #0]
6000504e:	681d      	ldr	r5, [r3, #0]
60005050:	4623      	mov	r3, r4
60005052:	47a8      	blx	r5
	if (ret == 0) {
60005054:	4605      	mov	r5, r0
60005056:	b9d0      	cbnz	r0, 6000508e <shell_init+0xfa>
	shell->ctx->state = state;
60005058:	68a3      	ldr	r3, [r4, #8]
6000505a:	2201      	movs	r2, #1
6000505c:	711a      	strb	r2, [r3, #4]
	k_tid_t tid = k_thread_create(shell->thread,
6000505e:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
60005062:	2200      	movs	r2, #0
60005064:	2300      	movs	r3, #0
60005066:	9504      	str	r5, [sp, #16]
60005068:	9400      	str	r4, [sp, #0]
6000506a:	e9cd 2306 	strd	r2, r3, [sp, #24]
6000506e:	230e      	movs	r3, #14
60005070:	f44f 6200 	mov.w	r2, #2048	; 0x800
60005074:	9303      	str	r3, [sp, #12]
60005076:	9b0e      	ldr	r3, [sp, #56]	; 0x38
60005078:	e9cd 6301 	strd	r6, r3, [sp, #4]
6000507c:	4b09      	ldr	r3, [pc, #36]	; (600050a4 <shell_init+0x110>)
6000507e:	f003 f9af 	bl	600083e0 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
60005082:	68a3      	ldr	r3, [r4, #8]
	k_thread_name_set(tid, shell->thread_name);
60005084:	6a61      	ldr	r1, [r4, #36]	; 0x24
	shell->ctx->tid = tid;
60005086:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
	return z_impl_k_thread_name_set(thread, str);
6000508a:	f003 f8e5 	bl	60008258 <z_impl_k_thread_name_set>
}
6000508e:	4628      	mov	r0, r5
60005090:	b008      	add	sp, #32
60005092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EALREADY;
60005096:	f06f 0577 	mvn.w	r5, #119	; 0x77
6000509a:	e7f8      	b.n	6000508e <shell_init+0xfa>
6000509c:	00500018 	.word	0x00500018
600050a0:	6000a749 	.word	0x6000a749
600050a4:	600050f5 	.word	0x600050f5

600050a8 <shell_start>:
{
600050a8:	b510      	push	{r4, lr}
600050aa:	4604      	mov	r4, r0
	return shell->ctx->state;
600050ac:	6880      	ldr	r0, [r0, #8]
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
600050ae:	7903      	ldrb	r3, [r0, #4]
600050b0:	2b01      	cmp	r3, #1
600050b2:	d119      	bne.n	600050e8 <shell_start+0x40>
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
600050b4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
600050b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
600050bc:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
600050c0:	f005 fb40 	bl	6000a744 <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(shell, SHELL_NORMAL);
600050c4:	2100      	movs	r1, #0
600050c6:	4620      	mov	r0, r4
600050c8:	f000 f90e 	bl	600052e8 <z_shell_vt100_color_set>
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
600050cc:	4908      	ldr	r1, [pc, #32]	; (600050f0 <shell_start+0x48>)
600050ce:	6960      	ldr	r0, [r4, #20]
600050d0:	f005 fb2b 	bl	6000a72a <z_shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
600050d4:	4620      	mov	r0, r4
600050d6:	f7ff fab7 	bl	60004648 <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
600050da:	68a0      	ldr	r0, [r4, #8]
600050dc:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
600050e0:	f005 fb7d 	bl	6000a7de <k_mutex_unlock.isra.0>
	return 0;
600050e4:	2000      	movs	r0, #0
}
600050e6:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
600050e8:	f06f 0085 	mvn.w	r0, #133	; 0x85
600050ec:	e7fb      	b.n	600050e6 <shell_start+0x3e>
600050ee:	bf00      	nop
600050f0:	6000dc93 	.word	0x6000dc93

600050f4 <shell_thread>:
{
600050f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
600050f8:	4604      	mov	r4, r0
	err = shell->iface->api->enable(shell->iface, false);
600050fa:	6840      	ldr	r0, [r0, #4]
{
600050fc:	460e      	mov	r6, r1
	err = shell->iface->api->enable(shell->iface, false);
600050fe:	2100      	movs	r1, #0
60005100:	6803      	ldr	r3, [r0, #0]
{
60005102:	4615      	mov	r5, r2
	err = shell->iface->api->enable(shell->iface, false);
60005104:	689b      	ldr	r3, [r3, #8]
60005106:	4798      	blx	r3
	if (err != 0) {
60005108:	2800      	cmp	r0, #0
6000510a:	d14c      	bne.n	600051a6 <shell_thread+0xb2>
	if (IS_ENABLED(CONFIG_SHELL_LOG_BACKEND) && log_backend) {
6000510c:	b126      	cbz	r6, 60005118 <shell_thread+0x24>
		z_shell_log_backend_enable(shell->log_backend, (void *)shell,
6000510e:	462a      	mov	r2, r5
60005110:	4621      	mov	r1, r4
60005112:	69e0      	ldr	r0, [r4, #28]
60005114:	f006 fa6d 	bl	6000b5f2 <z_shell_log_backend_enable>
	err = shell_start(shell);
60005118:	4620      	mov	r0, r4
6000511a:	f7ff ffc5 	bl	600050a8 <shell_start>
	if (err != 0) {
6000511e:	2800      	cmp	r0, #0
60005120:	d141      	bne.n	600051a6 <shell_thread+0xb2>
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
60005122:	f8df 8088 	ldr.w	r8, [pc, #136]	; 600051ac <shell_thread+0xb8>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
60005126:	4f22      	ldr	r7, [pc, #136]	; (600051b0 <shell_thread+0xbc>)
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
60005128:	4e22      	ldr	r6, [pc, #136]	; (600051b4 <shell_thread+0xc0>)
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
6000512a:	68a0      	ldr	r0, [r4, #8]
6000512c:	f500 7028 	add.w	r0, r0, #672	; 0x2a0
	return z_impl_k_poll(events, num_events, timeout);
60005130:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60005134:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60005138:	2103      	movs	r1, #3
6000513a:	f004 f9d1 	bl	600094e0 <z_impl_k_poll>
		if (err != 0) {
6000513e:	4605      	mov	r5, r0
60005140:	68a0      	ldr	r0, [r4, #8]
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
60005142:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60005146:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
6000514a:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
		if (err != 0) {
6000514e:	b175      	cbz	r5, 6000516e <shell_thread+0x7a>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
60005150:	f005 faf8 	bl	6000a744 <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(shell, SHELL_ERROR,
60005154:	4620      	mov	r0, r4
60005156:	462b      	mov	r3, r5
60005158:	4a17      	ldr	r2, [pc, #92]	; (600051b8 <shell_thread+0xc4>)
6000515a:	2102      	movs	r1, #2
6000515c:	f005 ff27 	bl	6000afae <z_shell_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
60005160:	68a0      	ldr	r0, [r4, #8]
}
60005162:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			k_mutex_unlock(&shell->ctx->wr_mtx);
60005166:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
6000516a:	f005 bb38 	b.w	6000a7de <k_mutex_unlock.isra.0>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
6000516e:	f005 fae9 	bl	6000a744 <k_mutex_lock.constprop.0.isra.0>
		if (shell->iface->api->update) {
60005172:	6860      	ldr	r0, [r4, #4]
60005174:	6803      	ldr	r3, [r0, #0]
60005176:	695b      	ldr	r3, [r3, #20]
60005178:	b103      	cbz	r3, 6000517c <shell_thread+0x88>
			shell->iface->api->update(shell->iface);
6000517a:	4798      	blx	r3
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
6000517c:	4642      	mov	r2, r8
6000517e:	4620      	mov	r0, r4
60005180:	2102      	movs	r1, #2
60005182:	f005 fab7 	bl	6000a6f4 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
60005186:	463a      	mov	r2, r7
60005188:	4620      	mov	r0, r4
6000518a:	2100      	movs	r1, #0
6000518c:	f005 fab2 	bl	6000a6f4 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
60005190:	4620      	mov	r0, r4
60005192:	4632      	mov	r2, r6
60005194:	2101      	movs	r1, #1
60005196:	f005 faad 	bl	6000a6f4 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
6000519a:	68a0      	ldr	r0, [r4, #8]
6000519c:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
600051a0:	f005 fb1d 	bl	6000a7de <k_mutex_unlock.isra.0>
600051a4:	e7c1      	b.n	6000512a <shell_thread+0x36>
}
600051a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
600051aa:	bf00      	nop
600051ac:	6000a75d 	.word	0x6000a75d
600051b0:	60004949 	.word	0x60004949
600051b4:	6000a7e3 	.word	0x6000a7e3
600051b8:	6000df63 	.word	0x6000df63

600051bc <cmd_help>:

	return (int)z_flag_mode_delete_set(shell, val);
}

static int cmd_help(const struct shell *shell, size_t argc, char **argv)
{
600051bc:	b510      	push	{r4, lr}
600051be:	4604      	mov	r4, r0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(shell, "Please press the <Tab> button to see all available "
600051c0:	4a0c      	ldr	r2, [pc, #48]	; (600051f4 <cmd_help+0x38>)
600051c2:	2100      	movs	r1, #0
600051c4:	f005 fb69 	bl	6000a89a <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(shell,
600051c8:	4620      	mov	r0, r4
600051ca:	4a0b      	ldr	r2, [pc, #44]	; (600051f8 <cmd_help+0x3c>)
600051cc:	2100      	movs	r1, #0
600051ce:	f005 fb64 	bl	6000a89a <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(shell,
600051d2:	4620      	mov	r0, r4
600051d4:	4a09      	ldr	r2, [pc, #36]	; (600051fc <cmd_help+0x40>)
600051d6:	2100      	movs	r1, #0
600051d8:	f005 fb5f 	bl	6000a89a <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(shell,
600051dc:	4620      	mov	r0, r4
600051de:	4a08      	ldr	r2, [pc, #32]	; (60005200 <cmd_help+0x44>)
600051e0:	2100      	movs	r1, #0
600051e2:	f005 fb5a 	bl	6000a89a <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(shell, NULL,
600051e6:	4620      	mov	r0, r4
600051e8:	4a06      	ldr	r2, [pc, #24]	; (60005204 <cmd_help+0x48>)
600051ea:	2100      	movs	r1, #0
600051ec:	f000 fa8e 	bl	6000570c <z_shell_help_subcmd_print>
			shell_print(shell, "  %s", entry->syntax);
		}
	}

	return 0;
}
600051f0:	2000      	movs	r0, #0
600051f2:	bd10      	pop	{r4, pc}
600051f4:	6000df7a 	.word	0x6000df7a
600051f8:	6000dfb8 	.word	0x6000dfb8
600051fc:	6000e017 	.word	0x6000e017
60005200:	6000e06b 	.word	0x6000e06b
60005204:	6000e105 	.word	0x6000e105

60005208 <z_shell_fprintf_fmt>:
	return 0;
}

void z_shell_fprintf_fmt(const struct shell_fprintf *sh_fprintf,
			 const char *fmt, va_list args)
{
60005208:	b510      	push	{r4, lr}
6000520a:	4604      	mov	r4, r0
6000520c:	4613      	mov	r3, r2
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
6000520e:	460a      	mov	r2, r1
60005210:	4601      	mov	r1, r0
60005212:	4806      	ldr	r0, [pc, #24]	; (6000522c <z_shell_fprintf_fmt+0x24>)
60005214:	f7fd fadc 	bl	600027d0 <cbvprintf>

	if (sh_fprintf->ctrl_blk->autoflush) {
60005218:	6923      	ldr	r3, [r4, #16]
6000521a:	791b      	ldrb	r3, [r3, #4]
6000521c:	b123      	cbz	r3, 60005228 <z_shell_fprintf_fmt+0x20>
		z_shell_fprintf_buffer_flush(sh_fprintf);
6000521e:	4620      	mov	r0, r4
	}
}
60005220:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_fprintf_buffer_flush(sh_fprintf);
60005224:	f005 bb46 	b.w	6000a8b4 <z_shell_fprintf_buffer_flush>
}
60005228:	bd10      	pop	{r4, pc}
6000522a:	bf00      	nop
6000522c:	6000a8cd 	.word	0x6000a8cd

60005230 <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
60005230:	b510      	push	{r4, lr}
60005232:	460b      	mov	r3, r1
60005234:	4614      	mov	r4, r2
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
60005236:	b950      	cbnz	r0, 6000524e <z_shell_cmd_get+0x1e>
	return ((uint8_t *)__shell_root_cmds_end -
60005238:	490e      	ldr	r1, [pc, #56]	; (60005274 <z_shell_cmd_get+0x44>)
6000523a:	4a0f      	ldr	r2, [pc, #60]	; (60005278 <z_shell_cmd_get+0x48>)
6000523c:	1a52      	subs	r2, r2, r1
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
6000523e:	ebb3 0fd2 	cmp.w	r3, r2, lsr #3
60005242:	d20f      	bcs.n	60005264 <z_shell_cmd_get+0x34>
60005244:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
60005248:	684c      	ldr	r4, [r1, #4]
			}
		}
	}

	return res;
}
6000524a:	4620      	mov	r0, r4
6000524c:	bd10      	pop	{r4, pc}
	if (parent->subcmd) {
6000524e:	6881      	ldr	r1, [r0, #8]
60005250:	b141      	cbz	r1, 60005264 <z_shell_cmd_get+0x34>
			parent->subcmd->u.dynamic_get(idx, dloc);
60005252:	684a      	ldr	r2, [r1, #4]
		if (parent->subcmd->is_dynamic) {
60005254:	7809      	ldrb	r1, [r1, #0]
60005256:	b139      	cbz	r1, 60005268 <z_shell_cmd_get+0x38>
			parent->subcmd->u.dynamic_get(idx, dloc);
60005258:	4618      	mov	r0, r3
6000525a:	4621      	mov	r1, r4
6000525c:	4790      	blx	r2
			if (dloc->syntax != NULL) {
6000525e:	6823      	ldr	r3, [r4, #0]
60005260:	2b00      	cmp	r3, #0
60005262:	d1f2      	bne.n	6000524a <z_shell_cmd_get+0x1a>
	const struct shell_static_entry *res = NULL;
60005264:	2400      	movs	r4, #0
60005266:	e7f0      	b.n	6000524a <z_shell_cmd_get+0x1a>
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
60005268:	2014      	movs	r0, #20
6000526a:	4343      	muls	r3, r0
6000526c:	18d4      	adds	r4, r2, r3
6000526e:	58d3      	ldr	r3, [r2, r3]
60005270:	e7f6      	b.n	60005260 <z_shell_cmd_get+0x30>
60005272:	bf00      	nop
60005274:	6000cf38 	.word	0x6000cf38
60005278:	6000cf80 	.word	0x6000cf80

6000527c <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n");
6000527c:	4901      	ldr	r1, [pc, #4]	; (60005284 <z_cursor_next_line_move.isra.0+0x8>)
6000527e:	f005 bd22 	b.w	6000acc6 <z_shell_raw_fprintf>
60005282:	bf00      	nop
60005284:	6000dc94 	.word	0x6000dc94

60005288 <z_clear_eos.isra.0>:
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
60005288:	4a01      	ldr	r2, [pc, #4]	; (60005290 <z_clear_eos.isra.0+0x8>)
6000528a:	4902      	ldr	r1, [pc, #8]	; (60005294 <z_clear_eos.isra.0+0xc>)
6000528c:	f005 bd1b 	b.w	6000acc6 <z_shell_raw_fprintf>
60005290:	6000e14f 	.word	0x6000e14f
60005294:	6000ddaf 	.word	0x6000ddaf

60005298 <z_shell_op_cursor_vert_move>:
#include <ctype.h>
#include "shell_ops.h"

void z_shell_op_cursor_vert_move(const struct shell *shell, int32_t delta)
{
	if (delta != 0) {
60005298:	b159      	cbz	r1, 600052b2 <z_shell_op_cursor_vert_move+0x1a>
		z_shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
6000529a:	2900      	cmp	r1, #0
6000529c:	ea81 72e1 	eor.w	r2, r1, r1, asr #31
600052a0:	6940      	ldr	r0, [r0, #20]
600052a2:	eba2 72e1 	sub.w	r2, r2, r1, asr #31
600052a6:	bfcc      	ite	gt
600052a8:	2341      	movgt	r3, #65	; 0x41
600052aa:	2342      	movle	r3, #66	; 0x42
600052ac:	4901      	ldr	r1, [pc, #4]	; (600052b4 <z_shell_op_cursor_vert_move+0x1c>)
600052ae:	f005 bd0a 	b.w	6000acc6 <z_shell_raw_fprintf>
				    delta > 0 ? delta : -delta,
				    delta > 0 ? 'A' : 'B');
	}
}
600052b2:	4770      	bx	lr
600052b4:	6000e141 	.word	0x6000e141

600052b8 <z_shell_op_cursor_horiz_move>:

void z_shell_op_cursor_horiz_move(const struct shell *shell, int32_t delta)
{
	if (delta != 0) {
600052b8:	b159      	cbz	r1, 600052d2 <z_shell_op_cursor_horiz_move+0x1a>
		z_shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
600052ba:	2900      	cmp	r1, #0
600052bc:	ea81 72e1 	eor.w	r2, r1, r1, asr #31
600052c0:	6940      	ldr	r0, [r0, #20]
600052c2:	eba2 72e1 	sub.w	r2, r2, r1, asr #31
600052c6:	bfcc      	ite	gt
600052c8:	2343      	movgt	r3, #67	; 0x43
600052ca:	2344      	movle	r3, #68	; 0x44
600052cc:	4901      	ldr	r1, [pc, #4]	; (600052d4 <z_shell_op_cursor_horiz_move+0x1c>)
600052ce:	f005 bcfa 	b.w	6000acc6 <z_shell_raw_fprintf>
				    delta > 0 ? delta : -delta,
				    delta > 0 ? 'C' : 'D');
	}
}
600052d2:	4770      	bx	lr
600052d4:	6000e141 	.word	0x6000e141

600052d8 <z_shell_print_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
600052d8:	6882      	ldr	r2, [r0, #8]
600052da:	4902      	ldr	r1, [pc, #8]	; (600052e4 <z_shell_print_cmd+0xc>)
600052dc:	323e      	adds	r2, #62	; 0x3e
600052de:	6940      	ldr	r0, [r0, #20]
600052e0:	f005 bcf1 	b.w	6000acc6 <z_shell_raw_fprintf>
600052e4:	6000ddaf 	.word	0x6000ddaf

600052e8 <z_shell_vt100_color_set>:

void z_shell_vt100_color_set(const struct shell *shell,
			     enum shell_vt100_color color)
{

	if (shell->ctx->vt100_ctx.col.col == color) {
600052e8:	6883      	ldr	r3, [r0, #8]
{
600052ea:	b507      	push	{r0, r1, r2, lr}
	if (shell->ctx->vt100_ctx.col.col == color) {
600052ec:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
600052f0:	428a      	cmp	r2, r1
600052f2:	d01f      	beq.n	60005334 <z_shell_vt100_color_set+0x4c>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
600052f4:	f883 102e 	strb.w	r1, [r3, #46]	; 0x2e

	if (color != SHELL_NORMAL) {
600052f8:	b1f9      	cbz	r1, 6000533a <z_shell_vt100_color_set+0x52>

		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
600052fa:	231b      	movs	r3, #27
600052fc:	312f      	adds	r1, #47	; 0x2f

		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
600052fe:	466a      	mov	r2, sp
60005300:	6940      	ldr	r0, [r0, #20]
		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
60005302:	f88d 3000 	strb.w	r3, [sp]
60005306:	235b      	movs	r3, #91	; 0x5b
60005308:	f88d 1005 	strb.w	r1, [sp, #5]
6000530c:	f88d 3001 	strb.w	r3, [sp, #1]
60005310:	2331      	movs	r3, #49	; 0x31
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
60005312:	490e      	ldr	r1, [pc, #56]	; (6000534c <z_shell_vt100_color_set+0x64>)
		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
60005314:	f88d 3002 	strb.w	r3, [sp, #2]
60005318:	233b      	movs	r3, #59	; 0x3b
6000531a:	f88d 3003 	strb.w	r3, [sp, #3]
6000531e:	2333      	movs	r3, #51	; 0x33
60005320:	f88d 3004 	strb.w	r3, [sp, #4]
60005324:	236d      	movs	r3, #109	; 0x6d
60005326:	f88d 3006 	strb.w	r3, [sp, #6]
6000532a:	2300      	movs	r3, #0
6000532c:	f88d 3007 	strb.w	r3, [sp, #7]
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
60005330:	f005 fcc9 	bl	6000acc6 <z_shell_raw_fprintf>
	} else {
		static const uint8_t cmd[] = SHELL_VT100_MODESOFF;

		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
	}
}
60005334:	b003      	add	sp, #12
60005336:	f85d fb04 	ldr.w	pc, [sp], #4
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
6000533a:	4a05      	ldr	r2, [pc, #20]	; (60005350 <z_shell_vt100_color_set+0x68>)
6000533c:	4903      	ldr	r1, [pc, #12]	; (6000534c <z_shell_vt100_color_set+0x64>)
6000533e:	6940      	ldr	r0, [r0, #20]
}
60005340:	b003      	add	sp, #12
60005342:	f85d eb04 	ldr.w	lr, [sp], #4
		z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
60005346:	f005 bcbe 	b.w	6000acc6 <z_shell_raw_fprintf>
6000534a:	bf00      	nop
6000534c:	6000ddaf 	.word	0x6000ddaf
60005350:	6000e148 	.word	0x6000e148

60005354 <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *shell,
				       const struct shell_vt100_colors *color)
{
60005354:	b537      	push	{r0, r1, r2, r4, r5, lr}
60005356:	460d      	mov	r5, r1
	z_shell_vt100_color_set(shell, color->col);
60005358:	7809      	ldrb	r1, [r1, #0]
{
6000535a:	4604      	mov	r4, r0
	z_shell_vt100_color_set(shell, color->col);
6000535c:	f7ff ffc4 	bl	600052e8 <z_shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
60005360:	786b      	ldrb	r3, [r5, #1]
	if ((bgcolor == SHELL_NORMAL) ||
60005362:	b1f3      	cbz	r3, 600053a2 <z_shell_vt100_colors_restore+0x4e>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
60005364:	68a2      	ldr	r2, [r4, #8]
	if ((bgcolor == SHELL_NORMAL) ||
60005366:	f892 102f 	ldrb.w	r1, [r2, #47]	; 0x2f
6000536a:	4299      	cmp	r1, r3
6000536c:	d019      	beq.n	600053a2 <z_shell_vt100_colors_restore+0x4e>
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
6000536e:	211b      	movs	r1, #27
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
60005370:	f882 302f 	strb.w	r3, [r2, #47]	; 0x2f
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
60005374:	466a      	mov	r2, sp
60005376:	6960      	ldr	r0, [r4, #20]
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
60005378:	f88d 1000 	strb.w	r1, [sp]
6000537c:	215b      	movs	r1, #91	; 0x5b
6000537e:	f88d 1001 	strb.w	r1, [sp, #1]
60005382:	2134      	movs	r1, #52	; 0x34
60005384:	f88d 1002 	strb.w	r1, [sp, #2]
60005388:	f103 012f 	add.w	r1, r3, #47	; 0x2f
6000538c:	f88d 1003 	strb.w	r1, [sp, #3]
60005390:	216d      	movs	r1, #109	; 0x6d
60005392:	f88d 1004 	strb.w	r1, [sp, #4]
60005396:	2100      	movs	r1, #0
60005398:	f88d 1005 	strb.w	r1, [sp, #5]
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
6000539c:	4902      	ldr	r1, [pc, #8]	; (600053a8 <z_shell_vt100_colors_restore+0x54>)
6000539e:	f005 fc92 	bl	6000acc6 <z_shell_raw_fprintf>
}
600053a2:	b003      	add	sp, #12
600053a4:	bd30      	pop	{r4, r5, pc}
600053a6:	bf00      	nop
600053a8:	6000ddaf 	.word	0x6000ddaf

600053ac <z_shell_op_word_remove>:
{
600053ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
600053ae:	6883      	ldr	r3, [r0, #8]
{
600053b0:	4605      	mov	r5, r0
	if ((shell->ctx->cmd_buff_len == 0) ||
600053b2:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
600053b4:	2a00      	cmp	r2, #0
600053b6:	d046      	beq.n	60005446 <z_shell_op_word_remove+0x9a>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
600053b8:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
	if ((shell->ctx->cmd_buff_len == 0) ||
600053ba:	2800      	cmp	r0, #0
600053bc:	d043      	beq.n	60005446 <z_shell_op_word_remove+0x9a>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
600053be:	303d      	adds	r0, #61	; 0x3d
	char *str_start = &shell->ctx->cmd_buff[0];
600053c0:	f103 063e 	add.w	r6, r3, #62	; 0x3e
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
600053c4:	4418      	add	r0, r3
	char *str_start = &shell->ctx->cmd_buff[0];
600053c6:	4603      	mov	r3, r0
600053c8:	1ac4      	subs	r4, r0, r3
	while ((str >= str_start) && (*str == ' ')) {
600053ca:	42b3      	cmp	r3, r6
600053cc:	4619      	mov	r1, r3
600053ce:	b2a4      	uxth	r4, r4
600053d0:	d30d      	bcc.n	600053ee <z_shell_op_word_remove+0x42>
600053d2:	f811 7901 	ldrb.w	r7, [r1], #-1
600053d6:	2f20      	cmp	r7, #32
600053d8:	d033      	beq.n	60005442 <z_shell_op_word_remove+0x96>
600053da:	4619      	mov	r1, r3
600053dc:	3b01      	subs	r3, #1
	while ((str >= str_start) && (*str != ' ')) {
600053de:	7808      	ldrb	r0, [r1, #0]
600053e0:	2820      	cmp	r0, #32
600053e2:	d004      	beq.n	600053ee <z_shell_op_word_remove+0x42>
		++chars_to_delete;
600053e4:	3401      	adds	r4, #1
	while ((str >= str_start) && (*str != ' ')) {
600053e6:	429e      	cmp	r6, r3
		--str;
600053e8:	4619      	mov	r1, r3
		++chars_to_delete;
600053ea:	b2a4      	uxth	r4, r4
	while ((str >= str_start) && (*str != ' ')) {
600053ec:	d9f5      	bls.n	600053da <z_shell_op_word_remove+0x2e>
	memmove(str + 1, str + 1 + chars_to_delete,
600053ee:	1c63      	adds	r3, r4, #1
600053f0:	1c4e      	adds	r6, r1, #1
600053f2:	1b12      	subs	r2, r2, r4
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
600053f4:	2700      	movs	r7, #0
	memmove(str + 1, str + 1 + chars_to_delete,
600053f6:	4419      	add	r1, r3
600053f8:	4630      	mov	r0, r6
600053fa:	f006 fa92 	bl	6000b922 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
600053fe:	68a9      	ldr	r1, [r5, #8]
	z_shell_op_cursor_move(shell, -chars_to_delete);
60005400:	4628      	mov	r0, r5
	shell->ctx->cmd_buff_len -= chars_to_delete;
60005402:	8f0a      	ldrh	r2, [r1, #56]	; 0x38
60005404:	1b12      	subs	r2, r2, r4
60005406:	b292      	uxth	r2, r2
60005408:	870a      	strh	r2, [r1, #56]	; 0x38
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
6000540a:	440a      	add	r2, r1
	z_shell_op_cursor_move(shell, -chars_to_delete);
6000540c:	4261      	negs	r1, r4
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
6000540e:	f882 703e 	strb.w	r7, [r2, #62]	; 0x3e
	z_shell_op_cursor_move(shell, -chars_to_delete);
60005412:	b209      	sxth	r1, r1
60005414:	f005 fcbf 	bl	6000ad96 <z_shell_op_cursor_move>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
60005418:	6968      	ldr	r0, [r5, #20]
6000541a:	4a0b      	ldr	r2, [pc, #44]	; (60005448 <z_shell_op_word_remove+0x9c>)
6000541c:	490b      	ldr	r1, [pc, #44]	; (6000544c <z_shell_op_word_remove+0xa0>)
6000541e:	f005 fc52 	bl	6000acc6 <z_shell_raw_fprintf>
	z_shell_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
60005422:	4639      	mov	r1, r7
60005424:	4633      	mov	r3, r6
60005426:	4a09      	ldr	r2, [pc, #36]	; (6000544c <z_shell_op_word_remove+0xa0>)
60005428:	4628      	mov	r0, r5
6000542a:	f005 fdc0 	bl	6000afae <z_shell_fprintf>
	z_clear_eos(shell);
6000542e:	6968      	ldr	r0, [r5, #20]
60005430:	f7ff ff2a 	bl	60005288 <z_clear_eos.isra.0>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
60005434:	6968      	ldr	r0, [r5, #20]
60005436:	4a06      	ldr	r2, [pc, #24]	; (60005450 <z_shell_op_word_remove+0xa4>)
60005438:	4904      	ldr	r1, [pc, #16]	; (6000544c <z_shell_op_word_remove+0xa0>)
}
6000543a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
6000543e:	f005 bc42 	b.w	6000acc6 <z_shell_raw_fprintf>
60005442:	460b      	mov	r3, r1
60005444:	e7c0      	b.n	600053c8 <z_shell_op_word_remove+0x1c>
60005446:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
60005448:	6000e153 	.word	0x6000e153
6000544c:	6000ddaf 	.word	0x6000ddaf
60005450:	6000e14c 	.word	0x6000e14c

60005454 <reprint_from_cursor>:
{
60005454:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60005458:	4604      	mov	r4, r0
6000545a:	460d      	mov	r5, r1
	if (data_removed) {
6000545c:	4617      	mov	r7, r2
6000545e:	b112      	cbz	r2, 60005466 <reprint_from_cursor+0x12>
		z_clear_eos(shell);
60005460:	6940      	ldr	r0, [r0, #20]
60005462:	f7ff ff11 	bl	60005288 <z_clear_eos.isra.0>
	return shell->ctx->internal.flags.obscure == 1;
60005466:	68a3      	ldr	r3, [r4, #8]
60005468:	f8d3 225c 	ldr.w	r2, [r3, #604]	; 0x25c
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
6000546c:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
6000546e:	f3c2 01c0 	ubfx	r1, r2, #3, #1
	if (z_flag_obscure_get(shell)) {
60005472:	0712      	lsls	r2, r2, #28
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
60005474:	f100 003e 	add.w	r0, r0, #62	; 0x3e
60005478:	4403      	add	r3, r0
	if (z_flag_obscure_get(shell)) {
6000547a:	d51f      	bpl.n	600054bc <reprint_from_cursor+0x68>
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
6000547c:	4618      	mov	r0, r3
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
6000547e:	f8df 8048 	ldr.w	r8, [pc, #72]	; 600054c8 <reprint_from_cursor+0x74>
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
60005482:	f006 fa10 	bl	6000b8a6 <strlen>
60005486:	4606      	mov	r6, r0
		while (len--) {
60005488:	b996      	cbnz	r6, 600054b0 <reprint_from_cursor+0x5c>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
6000548a:	68a3      	ldr	r3, [r4, #8]
	if (full_line_cmd(shell)) {
6000548c:	4620      	mov	r0, r4
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
6000548e:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
60005490:	875a      	strh	r2, [r3, #58]	; 0x3a
	if (full_line_cmd(shell)) {
60005492:	f005 fc25 	bl	6000ace0 <full_line_cmd>
60005496:	b120      	cbz	r0, 600054a2 <reprint_from_cursor+0x4e>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
60005498:	b107      	cbz	r7, 6000549c <reprint_from_cursor+0x48>
6000549a:	b115      	cbz	r5, 600054a2 <reprint_from_cursor+0x4e>
			z_cursor_next_line_move(shell);
6000549c:	6960      	ldr	r0, [r4, #20]
6000549e:	f7ff feed 	bl	6000527c <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(shell, -diff);
600054a2:	4269      	negs	r1, r5
600054a4:	4620      	mov	r0, r4
600054a6:	b209      	sxth	r1, r1
}
600054a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_shell_op_cursor_move(shell, -diff);
600054ac:	f005 bc73 	b.w	6000ad96 <z_shell_op_cursor_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
600054b0:	4641      	mov	r1, r8
600054b2:	6960      	ldr	r0, [r4, #20]
600054b4:	3e01      	subs	r6, #1
600054b6:	f005 fc06 	bl	6000acc6 <z_shell_raw_fprintf>
600054ba:	e7e5      	b.n	60005488 <reprint_from_cursor+0x34>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s",
600054bc:	4a03      	ldr	r2, [pc, #12]	; (600054cc <reprint_from_cursor+0x78>)
600054be:	4620      	mov	r0, r4
600054c0:	f005 fd75 	bl	6000afae <z_shell_fprintf>
600054c4:	e7e1      	b.n	6000548a <reprint_from_cursor+0x36>
600054c6:	bf00      	nop
600054c8:	6000ea71 	.word	0x6000ea71
600054cc:	6000ddaf 	.word	0x6000ddaf

600054d0 <z_shell_op_char_insert>:
	if (shell->ctx->internal.flags.insert_mode &&
600054d0:	6883      	ldr	r3, [r0, #8]
{
600054d2:	b513      	push	{r0, r1, r4, lr}
600054d4:	f88d 1007 	strb.w	r1, [sp, #7]
600054d8:	4604      	mov	r4, r0
	if (shell->ctx->internal.flags.insert_mode &&
600054da:	f8d3 225c 	ldr.w	r2, [r3, #604]	; 0x25c
600054de:	07d0      	lsls	r0, r2, #31
600054e0:	d521      	bpl.n	60005526 <z_shell_op_char_insert+0x56>
		(shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
600054e2:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
	if (shell->ctx->internal.flags.insert_mode &&
600054e4:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
600054e6:	428a      	cmp	r2, r1
600054e8:	d01d      	beq.n	60005526 <z_shell_op_char_insert+0x56>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
600054ea:	1c48      	adds	r0, r1, #1
		char_replace(shell, data);
600054ec:	f89d 2007 	ldrb.w	r2, [sp, #7]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
600054f0:	4419      	add	r1, r3
600054f2:	8758      	strh	r0, [r3, #58]	; 0x3a
600054f4:	f881 203e 	strb.w	r2, [r1, #62]	; 0x3e
	return shell->ctx->internal.flags.echo == 1;
600054f8:	f8d3 125c 	ldr.w	r1, [r3, #604]	; 0x25c
	if (!z_flag_echo_get(shell)) {
600054fc:	0749      	lsls	r1, r1, #29
600054fe:	d510      	bpl.n	60005522 <z_shell_op_char_insert+0x52>
	return shell->ctx->internal.flags.obscure == 1;
60005500:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
60005504:	6960      	ldr	r0, [r4, #20]
		data = '*';
60005506:	f013 0f08 	tst.w	r3, #8
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
6000550a:	490a      	ldr	r1, [pc, #40]	; (60005534 <z_shell_op_char_insert+0x64>)
6000550c:	bf18      	it	ne
6000550e:	222a      	movne	r2, #42	; 0x2a
60005510:	f005 fbd9 	bl	6000acc6 <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(shell)) {
60005514:	4620      	mov	r0, r4
60005516:	f005 fbf7 	bl	6000ad08 <z_shell_cursor_in_empty_line>
6000551a:	b110      	cbz	r0, 60005522 <z_shell_op_char_insert+0x52>
		z_cursor_next_line_move(shell);
6000551c:	6960      	ldr	r0, [r4, #20]
6000551e:	f7ff fead 	bl	6000527c <z_cursor_next_line_move.isra.0>
}
60005522:	b002      	add	sp, #8
60005524:	bd10      	pop	{r4, pc}
		data_insert(shell, &data, 1);
60005526:	2201      	movs	r2, #1
60005528:	f10d 0107 	add.w	r1, sp, #7
6000552c:	4620      	mov	r0, r4
6000552e:	f005 fd4b 	bl	6000afc8 <data_insert>
}
60005532:	e7f6      	b.n	60005522 <z_shell_op_char_insert+0x52>
60005534:	6000e145 	.word	0x6000e145

60005538 <z_shell_print_prompt_and_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
60005538:	6883      	ldr	r3, [r0, #8]
6000553a:	2103      	movs	r1, #3
6000553c:	4a09      	ldr	r2, [pc, #36]	; (60005564 <z_shell_print_prompt_and_cmd+0x2c>)
6000553e:	681b      	ldr	r3, [r3, #0]
{
60005540:	b510      	push	{r4, lr}
60005542:	4604      	mov	r4, r0
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
60005544:	f005 fd33 	bl	6000afae <z_shell_fprintf>
	return shell->ctx->internal.flags.echo == 1;
60005548:	68a3      	ldr	r3, [r4, #8]
6000554a:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
	if (z_flag_echo_get(shell)) {
6000554e:	075b      	lsls	r3, r3, #29
60005550:	d507      	bpl.n	60005562 <z_shell_print_prompt_and_cmd+0x2a>
		z_shell_print_cmd(shell);
60005552:	4620      	mov	r0, r4
60005554:	f7ff fec0 	bl	600052d8 <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(shell);
60005558:	4620      	mov	r0, r4
}
6000555a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_op_cursor_position_synchronize(shell);
6000555e:	f005 bbf7 	b.w	6000ad50 <z_shell_op_cursor_position_synchronize>
}
60005562:	bd10      	pop	{r4, pc}
60005564:	6000ddaf 	.word	0x6000ddaf

60005568 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
60005568:	b507      	push	{r0, r1, r2, lr}
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
6000556a:	4809      	ldr	r0, [pc, #36]	; (60005590 <enable_shell_uart+0x28>)
6000556c:	f002 fc16 	bl	60007d9c <z_impl_device_get_binding>
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	uint32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	if (dev == NULL) {
60005570:	4601      	mov	r1, r0
60005572:	b150      	cbz	r0, 6000558a <enable_shell_uart+0x22>

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, true, log_backend, level);
60005574:	2304      	movs	r3, #4
60005576:	4807      	ldr	r0, [pc, #28]	; (60005594 <enable_shell_uart+0x2c>)
60005578:	9300      	str	r3, [sp, #0]
6000557a:	2301      	movs	r3, #1
6000557c:	461a      	mov	r2, r3
6000557e:	f7ff fd09 	bl	60004f94 <shell_init>

	return 0;
60005582:	2000      	movs	r0, #0
}
60005584:	b003      	add	sp, #12
60005586:	f85d fb04 	ldr.w	pc, [sp], #4
		return -ENODEV;
6000558a:	f06f 0012 	mvn.w	r0, #18
6000558e:	e7f9      	b.n	60005584 <enable_shell_uart+0x1c>
60005590:	6000e156 	.word	0x6000e156
60005594:	6000cf08 	.word	0x6000cf08

60005598 <init>:
{
60005598:	b570      	push	{r4, r5, r6, lr}
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
6000559a:	6846      	ldr	r6, [r0, #4]
{
6000559c:	460c      	mov	r4, r1
 *
 * @param buf Address of ring buffer.
 */
static inline void ring_buf_reset(struct ring_buf *buf)
{
	buf->head = 0;
6000559e:	2500      	movs	r5, #0
	sh_uart->ctrl_blk->dev = (const struct device *)config;
600055a0:	6831      	ldr	r1, [r6, #0]
	ring_buf_reset(sh_uart->tx_ringbuf);
600055a2:	68b0      	ldr	r0, [r6, #8]
	sh_uart->ctrl_blk->context = context;
600055a4:	608b      	str	r3, [r1, #8]
	sh_uart->ctrl_blk->handler = evt_handler;
600055a6:	e9c1 4200 	strd	r4, r2, [r1]
	buf->tail = 0;
	memset(&buf->misc, 0, sizeof(buf->misc));
600055aa:	2208      	movs	r2, #8
600055ac:	4629      	mov	r1, r5
	buf->tail = 0;
600055ae:	e9c0 5500 	strd	r5, r5, [r0]
	memset(&buf->misc, 0, sizeof(buf->misc));
600055b2:	4410      	add	r0, r2
600055b4:	f006 f9f8 	bl	6000b9a8 <memset>
	ring_buf_reset(sh_uart->rx_ringbuf);
600055b8:	68f0      	ldr	r0, [r6, #12]
600055ba:	2208      	movs	r2, #8
600055bc:	4629      	mov	r1, r5
	buf->tail = 0;
600055be:	e9c0 5500 	strd	r5, r5, [r0]
	memset(&buf->misc, 0, sizeof(buf->misc));
600055c2:	4410      	add	r0, r2
600055c4:	f006 f9f0 	bl	6000b9a8 <memset>
	sh_uart->ctrl_blk->tx_busy = 0;
600055c8:	6833      	ldr	r3, [r6, #0]
600055ca:	60dd      	str	r5, [r3, #12]
static inline void uart_irq_callback_user_data_set(const struct device *dev,
						   uart_irq_callback_user_data_t cb,
						   void *user_data)
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
600055cc:	68a3      	ldr	r3, [r4, #8]
		(const struct uart_driver_api *)dev->api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
600055ce:	b12b      	cbz	r3, 600055dc <init+0x44>
600055d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
600055d2:	b11b      	cbz	r3, 600055dc <init+0x44>
		api->irq_callback_set(dev, cb, user_data);
600055d4:	4632      	mov	r2, r6
600055d6:	4905      	ldr	r1, [pc, #20]	; (600055ec <init+0x54>)
600055d8:	4620      	mov	r0, r4
600055da:	4798      	blx	r3
	if (api->irq_rx_enable != NULL) {
600055dc:	68a3      	ldr	r3, [r4, #8]
600055de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600055e0:	b10b      	cbz	r3, 600055e6 <init+0x4e>
		api->irq_rx_enable(dev);
600055e2:	4620      	mov	r0, r4
600055e4:	4798      	blx	r3
}
600055e6:	2000      	movs	r0, #0
600055e8:	bd70      	pop	{r4, r5, r6, pc}
600055ea:	bf00      	nop
600055ec:	600055f1 	.word	0x600055f1

600055f0 <uart_callback>:
{
600055f0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
600055f4:	4683      	mov	fp, r0
600055f6:	460d      	mov	r5, r1
	if (api->irq_update == NULL) {
600055f8:	6883      	ldr	r3, [r0, #8]
600055fa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
600055fc:	b103      	cbz	r3, 60005600 <uart_callback+0x10>
	return api->irq_update(dev);
600055fe:	4798      	blx	r3
	if (api->irq_rx_ready == NULL) {
60005600:	f8db 3008 	ldr.w	r3, [fp, #8]
60005604:	6b5b      	ldr	r3, [r3, #52]	; 0x34
60005606:	bb8b      	cbnz	r3, 6000566c <uart_callback+0x7c>
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
60005608:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 600056f4 <uart_callback+0x104>
6000560c:	f04f 0800 	mov.w	r8, #0
60005610:	4e39      	ldr	r6, [pc, #228]	; (600056f8 <uart_callback+0x108>)
			LOG_WRN("RX ring buffer full.");
60005612:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 600056fc <uart_callback+0x10c>
60005616:	eba9 0606 	sub.w	r6, r9, r6
6000561a:	08b6      	lsrs	r6, r6, #2
6000561c:	01b6      	lsls	r6, r6, #6
6000561e:	f046 0602 	orr.w	r6, r6, #2
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
60005622:	68e8      	ldr	r0, [r5, #12]
60005624:	a901      	add	r1, sp, #4
60005626:	6902      	ldr	r2, [r0, #16]
60005628:	f004 fab5 	bl	60009b96 <ring_buf_put_claim>
		if (len > 0) {
6000562c:	4607      	mov	r7, r0
6000562e:	2800      	cmp	r0, #0
60005630:	d042      	beq.n	600056b8 <uart_callback+0xc8>
	if (api->fifo_read != NULL) {
60005632:	f8db 3008 	ldr.w	r3, [fp, #8]
60005636:	699c      	ldr	r4, [r3, #24]
60005638:	b124      	cbz	r4, 60005644 <uart_callback+0x54>
		return api->fifo_read(dev, rx_data, size);
6000563a:	4602      	mov	r2, r0
6000563c:	9901      	ldr	r1, [sp, #4]
6000563e:	4658      	mov	r0, fp
60005640:	47a0      	blx	r4
60005642:	4604      	mov	r4, r0
				new_data = true;
60005644:	2c00      	cmp	r4, #0
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
60005646:	68e8      	ldr	r0, [r5, #12]
60005648:	4621      	mov	r1, r4
				new_data = true;
6000564a:	bf18      	it	ne
6000564c:	f04f 0801 	movne.w	r8, #1
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
60005650:	f004 fabd 	bl	60009bce <ring_buf_put_finish>
	} while (rd_len && (rd_len == len));
60005654:	b10c      	cbz	r4, 6000565a <uart_callback+0x6a>
60005656:	42a7      	cmp	r7, r4
60005658:	d0e3      	beq.n	60005622 <uart_callback+0x32>
	if (new_data) {
6000565a:	f1b8 0f00 	cmp.w	r8, #0
6000565e:	d009      	beq.n	60005674 <uart_callback+0x84>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
60005660:	682b      	ldr	r3, [r5, #0]
60005662:	2000      	movs	r0, #0
60005664:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
60005668:	4790      	blx	r2
}
6000566a:	e003      	b.n	60005674 <uart_callback+0x84>
	return api->irq_rx_ready(dev);
6000566c:	4658      	mov	r0, fp
6000566e:	4798      	blx	r3
	if (uart_irq_rx_ready(dev)) {
60005670:	2800      	cmp	r0, #0
60005672:	d1c9      	bne.n	60005608 <uart_callback+0x18>
	if (api->irq_tx_ready != NULL) {
60005674:	f8db 3008 	ldr.w	r3, [fp, #8]
60005678:	6a5b      	ldr	r3, [r3, #36]	; 0x24
6000567a:	b1d3      	cbz	r3, 600056b2 <uart_callback+0xc2>
		return api->irq_tx_ready(dev);
6000567c:	4658      	mov	r0, fp
6000567e:	4798      	blx	r3
	if (uart_irq_tx_ready(dev)) {
60005680:	b1b8      	cbz	r0, 600056b2 <uart_callback+0xc2>
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (uint8_t **)&data,
60005682:	68a8      	ldr	r0, [r5, #8]
60005684:	a901      	add	r1, sp, #4
60005686:	6902      	ldr	r2, [r0, #16]
60005688:	f004 facd 	bl	60009c26 <ring_buf_get_claim>
	if (len) {
6000568c:	4604      	mov	r4, r0
6000568e:	b350      	cbz	r0, 600056e6 <uart_callback+0xf6>
	if (api->fifo_fill != NULL) {
60005690:	f8db 3008 	ldr.w	r3, [fp, #8]
60005694:	695b      	ldr	r3, [r3, #20]
60005696:	b323      	cbz	r3, 600056e2 <uart_callback+0xf2>
		return api->fifo_fill(dev, tx_data, size);
60005698:	4602      	mov	r2, r0
6000569a:	9901      	ldr	r1, [sp, #4]
6000569c:	4658      	mov	r0, fp
6000569e:	4798      	blx	r3
600056a0:	4601      	mov	r1, r0
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
600056a2:	68a8      	ldr	r0, [r5, #8]
600056a4:	f004 fadb 	bl	60009c5e <ring_buf_get_finish>
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
600056a8:	682b      	ldr	r3, [r5, #0]
600056aa:	2001      	movs	r0, #1
600056ac:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
600056b0:	4790      	blx	r2
}
600056b2:	b003      	add	sp, #12
600056b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			LOG_WRN("RX ring buffer full.");
600056b8:	f8d9 3000 	ldr.w	r3, [r9]
600056bc:	f013 0f06 	tst.w	r3, #6
600056c0:	d003      	beq.n	600056ca <uart_callback+0xda>
600056c2:	4631      	mov	r1, r6
600056c4:	4650      	mov	r0, sl
600056c6:	f004 fca3 	bl	6000a010 <log_0>
	if (api->fifo_read != NULL) {
600056ca:	f8db 3008 	ldr.w	r3, [fp, #8]
600056ce:	699c      	ldr	r4, [r3, #24]
600056d0:	2c00      	cmp	r4, #0
600056d2:	d0bf      	beq.n	60005654 <uart_callback+0x64>
		return api->fifo_read(dev, rx_data, size);
600056d4:	2201      	movs	r2, #1
600056d6:	f10d 0103 	add.w	r1, sp, #3
600056da:	4658      	mov	r0, fp
600056dc:	47a0      	blx	r4
600056de:	4604      	mov	r4, r0
600056e0:	e7b8      	b.n	60005654 <uart_callback+0x64>
	return 0;
600056e2:	4619      	mov	r1, r3
600056e4:	e7dd      	b.n	600056a2 <uart_callback+0xb2>
		uart_irq_tx_disable(dev);
600056e6:	4658      	mov	r0, fp
600056e8:	f005 fccd 	bl	6000b086 <uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
600056ec:	682b      	ldr	r3, [r5, #0]
600056ee:	60dc      	str	r4, [r3, #12]
600056f0:	e7da      	b.n	600056a8 <uart_callback+0xb8>
600056f2:	bf00      	nop
600056f4:	80000248 	.word	0x80000248
600056f8:	80000234 	.word	0x80000234
600056fc:	6000e15d 	.word	0x6000e15d

60005700 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n");
60005700:	4901      	ldr	r1, [pc, #4]	; (60005708 <z_cursor_next_line_move.isra.0+0x8>)
60005702:	f005 bd1c 	b.w	6000b13e <z_shell_raw_fprintf>
60005706:	bf00      	nop
60005708:	6000dc94 	.word	0x6000dc94

6000570c <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *shell,
			       const struct shell_static_entry *parent,
			       const char *description)
{
6000570c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60005710:	460e      	mov	r6, r1
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
	size_t idx = 0;
60005712:	2100      	movs	r1, #0
{
60005714:	b08d      	sub	sp, #52	; 0x34
60005716:	4604      	mov	r4, r0
60005718:	4617      	mov	r7, r2
	uint16_t longest = 0U;
6000571a:	460d      	mov	r5, r1

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
6000571c:	aa07      	add	r2, sp, #28
6000571e:	4630      	mov	r0, r6
60005720:	f101 0801 	add.w	r8, r1, #1
60005724:	f7ff fd84 	bl	60005230 <z_shell_cmd_get>
60005728:	4601      	mov	r1, r0
6000572a:	b998      	cbnz	r0, 60005754 <z_shell_help_subcmd_print+0x48>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
6000572c:	b17d      	cbz	r5, 6000574e <z_shell_help_subcmd_print+0x42>
		return;
	}

	if (description != NULL) {
6000572e:	b11f      	cbz	r7, 60005738 <z_shell_help_subcmd_print+0x2c>
		z_shell_fprintf(shell, SHELL_NORMAL, description);
60005730:	463a      	mov	r2, r7
60005732:	4620      	mov	r0, r4
60005734:	f005 fc3b 	bl	6000afae <z_shell_fprintf>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
60005738:	2100      	movs	r1, #0
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
6000573a:	4f1e      	ldr	r7, [pc, #120]	; (600057b4 <z_shell_help_subcmd_print+0xa8>)
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
6000573c:	f8df 9078 	ldr.w	r9, [pc, #120]	; 600057b8 <z_shell_help_subcmd_print+0xac>
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
60005740:	aa07      	add	r2, sp, #28
60005742:	4630      	mov	r0, r6
60005744:	f101 0801 	add.w	r8, r1, #1
60005748:	f7ff fd72 	bl	60005230 <z_shell_cmd_get>
6000574c:	b960      	cbnz	r0, 60005768 <z_shell_help_subcmd_print+0x5c>
		help_item_print(shell, entry->syntax, longest, entry->help);
	}
}
6000574e:	b00d      	add	sp, #52	; 0x34
60005750:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
60005754:	6808      	ldr	r0, [r1, #0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
60005756:	b110      	cbz	r0, 6000575e <z_shell_help_subcmd_print+0x52>
60005758:	f006 f8a5 	bl	6000b8a6 <strlen>
6000575c:	b280      	uxth	r0, r0
6000575e:	4285      	cmp	r5, r0
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
60005760:	4641      	mov	r1, r8
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
60005762:	bf38      	it	cc
60005764:	4605      	movcc	r5, r0
60005766:	e7d9      	b.n	6000571c <z_shell_help_subcmd_print+0x10>
		help_item_print(shell, entry->syntax, longest, entry->help);
60005768:	6803      	ldr	r3, [r0, #0]
6000576a:	f8d0 a004 	ldr.w	sl, [r0, #4]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
6000576e:	4811      	ldr	r0, [pc, #68]	; (600057b4 <z_shell_help_subcmd_print+0xa8>)
		help_item_print(shell, entry->syntax, longest, entry->help);
60005770:	9305      	str	r3, [sp, #20]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
60005772:	f006 f898 	bl	6000b8a6 <strlen>
	if ((item_name == NULL) || (item_name[0] == '\0')) {
60005776:	9b05      	ldr	r3, [sp, #20]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
60005778:	4683      	mov	fp, r0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
6000577a:	b183      	cbz	r3, 6000579e <z_shell_help_subcmd_print+0x92>
6000577c:	781a      	ldrb	r2, [r3, #0]
6000577e:	b172      	cbz	r2, 6000579e <z_shell_help_subcmd_print+0x92>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
60005780:	464a      	mov	r2, r9
60005782:	2100      	movs	r1, #0
60005784:	4620      	mov	r0, r4
60005786:	9500      	str	r5, [sp, #0]
60005788:	e9cd 3701 	strd	r3, r7, [sp, #4]
6000578c:	463b      	mov	r3, r7
6000578e:	f005 fc0e 	bl	6000afae <z_shell_fprintf>
	if (item_help == NULL) {
60005792:	f1ba 0f00 	cmp.w	sl, #0
60005796:	d104      	bne.n	600057a2 <z_shell_help_subcmd_print+0x96>
		z_cursor_next_line_move(shell);
60005798:	6960      	ldr	r0, [r4, #20]
6000579a:	f7ff ffb1 	bl	60005700 <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
6000579e:	4641      	mov	r1, r8
600057a0:	e7ce      	b.n	60005740 <z_shell_help_subcmd_print+0x34>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
600057a2:	1c6a      	adds	r2, r5, #1
	formatted_text_print(shell, item_help, offset, false);
600057a4:	4651      	mov	r1, sl
600057a6:	4620      	mov	r0, r4
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
600057a8:	eb02 024b 	add.w	r2, r2, fp, lsl #1
	formatted_text_print(shell, item_help, offset, false);
600057ac:	b292      	uxth	r2, r2
600057ae:	f005 fcd3 	bl	6000b158 <formatted_text_print.constprop.0>
600057b2:	e7f4      	b.n	6000579e <z_shell_help_subcmd_print+0x92>
600057b4:	6000e1b7 	.word	0x6000e1b7
600057b8:	6000e19f 	.word	0x6000e19f

600057bc <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *shell,
			    const struct shell_static_entry *cmd)
{
600057bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
600057be:	4606      	mov	r6, r0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
600057c0:	6808      	ldr	r0, [r1, #0]
{
600057c2:	460d      	mov	r5, r1
600057c4:	b1b8      	cbz	r0, 600057f6 <z_shell_help_cmd_print+0x3a>
600057c6:	f006 f86e 	bl	6000b8a6 <strlen>
600057ca:	b284      	uxth	r4, r0
600057cc:	4f0b      	ldr	r7, [pc, #44]	; (600057fc <z_shell_help_cmd_print+0x40>)
600057ce:	4638      	mov	r0, r7
600057d0:	f006 f869 	bl	6000b8a6 <strlen>
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
600057d4:	4404      	add	r4, r0

	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
600057d6:	682b      	ldr	r3, [r5, #0]
600057d8:	4630      	mov	r0, r6
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
600057da:	b2a4      	uxth	r4, r4
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
600057dc:	4a08      	ldr	r2, [pc, #32]	; (60005800 <z_shell_help_cmd_print+0x44>)
600057de:	2100      	movs	r1, #0
600057e0:	9700      	str	r7, [sp, #0]
600057e2:	f005 fbe4 	bl	6000afae <z_shell_fprintf>

	formatted_text_print(shell, cmd->help, field_width, false);
600057e6:	4622      	mov	r2, r4
600057e8:	6869      	ldr	r1, [r5, #4]
600057ea:	4630      	mov	r0, r6
}
600057ec:	b003      	add	sp, #12
600057ee:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	formatted_text_print(shell, cmd->help, field_width, false);
600057f2:	f005 bcb1 	b.w	6000b158 <formatted_text_print.constprop.0>
600057f6:	4604      	mov	r4, r0
600057f8:	e7e8      	b.n	600057cc <z_shell_help_cmd_print+0x10>
600057fa:	bf00      	nop
600057fc:	6000e1b3 	.word	0x6000e1b3
60005800:	6000df5e 	.word	0x6000df5e

60005804 <z_shell_help_request>:

bool z_shell_help_request(const char *str)
{
60005804:	b510      	push	{r4, lr}
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
60005806:	4907      	ldr	r1, [pc, #28]	; (60005824 <z_shell_help_request+0x20>)
{
60005808:	4604      	mov	r4, r0
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
6000580a:	f006 f85c 	bl	6000b8c6 <strcmp>
6000580e:	b138      	cbz	r0, 60005820 <z_shell_help_request+0x1c>
60005810:	4905      	ldr	r1, [pc, #20]	; (60005828 <z_shell_help_request+0x24>)
60005812:	4620      	mov	r0, r4
60005814:	f006 f857 	bl	6000b8c6 <strcmp>
60005818:	fab0 f080 	clz	r0, r0
6000581c:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
6000581e:	bd10      	pop	{r4, pc}
		return true;
60005820:	2001      	movs	r0, #1
60005822:	e7fc      	b.n	6000581e <z_shell_help_request+0x1a>
60005824:	6000e1a9 	.word	0x6000e1a9
60005828:	6000e1ac 	.word	0x6000e1ac

6000582c <cmd_clear>:
	z_cursor_restore(shell);
	return ret_val;
}

static int cmd_clear(const struct shell *shell, size_t argc, char **argv)
{
6000582c:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
6000582e:	4d07      	ldr	r5, [pc, #28]	; (6000584c <cmd_clear+0x20>)
{
60005830:	4604      	mov	r4, r0
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
60005832:	4a07      	ldr	r2, [pc, #28]	; (60005850 <cmd_clear+0x24>)
60005834:	4629      	mov	r1, r5
60005836:	6940      	ldr	r0, [r0, #20]
60005838:	f005 fd05 	bl	6000b246 <z_shell_raw_fprintf>
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
6000583c:	6960      	ldr	r0, [r4, #20]
6000583e:	4a05      	ldr	r2, [pc, #20]	; (60005854 <cmd_clear+0x28>)
60005840:	4629      	mov	r1, r5
60005842:	f005 fd00 	bl	6000b246 <z_shell_raw_fprintf>

	return 0;
}
60005846:	2000      	movs	r0, #0
60005848:	bd38      	pop	{r3, r4, r5, pc}
6000584a:	bf00      	nop
6000584c:	6000ddaf 	.word	0x6000ddaf
60005850:	6000e615 	.word	0x6000e615
60005854:	6000e610 	.word	0x6000e610

60005858 <cmd_resize_default>:
	return 0;
}

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
60005858:	b510      	push	{r4, lr}
6000585a:	4604      	mov	r4, r0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
6000585c:	4a04      	ldr	r2, [pc, #16]	; (60005870 <cmd_resize_default+0x18>)
6000585e:	4905      	ldr	r1, [pc, #20]	; (60005874 <cmd_resize_default+0x1c>)
60005860:	6940      	ldr	r0, [r0, #20]
60005862:	f005 fcf0 	bl	6000b246 <z_shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
60005866:	68a3      	ldr	r3, [r4, #8]
60005868:	4a03      	ldr	r2, [pc, #12]	; (60005878 <cmd_resize_default+0x20>)

	return 0;
}
6000586a:	2000      	movs	r0, #0
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
6000586c:	629a      	str	r2, [r3, #40]	; 0x28
}
6000586e:	bd10      	pop	{r4, pc}
60005870:	6000e604 	.word	0x6000e604
60005874:	6000ddaf 	.word	0x6000ddaf
60005878:	00500018 	.word	0x00500018

6000587c <cmd_shell_stats_show>:
{
6000587c:	b508      	push	{r3, lr}
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
6000587e:	6983      	ldr	r3, [r0, #24]
60005880:	2100      	movs	r1, #0
60005882:	4a03      	ldr	r2, [pc, #12]	; (60005890 <cmd_shell_stats_show+0x14>)
60005884:	681b      	ldr	r3, [r3, #0]
60005886:	f005 f808 	bl	6000a89a <shell_fprintf>
}
6000588a:	2000      	movs	r0, #0
6000588c:	bd08      	pop	{r3, pc}
6000588e:	bf00      	nop
60005890:	6000e1ba 	.word	0x6000e1ba

60005894 <cmd_history>:
{
60005894:	b5f0      	push	{r4, r5, r6, r7, lr}
60005896:	4604      	mov	r4, r0
60005898:	b085      	sub	sp, #20
	size_t i = 0;
6000589a:	2500      	movs	r5, #0
			shell_print(shell, "[%3d] %s",
6000589c:	4f0e      	ldr	r7, [pc, #56]	; (600058d8 <cmd_history+0x44>)
				    shell->ctx->temp_buff, &len);
6000589e:	68a2      	ldr	r2, [r4, #8]
		z_shell_history_get(shell->history, true,
600058a0:	f10d 030e 	add.w	r3, sp, #14
600058a4:	2101      	movs	r1, #1
600058a6:	68e0      	ldr	r0, [r4, #12]
600058a8:	f502 729f 	add.w	r2, r2, #318	; 0x13e
600058ac:	f005 fd53 	bl	6000b356 <z_shell_history_get>
		if (len) {
600058b0:	f8bd 000e 	ldrh.w	r0, [sp, #14]
600058b4:	68a3      	ldr	r3, [r4, #8]
600058b6:	b158      	cbz	r0, 600058d0 <cmd_history+0x3c>
			shell_print(shell, "[%3d] %s",
600058b8:	f503 739f 	add.w	r3, r3, #318	; 0x13e
600058bc:	1c6e      	adds	r6, r5, #1
600058be:	463a      	mov	r2, r7
600058c0:	2100      	movs	r1, #0
600058c2:	9300      	str	r3, [sp, #0]
600058c4:	4620      	mov	r0, r4
600058c6:	462b      	mov	r3, r5
600058c8:	4635      	mov	r5, r6
600058ca:	f004 ffe6 	bl	6000a89a <shell_fprintf>
		z_shell_history_get(shell->history, true,
600058ce:	e7e6      	b.n	6000589e <cmd_history+0xa>
	shell->ctx->temp_buff[0] = '\0';
600058d0:	f883 013e 	strb.w	r0, [r3, #318]	; 0x13e
}
600058d4:	b005      	add	sp, #20
600058d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
600058d8:	6000e1c9 	.word	0x6000e1c9

600058dc <cmd_echo>:
	if (argc == 2) {
600058dc:	2902      	cmp	r1, #2
{
600058de:	b507      	push	{r0, r1, r2, lr}
	if (argc == 2) {
600058e0:	d10c      	bne.n	600058fc <cmd_echo+0x20>
		shell_error(shell, "%s:%s%s", argv[0],
600058e2:	6853      	ldr	r3, [r2, #4]
600058e4:	9301      	str	r3, [sp, #4]
600058e6:	4b0d      	ldr	r3, [pc, #52]	; (6000591c <cmd_echo+0x40>)
600058e8:	9300      	str	r3, [sp, #0]
600058ea:	6813      	ldr	r3, [r2, #0]
600058ec:	4a0c      	ldr	r2, [pc, #48]	; (60005920 <cmd_echo+0x44>)
600058ee:	f004 ffd4 	bl	6000a89a <shell_fprintf>
600058f2:	f06f 0015 	mvn.w	r0, #21
}
600058f6:	b003      	add	sp, #12
600058f8:	f85d fb04 	ldr.w	pc, [sp], #4
	return shell->ctx->internal.flags.echo == 1;
600058fc:	6883      	ldr	r3, [r0, #8]
	shell_print(shell, "Echo status: %s",
600058fe:	2100      	movs	r1, #0
60005900:	4a08      	ldr	r2, [pc, #32]	; (60005924 <cmd_echo+0x48>)
60005902:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
60005906:	f013 0f04 	tst.w	r3, #4
6000590a:	4b07      	ldr	r3, [pc, #28]	; (60005928 <cmd_echo+0x4c>)
6000590c:	bf18      	it	ne
6000590e:	4613      	movne	r3, r2
60005910:	4a06      	ldr	r2, [pc, #24]	; (6000592c <cmd_echo+0x50>)
60005912:	f004 ffc2 	bl	6000a89a <shell_fprintf>
	return 0;
60005916:	2000      	movs	r0, #0
60005918:	e7ed      	b.n	600058f6 <cmd_echo+0x1a>
6000591a:	bf00      	nop
6000591c:	6000e1e0 	.word	0x6000e1e0
60005920:	6000e1d7 	.word	0x6000e1d7
60005924:	6000dd6c 	.word	0x6000dd6c
60005928:	6000e1d3 	.word	0x6000e1d3
6000592c:	6000e1f5 	.word	0x6000e1f5

60005930 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
	int err;

	if (argc != 1) {
60005930:	2901      	cmp	r1, #1
{
60005932:	b5f0      	push	{r4, r5, r6, r7, lr}
60005934:	4605      	mov	r5, r0
60005936:	b085      	sub	sp, #20
	if (argc != 1) {
60005938:	d00d      	beq.n	60005956 <cmd_resize+0x26>
		shell_error(shell, "%s:%s%s", argv[0],
6000593a:	6853      	ldr	r3, [r2, #4]
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
6000593c:	f06f 0415 	mvn.w	r4, #21
		shell_error(shell, "%s:%s%s", argv[0],
60005940:	2102      	movs	r1, #2
60005942:	9301      	str	r3, [sp, #4]
60005944:	4b53      	ldr	r3, [pc, #332]	; (60005a94 <cmd_resize+0x164>)
60005946:	9300      	str	r3, [sp, #0]
60005948:	6813      	ldr	r3, [r2, #0]
6000594a:	4a53      	ldr	r2, [pc, #332]	; (60005a98 <cmd_resize+0x168>)
6000594c:	f004 ffa5 	bl	6000a89a <shell_fprintf>
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
60005950:	4620      	mov	r0, r4
60005952:	b005      	add	sp, #20
60005954:	bdf0      	pop	{r4, r5, r6, r7, pc}
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
60005956:	4a51      	ldr	r2, [pc, #324]	; (60005a9c <cmd_resize+0x16c>)
	char c = 0;
60005958:	2400      	movs	r4, #0
6000595a:	4951      	ldr	r1, [pc, #324]	; (60005aa0 <cmd_resize+0x170>)
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
6000595c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
60005960:	6940      	ldr	r0, [r0, #20]
60005962:	f005 fc70 	bl	6000b246 <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
60005966:	f06f 01f9 	mvn.w	r1, #249	; 0xf9
6000596a:	4628      	mov	r0, r5
6000596c:	f7ff fc94 	bl	60005298 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
60005970:	21fa      	movs	r1, #250	; 0xfa
60005972:	4628      	mov	r0, r5
60005974:	f7ff fca0 	bl	600052b8 <z_shell_op_cursor_horiz_move>
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
60005978:	68a8      	ldr	r0, [r5, #8]
6000597a:	f44f 7280 	mov.w	r2, #256	; 0x100
6000597e:	4621      	mov	r1, r4
60005980:	f500 709f 	add.w	r0, r0, #318	; 0x13e
	char c = 0;
60005984:	f88d 400b 	strb.w	r4, [sp, #11]
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
60005988:	f006 f80e 	bl	6000b9a8 <memset>
	z_shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
6000598c:	4945      	ldr	r1, [pc, #276]	; (60005aa4 <cmd_resize+0x174>)
6000598e:	6968      	ldr	r0, [r5, #20]
60005990:	f005 fc59 	bl	6000b246 <z_shell_raw_fprintf>
60005994:	6968      	ldr	r0, [r5, #20]
60005996:	f004 ff8d 	bl	6000a8b4 <z_shell_fprintf_buffer_flush>
			(void)shell->iface->api->read(shell->iface, &c,
6000599a:	6868      	ldr	r0, [r5, #4]
6000599c:	2201      	movs	r2, #1
6000599e:	f10d 010b 	add.w	r1, sp, #11
600059a2:	6803      	ldr	r3, [r0, #0]
600059a4:	691f      	ldr	r7, [r3, #16]
600059a6:	ab03      	add	r3, sp, #12
600059a8:	47b8      	blx	r7
			if (cnt == 0) {
600059aa:	9b03      	ldr	r3, [sp, #12]
600059ac:	b953      	cbnz	r3, 600059c4 <cmd_resize+0x94>
	for (uint16_t i = 0; i < 1000; i++) {
600059ae:	3e01      	subs	r6, #1
	z_impl_k_busy_wait(usec_to_wait);
600059b0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
600059b4:	f003 fcec 	bl	60009390 <z_impl_k_busy_wait>
600059b8:	b2b6      	uxth	r6, r6
600059ba:	2e00      	cmp	r6, #0
600059bc:	d1ed      	bne.n	6000599a <cmd_resize+0x6a>
		ret_val = -ENOTSUP;
600059be:	f06f 0485 	mvn.w	r4, #133	; 0x85
600059c2:	e033      	b.n	60005a2c <cmd_resize+0xfc>
			if ((c != SHELL_VT100_ASCII_ESC) &&
600059c4:	f89d 300b 	ldrb.w	r3, [sp, #11]
			    (shell->ctx->temp_buff[0] !=
600059c8:	68a9      	ldr	r1, [r5, #8]
			if ((c != SHELL_VT100_ASCII_ESC) &&
600059ca:	2b1b      	cmp	r3, #27
600059cc:	d056      	beq.n	60005a7c <cmd_resize+0x14c>
600059ce:	f891 213e 	ldrb.w	r2, [r1, #318]	; 0x13e
600059d2:	2a1b      	cmp	r2, #27
600059d4:	d1e1      	bne.n	6000599a <cmd_resize+0x6a>
			if (c == 'R') { /* End of response from the terminal. */
600059d6:	2b52      	cmp	r3, #82	; 0x52
600059d8:	d150      	bne.n	60005a7c <cmd_resize+0x14c>
				shell->ctx->temp_buff[buff_idx] = '\0';
600059da:	440c      	add	r4, r1
600059dc:	2300      	movs	r3, #0
600059de:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
				if (shell->ctx->temp_buff[1] != '[') {
600059e2:	f891 213f 	ldrb.w	r2, [r1, #319]	; 0x13f
600059e6:	2a5b      	cmp	r2, #91	; 0x5b
600059e8:	d150      	bne.n	60005a8c <cmd_resize+0x15c>
600059ea:	f501 74a0 	add.w	r4, r1, #320	; 0x140
	*y = 0U;
600059ee:	461f      	mov	r7, r3
				buff_idx = 2U;
600059f0:	2602      	movs	r6, #2
				while (shell->ctx->temp_buff[buff_idx] != ';') {
600059f2:	f814 0b01 	ldrb.w	r0, [r4], #1
600059f6:	4632      	mov	r2, r6
					(shell->ctx->temp_buff[buff_idx++] -
600059f8:	3601      	adds	r6, #1
				while (shell->ctx->temp_buff[buff_idx] != ';') {
600059fa:	283b      	cmp	r0, #59	; 0x3b
					(shell->ctx->temp_buff[buff_idx++] -
600059fc:	b2b6      	uxth	r6, r6
				while (shell->ctx->temp_buff[buff_idx] != ';') {
600059fe:	d127      	bne.n	60005a50 <cmd_resize+0x120>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
60005a00:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
60005a04:	d0db      	beq.n	600059be <cmd_resize+0x8e>
60005a06:	f202 123f 	addw	r2, r2, #319	; 0x13f
	*x = 0U;
60005a0a:	2300      	movs	r3, #0
60005a0c:	fa11 f282 	uxtah	r2, r1, r2
				while (shell->ctx->temp_buff[buff_idx]
60005a10:	f812 4b01 	ldrb.w	r4, [r2], #1
60005a14:	bb3c      	cbnz	r4, 60005a66 <cmd_resize+0x136>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
60005a16:	2bfa      	cmp	r3, #250	; 0xfa
				shell->ctx->temp_buff[0] = 0;
60005a18:	f881 413e 	strb.w	r4, [r1, #318]	; 0x13e
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
60005a1c:	bf28      	it	cs
60005a1e:	23fa      	movcs	r3, #250	; 0xfa
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
60005a20:	2ffa      	cmp	r7, #250	; 0xfa
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
60005a22:	854b      	strh	r3, [r1, #42]	; 0x2a
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
60005a24:	463b      	mov	r3, r7
60005a26:	bf28      	it	cs
60005a28:	23fa      	movcs	r3, #250	; 0xfa
60005a2a:	850b      	strh	r3, [r1, #40]	; 0x28
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
60005a2c:	4a1e      	ldr	r2, [pc, #120]	; (60005aa8 <cmd_resize+0x178>)
60005a2e:	491c      	ldr	r1, [pc, #112]	; (60005aa0 <cmd_resize+0x170>)
60005a30:	6968      	ldr	r0, [r5, #20]
60005a32:	f005 fc08 	bl	6000b246 <z_shell_raw_fprintf>
	if (err != 0) {
60005a36:	2c00      	cmp	r4, #0
60005a38:	d08a      	beq.n	60005950 <cmd_resize+0x20>
		shell->ctx->vt100_ctx.cons.terminal_hei =
60005a3a:	68ab      	ldr	r3, [r5, #8]
		shell_warn(shell, "No response from the terminal, assumed 80x24"
60005a3c:	2104      	movs	r1, #4
		shell->ctx->vt100_ctx.cons.terminal_hei =
60005a3e:	4a1b      	ldr	r2, [pc, #108]	; (60005aac <cmd_resize+0x17c>)
		shell_warn(shell, "No response from the terminal, assumed 80x24"
60005a40:	4628      	mov	r0, r5
60005a42:	f06f 0407 	mvn.w	r4, #7
		shell->ctx->vt100_ctx.cons.terminal_hei =
60005a46:	629a      	str	r2, [r3, #40]	; 0x28
		shell_warn(shell, "No response from the terminal, assumed 80x24"
60005a48:	4a19      	ldr	r2, [pc, #100]	; (60005ab0 <cmd_resize+0x180>)
60005a4a:	f004 ff26 	bl	6000a89a <shell_fprintf>
		return -ENOEXEC;
60005a4e:	e77f      	b.n	60005950 <cmd_resize+0x20>
					*y = *y * 10U +
60005a50:	eb07 0387 	add.w	r3, r7, r7, lsl #2
					if (buff_idx >=
60005a54:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
					*y = *y * 10U +
60005a58:	eb00 0343 	add.w	r3, r0, r3, lsl #1
60005a5c:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
60005a60:	b29f      	uxth	r7, r3
					if (buff_idx >=
60005a62:	d1c6      	bne.n	600059f2 <cmd_resize+0xc2>
60005a64:	e7ab      	b.n	600059be <cmd_resize+0x8e>
					*x = *x * 10U +
60005a66:	eb03 0383 	add.w	r3, r3, r3, lsl #2
					(shell->ctx->temp_buff[buff_idx++] -
60005a6a:	3601      	adds	r6, #1
					*x = *x * 10U +
60005a6c:	eb04 0443 	add.w	r4, r4, r3, lsl #1
					(shell->ctx->temp_buff[buff_idx++] -
60005a70:	b2b6      	uxth	r6, r6
					*x = *x * 10U +
60005a72:	3c30      	subs	r4, #48	; 0x30
					if (buff_idx >=
60005a74:	2eff      	cmp	r6, #255	; 0xff
					*x = *x * 10U +
60005a76:	b2a3      	uxth	r3, r4
					if (buff_idx >=
60005a78:	d9ca      	bls.n	60005a10 <cmd_resize+0xe0>
60005a7a:	e7a0      	b.n	600059be <cmd_resize+0x8e>
			shell->ctx->temp_buff[buff_idx] = c;
60005a7c:	190a      	adds	r2, r1, r4
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
60005a7e:	3401      	adds	r4, #1
60005a80:	b2a4      	uxth	r4, r4
			shell->ctx->temp_buff[buff_idx] = c;
60005a82:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
60005a86:	2c09      	cmp	r4, #9
60005a88:	d987      	bls.n	6000599a <cmd_resize+0x6a>
				shell->ctx->temp_buff[0] = 0;
60005a8a:	2300      	movs	r3, #0
60005a8c:	f881 313e 	strb.w	r3, [r1, #318]	; 0x13e
				return -ENOMEM;
60005a90:	e795      	b.n	600059be <cmd_resize+0x8e>
60005a92:	bf00      	nop
60005a94:	6000e1e0 	.word	0x6000e1e0
60005a98:	6000e1d7 	.word	0x6000e1d7
60005a9c:	6000e60d 	.word	0x6000e60d
60005aa0:	6000ddaf 	.word	0x6000ddaf
60005aa4:	6000e619 	.word	0x6000e619
60005aa8:	6000e60a 	.word	0x6000e60a
60005aac:	00500018 	.word	0x00500018
60005ab0:	6000e206 	.word	0x6000e206

60005ab4 <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
60005ab4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60005ab8:	4607      	mov	r7, r0
60005aba:	b089      	sub	sp, #36	; 0x24
60005abc:	4615      	mov	r5, r2
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
60005abe:	4689      	mov	r9, r1
60005ac0:	b921      	cbnz	r1, 60005acc <z_shell_wildcard_process+0x18>
		return ret_val;
60005ac2:	2403      	movs	r4, #3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
60005ac4:	4620      	mov	r0, r4
60005ac6:	b009      	add	sp, #36	; 0x24
60005ac8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!z_shell_has_wildcard(pattern)) {
60005acc:	4610      	mov	r0, r2
60005ace:	f005 fe1b 	bl	6000b708 <z_shell_has_wildcard>
60005ad2:	2800      	cmp	r0, #0
60005ad4:	d0f5      	beq.n	60005ac2 <z_shell_wildcard_process+0xe>
	size_t cnt = 0;
60005ad6:	f04f 0800 	mov.w	r8, #0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
60005ada:	2402      	movs	r4, #2
	size_t cmd_idx = 0;
60005adc:	4641      	mov	r1, r8
60005ade:	e024      	b.n	60005b2a <z_shell_wildcard_process+0x76>
	return str == NULL ? 0U : (uint16_t)strlen(str);
60005ae0:	465c      	mov	r4, fp
60005ae2:	e03c      	b.n	60005b5e <z_shell_wildcard_process+0xaa>
	completion_addr = strstr(buff, pattern);
60005ae4:	4629      	mov	r1, r5
60005ae6:	f50a 709f 	add.w	r0, sl, #318	; 0x13e
60005aea:	f005 fe93 	bl	6000b814 <strstr>
	if (!completion_addr) {
60005aee:	4606      	mov	r6, r0
60005af0:	2800      	cmp	r0, #0
60005af2:	d04e      	beq.n	60005b92 <z_shell_wildcard_process+0xde>
60005af4:	f005 fed7 	bl	6000b8a6 <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
60005af8:	4631      	mov	r1, r6
60005afa:	b282      	uxth	r2, r0
60005afc:	1c60      	adds	r0, r4, #1
			cnt++;
60005afe:	f108 0801 	add.w	r8, r8, #1
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
60005b02:	3201      	adds	r2, #1
60005b04:	4430      	add	r0, r6
60005b06:	f005 ff0c 	bl	6000b922 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
60005b0a:	4622      	mov	r2, r4
60005b0c:	4659      	mov	r1, fp
60005b0e:	4630      	mov	r0, r6
60005b10:	f005 ff1f 	bl	6000b952 <memcpy>
	completion_addr[cmd_len] = ' ';
60005b14:	f04f 0320 	mov.w	r3, #32
60005b18:	5533      	strb	r3, [r6, r4]
	*buff_len += cmd_len + 1; /* + 1 for space */
60005b1a:	f8ba 003c 	ldrh.w	r0, [sl, #60]	; 0x3c
60005b1e:	4404      	add	r4, r0
60005b20:	3401      	adds	r4, #1
60005b22:	f8aa 403c 	strh.w	r4, [sl, #60]	; 0x3c
			ret_val = command_add(shell->ctx->temp_buff,
60005b26:	2400      	movs	r4, #0
60005b28:	9901      	ldr	r1, [sp, #4]
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
60005b2a:	1c4b      	adds	r3, r1, #1
60005b2c:	aa03      	add	r2, sp, #12
60005b2e:	4648      	mov	r0, r9
60005b30:	9301      	str	r3, [sp, #4]
60005b32:	f7ff fb7d 	bl	60005230 <z_shell_cmd_get>
60005b36:	4606      	mov	r6, r0
60005b38:	b1f8      	cbz	r0, 60005b7a <z_shell_wildcard_process+0xc6>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
60005b3a:	2200      	movs	r2, #0
60005b3c:	6831      	ldr	r1, [r6, #0]
60005b3e:	4628      	mov	r0, r5
60005b40:	f004 fa12 	bl	60009f68 <fnmatch>
60005b44:	2800      	cmp	r0, #0
60005b46:	d1ef      	bne.n	60005b28 <z_shell_wildcard_process+0x74>
			ret_val = command_add(shell->ctx->temp_buff,
60005b48:	f8d6 b000 	ldr.w	fp, [r6]
60005b4c:	f8d7 a008 	ldr.w	sl, [r7, #8]
60005b50:	f1bb 0f00 	cmp.w	fp, #0
60005b54:	d0c4      	beq.n	60005ae0 <z_shell_wildcard_process+0x2c>
60005b56:	4658      	mov	r0, fp
60005b58:	f005 fea5 	bl	6000b8a6 <strlen>
60005b5c:	b284      	uxth	r4, r0
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
60005b5e:	f8ba 203c 	ldrh.w	r2, [sl, #60]	; 0x3c
60005b62:	3201      	adds	r2, #1
60005b64:	4422      	add	r2, r4
60005b66:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
60005b6a:	ddbb      	ble.n	60005ae4 <z_shell_wildcard_process+0x30>
			ret_val = command_add(shell->ctx->temp_buff,
60005b6c:	2401      	movs	r4, #1
				z_shell_fprintf(shell, SHELL_WARNING,
60005b6e:	462b      	mov	r3, r5
60005b70:	4a09      	ldr	r2, [pc, #36]	; (60005b98 <z_shell_wildcard_process+0xe4>)
60005b72:	2104      	movs	r1, #4
60005b74:	4638      	mov	r0, r7
60005b76:	f005 fa1a 	bl	6000afae <z_shell_fprintf>
	if (cnt > 0) {
60005b7a:	f1b8 0f00 	cmp.w	r8, #0
60005b7e:	d0a1      	beq.n	60005ac4 <z_shell_wildcard_process+0x10>
		z_shell_pattern_remove(shell->ctx->temp_buff,
60005b80:	68b8      	ldr	r0, [r7, #8]
60005b82:	462a      	mov	r2, r5
60005b84:	f100 013c 	add.w	r1, r0, #60	; 0x3c
60005b88:	f500 709f 	add.w	r0, r0, #318	; 0x13e
60005b8c:	f004 ffbe 	bl	6000ab0c <z_shell_pattern_remove>
	return ret_val;
60005b90:	e798      	b.n	60005ac4 <z_shell_wildcard_process+0x10>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
60005b92:	2402      	movs	r4, #2
60005b94:	e7f1      	b.n	60005b7a <z_shell_wildcard_process+0xc6>
60005b96:	bf00      	nop
60005b98:	6000e61e 	.word	0x6000e61e

60005b9c <set_thread_name>:
#define THREAD_NAME_LEN 20
#endif


static void set_thread_name(char *name, struct k_thread *thread)
{
60005b9c:	b537      	push	{r0, r1, r2, r4, r5, lr}
60005b9e:	4604      	mov	r4, r0
	const char *tname = k_thread_name_get(thread);
60005ba0:	4608      	mov	r0, r1
{
60005ba2:	460d      	mov	r5, r1
	const char *tname = k_thread_name_get(thread);
60005ba4:	f006 fb1d 	bl	6000c1e2 <k_thread_name_get>

	if (tname != NULL && tname[0] != '\0') {
60005ba8:	4601      	mov	r1, r0
60005baa:	b148      	cbz	r0, 60005bc0 <set_thread_name+0x24>
60005bac:	7803      	ldrb	r3, [r0, #0]
60005bae:	b13b      	cbz	r3, 60005bc0 <set_thread_name+0x24>
		memcpy(name, tname, THREAD_NAME_LEN);
60005bb0:	2220      	movs	r2, #32
60005bb2:	4620      	mov	r0, r4
60005bb4:	f005 fecd 	bl	6000b952 <memcpy>
		name[THREAD_NAME_LEN - 1] = '\0';
60005bb8:	2300      	movs	r3, #0
60005bba:	77e3      	strb	r3, [r4, #31]
	} else {
		snprintk(name, THREAD_NAME_LEN, "T%pE%p",
		thread, &thread->entry);
	}
}
60005bbc:	b003      	add	sp, #12
60005bbe:	bd30      	pop	{r4, r5, pc}
		snprintk(name, THREAD_NAME_LEN, "T%pE%p",
60005bc0:	f105 036c 	add.w	r3, r5, #108	; 0x6c
60005bc4:	4a03      	ldr	r2, [pc, #12]	; (60005bd4 <set_thread_name+0x38>)
60005bc6:	2120      	movs	r1, #32
60005bc8:	4620      	mov	r0, r4
60005bca:	9300      	str	r3, [sp, #0]
60005bcc:	462b      	mov	r3, r5
60005bce:	f003 fe8f 	bl	600098f0 <snprintk>
}
60005bd2:	e7f3      	b.n	60005bbc <set_thread_name+0x20>
60005bd4:	6000e670 	.word	0x6000e670

60005bd8 <send_task_list_cb>:
				   CONFIG_SOC_SERIES " " CONFIG_ARCH);
	SEGGER_SYSVIEW_SendSysDesc("O=Zephyr");
}

static void send_task_list_cb(void)
{
60005bd8:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread;

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
60005bda:	4b0f      	ldr	r3, [pc, #60]	; (60005c18 <send_task_list_cb+0x40>)
{
60005bdc:	b08e      	sub	sp, #56	; 0x38
		char name[THREAD_NAME_LEN];

		if (z_is_idle_thread_object(thread)) {
60005bde:	4e0f      	ldr	r6, [pc, #60]	; (60005c1c <send_task_list_cb+0x44>)
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
60005be0:	6adc      	ldr	r4, [r3, #44]	; 0x2c
			continue;
		}

		set_thread_name(name, thread);
60005be2:	ad06      	add	r5, sp, #24
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
60005be4:	b90c      	cbnz	r4, 60005bea <send_task_list_cb+0x12>
			.StackSize = thread->stack_info.size,
			.StackBase = thread->stack_info.start,
			.Prio = thread->base.prio,
		});
	}
}
60005be6:	b00e      	add	sp, #56	; 0x38
60005be8:	bd70      	pop	{r4, r5, r6, pc}
		if (z_is_idle_thread_object(thread)) {
60005bea:	42b4      	cmp	r4, r6
60005bec:	d011      	beq.n	60005c12 <send_task_list_cb+0x3a>
		set_thread_name(name, thread);
60005bee:	4628      	mov	r0, r5
60005bf0:	4621      	mov	r1, r4
60005bf2:	f7ff ffd3 	bl	60005b9c <set_thread_name>
			.Prio = thread->base.prio,
60005bf6:	f994 300e 	ldrsb.w	r3, [r4, #14]
		SEGGER_SYSVIEW_SendTaskInfo(&(SEGGER_SYSVIEW_TASKINFO) {
60005bfa:	a801      	add	r0, sp, #4
			.Prio = thread->base.prio,
60005bfc:	9303      	str	r3, [sp, #12]
		SEGGER_SYSVIEW_SendTaskInfo(&(SEGGER_SYSVIEW_TASKINFO) {
60005bfe:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
60005c02:	9304      	str	r3, [sp, #16]
60005c04:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
60005c08:	e9cd 4501 	strd	r4, r5, [sp, #4]
60005c0c:	9305      	str	r3, [sp, #20]
60005c0e:	f001 fe65 	bl	600078dc <SEGGER_SYSVIEW_SendTaskInfo>
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
60005c12:	6fe4      	ldr	r4, [r4, #124]	; 0x7c
60005c14:	e7e6      	b.n	60005be4 <send_task_list_cb+0xc>
60005c16:	bf00      	nop
60005c18:	80000ef4 	.word	0x80000ef4
60005c1c:	80000760 	.word	0x80000760

60005c20 <cbSendSystemDesc>:
{
60005c20:	b508      	push	{r3, lr}
	SEGGER_SYSVIEW_SendSysDesc("N=ZephyrSysView");
60005c22:	4805      	ldr	r0, [pc, #20]	; (60005c38 <cbSendSystemDesc+0x18>)
60005c24:	f001 fec8 	bl	600079b8 <SEGGER_SYSVIEW_SendSysDesc>
	SEGGER_SYSVIEW_SendSysDesc("D=" CONFIG_BOARD " "
60005c28:	4804      	ldr	r0, [pc, #16]	; (60005c3c <cbSendSystemDesc+0x1c>)
60005c2a:	f001 fec5 	bl	600079b8 <SEGGER_SYSVIEW_SendSysDesc>
	SEGGER_SYSVIEW_SendSysDesc("O=Zephyr");
60005c2e:	4804      	ldr	r0, [pc, #16]	; (60005c40 <cbSendSystemDesc+0x20>)
}
60005c30:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SEGGER_SYSVIEW_SendSysDesc("O=Zephyr");
60005c34:	f001 bec0 	b.w	600079b8 <SEGGER_SYSVIEW_SendSysDesc>
60005c38:	6000e677 	.word	0x6000e677
60005c3c:	6000e687 	.word	0x6000e687
60005c40:	6000e69f 	.word	0x6000e69f

60005c44 <SEGGER_SYSVIEW_Conf>:



void SEGGER_SYSVIEW_Conf(void)
{
	SEGGER_SYSVIEW_Init(sys_clock_hw_cycles_per_sec(),
60005c44:	4906      	ldr	r1, [pc, #24]	; (60005c60 <SEGGER_SYSVIEW_Conf+0x1c>)
60005c46:	4a07      	ldr	r2, [pc, #28]	; (60005c64 <SEGGER_SYSVIEW_Conf+0x20>)
60005c48:	4608      	mov	r0, r1
{
60005c4a:	b508      	push	{r3, lr}
	SEGGER_SYSVIEW_Init(sys_clock_hw_cycles_per_sec(),
60005c4c:	4b06      	ldr	r3, [pc, #24]	; (60005c68 <SEGGER_SYSVIEW_Conf+0x24>)
60005c4e:	f001 fb87 	bl	60007360 <SEGGER_SYSVIEW_Init>
			    sys_clock_hw_cycles_per_sec(),
			    &SYSVIEW_X_OS_TraceAPI, cbSendSystemDesc);
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_sram), okay)
	SEGGER_SYSVIEW_SetRAMBase(DT_REG_ADDR(DT_CHOSEN(zephyr_sram)));
60005c52:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
	/* Setting RAMBase is just an optimization: this value is subtracted
	 * from all pointers in order to save bandwidth.  It's not an error
	 * if a platform does not set this value.
	 */
#endif
}
60005c56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SEGGER_SYSVIEW_SetRAMBase(DT_REG_ADDR(DT_CHOSEN(zephyr_sram)));
60005c5a:	f001 bbb7 	b.w	600073cc <SEGGER_SYSVIEW_SetRAMBase>
60005c5e:	bf00      	nop
60005c60:	23c34600 	.word	0x23c34600
60005c64:	6000d5c0 	.word	0x6000d5c0
60005c68:	60005c21 	.word	0x60005c21

60005c6c <sysview_get_interrupt>:
}

uint32_t sysview_get_interrupt(void)
{
#ifdef CONFIG_CPU_CORTEX_M
	interrupt = ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) >>
60005c6c:	4b02      	ldr	r3, [pc, #8]	; (60005c78 <sysview_get_interrupt+0xc>)
60005c6e:	6858      	ldr	r0, [r3, #4]
		     SCB_ICSR_VECTACTIVE_Pos);
#endif
	return interrupt;
}
60005c70:	f3c0 0008 	ubfx	r0, r0, #0, #9
60005c74:	4770      	bx	lr
60005c76:	bf00      	nop
60005c78:	e000ed00 	.word	0xe000ed00

60005c7c <sys_trace_k_thread_switched_in>:

void sys_trace_k_thread_switched_in(void)
{
60005c7c:	b508      	push	{r3, lr}
	return z_impl_k_current_get();
60005c7e:	f003 f945 	bl	60008f0c <z_impl_k_current_get>
	struct k_thread *thread;

	thread = k_current_get();

	if (z_is_idle_thread_object(thread)) {
60005c82:	4b05      	ldr	r3, [pc, #20]	; (60005c98 <sys_trace_k_thread_switched_in+0x1c>)
60005c84:	4283      	cmp	r3, r0
60005c86:	d103      	bne.n	60005c90 <sys_trace_k_thread_switched_in+0x14>
		SEGGER_SYSVIEW_OnIdle();
	} else {
		SEGGER_SYSVIEW_OnTaskStartExec((uint32_t)(uintptr_t)thread);
	}
}
60005c88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		SEGGER_SYSVIEW_OnIdle();
60005c8c:	f001 bf3c 	b.w	60007b08 <SEGGER_SYSVIEW_OnIdle>
}
60005c90:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		SEGGER_SYSVIEW_OnTaskStartExec((uint32_t)(uintptr_t)thread);
60005c94:	f001 bf76 	b.w	60007b84 <SEGGER_SYSVIEW_OnTaskStartExec>
60005c98:	80000760 	.word	0x80000760

60005c9c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
60005c9c:	b510      	push	{r4, lr}
60005c9e:	4807      	ldr	r0, [pc, #28]	; (60005cbc <uart_console_init+0x20>)
60005ca0:	f002 f87c 	bl	60007d9c <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
60005ca4:	4c06      	ldr	r4, [pc, #24]	; (60005cc0 <uart_console_init+0x24>)

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
60005ca6:	4b07      	ldr	r3, [pc, #28]	; (60005cc4 <uart_console_init+0x28>)
60005ca8:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
60005caa:	4620      	mov	r0, r4
60005cac:	f000 ff10 	bl	60006ad0 <__stdout_hook_install>
	__printk_hook_install(console_out);
60005cb0:	4620      	mov	r0, r4
60005cb2:	f7fc fd73 	bl	6000279c <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
60005cb6:	2000      	movs	r0, #0
60005cb8:	bd10      	pop	{r4, pc}
60005cba:	bf00      	nop
60005cbc:	6000e156 	.word	0x6000e156
60005cc0:	60005cc9 	.word	0x60005cc9
60005cc4:	80000e34 	.word	0x80000e34

60005cc8 <console_out>:
	if ('\n' == c) {
60005cc8:	280a      	cmp	r0, #10
{
60005cca:	b538      	push	{r3, r4, r5, lr}
60005ccc:	4604      	mov	r4, r0
60005cce:	4d07      	ldr	r5, [pc, #28]	; (60005cec <console_out+0x24>)
	if ('\n' == c) {
60005cd0:	d104      	bne.n	60005cdc <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
60005cd2:	6828      	ldr	r0, [r5, #0]
	api->poll_out(dev, out_char);
60005cd4:	6883      	ldr	r3, [r0, #8]
60005cd6:	210d      	movs	r1, #13
60005cd8:	685b      	ldr	r3, [r3, #4]
60005cda:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
60005cdc:	6828      	ldr	r0, [r5, #0]
60005cde:	6883      	ldr	r3, [r0, #8]
60005ce0:	b2e1      	uxtb	r1, r4
60005ce2:	685b      	ldr	r3, [r3, #4]
60005ce4:	4798      	blx	r3
}
60005ce6:	4620      	mov	r0, r4
60005ce8:	bd38      	pop	{r3, r4, r5, pc}
60005cea:	bf00      	nop
60005cec:	80000e34 	.word	0x80000e34

60005cf0 <rtt_console_init>:

	return character;
}

static int rtt_console_init(const struct device *d)
{
60005cf0:	b510      	push	{r4, lr}
	ARG_UNUSED(d);

	__printk_hook_install(rtt_console_out);
60005cf2:	4c04      	ldr	r4, [pc, #16]	; (60005d04 <rtt_console_init+0x14>)
60005cf4:	4620      	mov	r0, r4
60005cf6:	f7fc fd51 	bl	6000279c <__printk_hook_install>
	__stdout_hook_install(rtt_console_out);
60005cfa:	4620      	mov	r0, r4
60005cfc:	f000 fee8 	bl	60006ad0 <__stdout_hook_install>

	return 0;
}
60005d00:	2000      	movs	r0, #0
60005d02:	bd10      	pop	{r4, pc}
60005d04:	60005d09 	.word	0x60005d09

60005d08 <rtt_console_out>:
{
60005d08:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
60005d0c:	4604      	mov	r4, r0
	char c = (char)character;
60005d0e:	2503      	movs	r5, #3
	return z_impl_k_mutex_lock(mutex, timeout);
60005d10:	f8df 8058 	ldr.w	r8, [pc, #88]	; 60005d6c <rtt_console_out+0x64>
60005d14:	4e16      	ldr	r6, [pc, #88]	; (60005d70 <rtt_console_out+0x68>)
60005d16:	f88d 0007 	strb.w	r0, [sp, #7]
60005d1a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60005d1e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60005d22:	4640      	mov	r0, r8
60005d24:	f002 fc86 	bl	60008634 <z_impl_k_mutex_lock>
		cnt = SEGGER_RTT_WriteNoLock(0, &c, 1);
60005d28:	2201      	movs	r2, #1
60005d2a:	f10d 0107 	add.w	r1, sp, #7
60005d2e:	2000      	movs	r0, #0
60005d30:	f001 fa76 	bl	60007220 <SEGGER_RTT_WriteNoLock>
60005d34:	4607      	mov	r7, r0
	return z_impl_k_mutex_unlock(mutex);
60005d36:	4640      	mov	r0, r8
60005d38:	f002 fd06 	bl	60008748 <z_impl_k_mutex_unlock>
		if (cnt) {
60005d3c:	b12f      	cbz	r7, 60005d4a <rtt_console_out+0x42>
			host_present = true;
60005d3e:	2301      	movs	r3, #1
60005d40:	7033      	strb	r3, [r6, #0]
}
60005d42:	4620      	mov	r0, r4
60005d44:	b002      	add	sp, #8
60005d46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (host_present) {
60005d4a:	7833      	ldrb	r3, [r6, #0]
60005d4c:	2b00      	cmp	r3, #0
60005d4e:	d0f8      	beq.n	60005d42 <rtt_console_out+0x3a>
			if (max_cnt) {
60005d50:	3d01      	subs	r5, #1
60005d52:	d008      	beq.n	60005d66 <rtt_console_out+0x5e>
	if (!IS_ENABLED(CONFIG_MULTITHREADING) || k_is_in_isr()) {
60005d54:	f006 fa3f 	bl	6000c1d6 <k_is_in_isr>
60005d58:	2800      	cmp	r0, #0
60005d5a:	d1de      	bne.n	60005d1a <rtt_console_out+0x12>
	return z_impl_k_sleep(timeout);
60005d5c:	2100      	movs	r1, #0
60005d5e:	2014      	movs	r0, #20
60005d60:	f003 f8a6 	bl	60008eb0 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
60005d64:	e7d9      	b.n	60005d1a <rtt_console_out+0x12>
				host_present = false;
60005d66:	7035      	strb	r5, [r6, #0]
60005d68:	e7eb      	b.n	60005d42 <rtt_console_out+0x3a>
60005d6a:	bf00      	nop
60005d6c:	8000024c 	.word	0x8000024c
60005d70:	80000fb6 	.word	0x80000fb6

60005d74 <mcux_ccm_get_subsys_rate>:
				    clock_control_subsys_t sub_system,
				    uint32_t *rate)
{
	uint32_t clock_name = (uint32_t) sub_system;

	switch (clock_name) {
60005d74:	2903      	cmp	r1, #3
{
60005d76:	b538      	push	{r3, r4, r5, lr}
60005d78:	4614      	mov	r4, r2
	switch (clock_name) {
60005d7a:	d110      	bne.n	60005d9e <mcux_ccm_get_subsys_rate+0x2a>
    return (((uint32_t)(CCM_TUPLE_REG(CCM, mux) & CCM_TUPLE_MASK(mux))) >> CCM_TUPLE_SHIFT(mux));
60005d7c:	4d11      	ldr	r5, [pc, #68]	; (60005dc4 <mcux_ccm_get_subsys_rate+0x50>)
60005d7e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	}
#endif

#ifdef CONFIG_UART_MCUX_LPUART
	case IMX_CCM_LPUART_CLK:
		if (CLOCK_GetMux(kCLOCK_UartMux) == 0) {
60005d80:	065a      	lsls	r2, r3, #25
60005d82:	d40e      	bmi.n	60005da2 <mcux_ccm_get_subsys_rate+0x2e>
			*rate = CLOCK_GetPllFreq(kCLOCK_PllUsb1) / 6
60005d84:	4810      	ldr	r0, [pc, #64]	; (60005dc8 <mcux_ccm_get_subsys_rate+0x54>)
60005d86:	f000 ff83 	bl	60006c90 <CLOCK_GetPllFreq>
    return ((uint32_t)(CCM_TUPLE_REG(CCM, divider) & CCM_TUPLE_MASK(divider)) >> CCM_TUPLE_SHIFT(divider));
60005d8a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
60005d8c:	2206      	movs	r2, #6
60005d8e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
60005d92:	fbb0 f0f2 	udiv	r0, r0, r2
				/ (CLOCK_GetDiv(kCLOCK_UartDiv) + 1);
60005d96:	3301      	adds	r3, #1
60005d98:	fbb0 f0f3 	udiv	r0, r0, r3
			*rate = CLOCK_GetPllFreq(kCLOCK_PllUsb1) / 6
60005d9c:	6020      	str	r0, [r4, #0]
#endif

	}

	return 0;
}
60005d9e:	2000      	movs	r0, #0
60005da0:	bd38      	pop	{r3, r4, r5, pc}
    return ((XTALOSC24M->LOWPWR_CTRL & XTALOSC24M_LOWPWR_CTRL_OSC_SEL_MASK) != 0UL) ? 24000000UL : g_xtalFreq;
60005da2:	4b0a      	ldr	r3, [pc, #40]	; (60005dcc <mcux_ccm_get_subsys_rate+0x58>)
60005da4:	f8d3 3270 	ldr.w	r3, [r3, #624]	; 0x270
60005da8:	06db      	lsls	r3, r3, #27
60005daa:	d409      	bmi.n	60005dc0 <mcux_ccm_get_subsys_rate+0x4c>
60005dac:	4b08      	ldr	r3, [pc, #32]	; (60005dd0 <mcux_ccm_get_subsys_rate+0x5c>)
60005dae:	681a      	ldr	r2, [r3, #0]
    return ((uint32_t)(CCM_TUPLE_REG(CCM, divider) & CCM_TUPLE_MASK(divider)) >> CCM_TUPLE_SHIFT(divider));
60005db0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
60005db2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
				/ (CLOCK_GetDiv(kCLOCK_UartDiv) + 1);
60005db6:	3301      	adds	r3, #1
60005db8:	fbb2 f3f3 	udiv	r3, r2, r3
			*rate = CLOCK_GetOscFreq()
60005dbc:	6023      	str	r3, [r4, #0]
60005dbe:	e7ee      	b.n	60005d9e <mcux_ccm_get_subsys_rate+0x2a>
    return ((XTALOSC24M->LOWPWR_CTRL & XTALOSC24M_LOWPWR_CTRL_OSC_SEL_MASK) != 0UL) ? 24000000UL : g_xtalFreq;
60005dc0:	4a04      	ldr	r2, [pc, #16]	; (60005dd4 <mcux_ccm_get_subsys_rate+0x60>)
60005dc2:	e7f5      	b.n	60005db0 <mcux_ccm_get_subsys_rate+0x3c>
60005dc4:	400fc000 	.word	0x400fc000
60005dc8:	0010000d 	.word	0x0010000d
60005dcc:	400d8000 	.word	0x400d8000
60005dd0:	80000ec4 	.word	0x80000ec4
60005dd4:	016e3600 	.word	0x016e3600

60005dd8 <elapsed>:
 *     - and until the current call of the function is completed.
 * - the function is invoked with interrupts disabled.
 */
static uint32_t elapsed(void)
{
	uint32_t val1 = SysTick->VAL;	/* A */
60005dd8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60005ddc:	699a      	ldr	r2, [r3, #24]
	uint32_t ctrl = SysTick->CTRL;	/* B */
60005dde:	6919      	ldr	r1, [r3, #16]
	uint32_t val2 = SysTick->VAL;	/* C */
60005de0:	6998      	ldr	r0, [r3, #24]
	 * 4) After C we'll see it next time
	 *
	 * So the count in val2 is post-wrap and last_load needs to be
	 * added if and only if COUNTFLAG is set or val1 < val2.
	 */
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
60005de2:	f411 3f80 	tst.w	r1, #65536	; 0x10000
60005de6:	4b09      	ldr	r3, [pc, #36]	; (60005e0c <elapsed+0x34>)
60005de8:	4909      	ldr	r1, [pc, #36]	; (60005e10 <elapsed+0x38>)
{
60005dea:	b510      	push	{r4, lr}
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
60005dec:	d101      	bne.n	60005df2 <elapsed+0x1a>
	    || (val1 < val2)) {
60005dee:	4282      	cmp	r2, r0
60005df0:	d206      	bcs.n	60005e00 <elapsed+0x28>
		overflow_cyc += last_load;
60005df2:	681a      	ldr	r2, [r3, #0]
60005df4:	680c      	ldr	r4, [r1, #0]
60005df6:	4422      	add	r2, r4
60005df8:	601a      	str	r2, [r3, #0]

		/* We know there was a wrap, but we might not have
		 * seen it in CTRL, so clear it. */
		(void)SysTick->CTRL;
60005dfa:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
60005dfe:	6912      	ldr	r2, [r2, #16]
	}

	return (last_load - val2) + overflow_cyc;
60005e00:	681b      	ldr	r3, [r3, #0]
60005e02:	680a      	ldr	r2, [r1, #0]
60005e04:	4413      	add	r3, r2
}
60005e06:	1a18      	subs	r0, r3, r0
60005e08:	bd10      	pop	{r4, pc}
60005e0a:	bf00      	nop
60005e0c:	80000e4c 	.word	0x80000e4c
60005e10:	80000e48 	.word	0x80000e48

60005e14 <sys_clock_isr>:

/* Callout out of platform assembly, not hooked via IRQ_CONNECT... */
void sys_clock_isr(void *arg)
{
60005e14:	b508      	push	{r3, lr}
	ARG_UNUSED(arg);
	uint32_t dticks;

	/* Update overflow_cyc and clear COUNTFLAG by invoking elapsed() */
	elapsed();
60005e16:	f7ff ffdf 	bl	60005dd8 <elapsed>

	/* Increment the amount of HW cycles elapsed (complete counter
	 * cycles) and announce the progress to the kernel.
	 */
	cycle_count += overflow_cyc;
60005e1a:	4b0c      	ldr	r3, [pc, #48]	; (60005e4c <sys_clock_isr+0x38>)
60005e1c:	4a0c      	ldr	r2, [pc, #48]	; (60005e50 <sys_clock_isr+0x3c>)
60005e1e:	6818      	ldr	r0, [r3, #0]
60005e20:	6811      	ldr	r1, [r2, #0]
60005e22:	4408      	add	r0, r1
		 * because the value has been updated before LOAD re-program.
		 *
		 * We can assess if this is the case by inspecting COUNTFLAG.
		 */

		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
60005e24:	f64e 2160 	movw	r1, #60000	; 0xea60
	cycle_count += overflow_cyc;
60005e28:	6010      	str	r0, [r2, #0]
	overflow_cyc = 0;
60005e2a:	2200      	movs	r2, #0
60005e2c:	601a      	str	r2, [r3, #0]
		dticks = (cycle_count - announced_cycles) / CYC_PER_TICK;
60005e2e:	4a09      	ldr	r2, [pc, #36]	; (60005e54 <sys_clock_isr+0x40>)
60005e30:	6813      	ldr	r3, [r2, #0]
60005e32:	1ac0      	subs	r0, r0, r3
60005e34:	fbb0 f0f1 	udiv	r0, r0, r1
		announced_cycles += dticks * CYC_PER_TICK;
60005e38:	fb01 3300 	mla	r3, r1, r0, r3
60005e3c:	6013      	str	r3, [r2, #0]
		sys_clock_announce(dticks);
60005e3e:	f003 fa33 	bl	600092a8 <sys_clock_announce>
	} else {
		sys_clock_announce(1);
	}
	z_arm_int_exit();
}
60005e42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
60005e46:	f000 bd29 	b.w	6000689c <z_arm_exc_exit>
60005e4a:	bf00      	nop
60005e4c:	80000e4c 	.word	0x80000e4c
60005e50:	80000e44 	.word	0x80000e44
60005e54:	80000e40 	.word	0x80000e40

60005e58 <sys_clock_driver_init>:
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60005e58:	4b09      	ldr	r3, [pc, #36]	; (60005e80 <sys_clock_driver_init+0x28>)
60005e5a:	2210      	movs	r2, #16
{
	ARG_UNUSED(dev);

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
	overflow_cyc = 0U;
60005e5c:	2000      	movs	r0, #0
60005e5e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	last_load = CYC_PER_TICK - 1;
60005e62:	f64e 225f 	movw	r2, #59999	; 0xea5f
60005e66:	4b07      	ldr	r3, [pc, #28]	; (60005e84 <sys_clock_driver_init+0x2c>)
60005e68:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
60005e6a:	4b07      	ldr	r3, [pc, #28]	; (60005e88 <sys_clock_driver_init+0x30>)
60005e6c:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
60005e6e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60005e72:	615a      	str	r2, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
60005e74:	6198      	str	r0, [r3, #24]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
60005e76:	691a      	ldr	r2, [r3, #16]
60005e78:	f042 0207 	orr.w	r2, r2, #7
60005e7c:	611a      	str	r2, [r3, #16]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
60005e7e:	4770      	bx	lr
60005e80:	e000ed00 	.word	0xe000ed00
60005e84:	80000e48 	.word	0x80000e48
60005e88:	80000e4c 	.word	0x80000e4c

60005e8c <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
60005e8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60005e8e:	4d32      	ldr	r5, [pc, #200]	; (60005f58 <sys_clock_set_timeout+0xcc>)
	 * need to wake up multiple times per second.  If the kernel
	 * allows us to miss tick announcements in idle, then shut off
	 * the counter. (Note: we can assume if idle==true that
	 * interrupts are already disabled)
	 */
	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
60005e90:	b159      	cbz	r1, 60005eaa <sys_clock_set_timeout+0x1e>
60005e92:	1c42      	adds	r2, r0, #1
60005e94:	d109      	bne.n	60005eaa <sys_clock_set_timeout+0x1e>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
60005e96:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
60005e9a:	6913      	ldr	r3, [r2, #16]
60005e9c:	f023 0301 	bic.w	r3, r3, #1
60005ea0:	6113      	str	r3, [r2, #16]
		last_load = TIMER_STOPPED;
60005ea2:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
60005ea6:	602b      	str	r3, [r5, #0]
	} else {
		cycle_count += (val1 - val2);
	}
	k_spin_unlock(&lock, key);
#endif
}
60005ea8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
60005eaa:	1c43      	adds	r3, r0, #1
	uint32_t last_load_ = last_load;
60005eac:	682f      	ldr	r7, [r5, #0]
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
60005eae:	bf08      	it	eq
60005eb0:	f44f 708b 	moveq.w	r0, #278	; 0x116
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
60005eb4:	1e44      	subs	r4, r0, #1
60005eb6:	2c00      	cmp	r4, #0
60005eb8:	dd35      	ble.n	60005f26 <sys_clock_set_timeout+0x9a>
60005eba:	f5b4 7f8b 	cmp.w	r4, #278	; 0x116
60005ebe:	bfa8      	it	ge
60005ec0:	f44f 748b 	movge.w	r4, #278	; 0x116
	__asm__ volatile(
60005ec4:	f04f 0310 	mov.w	r3, #16
60005ec8:	f3ef 8611 	mrs	r6, BASEPRI
60005ecc:	f383 8811 	msr	BASEPRI, r3
60005ed0:	f3bf 8f6f 	isb	sy
	uint32_t pending = elapsed();
60005ed4:	f7ff ff80 	bl	60005dd8 <elapsed>
	val1 = SysTick->VAL;
60005ed8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
	cycle_count += pending;
60005edc:	491f      	ldr	r1, [pc, #124]	; (60005f5c <sys_clock_set_timeout+0xd0>)
	overflow_cyc = 0U;
60005ede:	2200      	movs	r2, #0
	val1 = SysTick->VAL;
60005ee0:	f8d3 c018 	ldr.w	ip, [r3, #24]
	cycle_count += pending;
60005ee4:	680b      	ldr	r3, [r1, #0]
60005ee6:	4418      	add	r0, r3
	overflow_cyc = 0U;
60005ee8:	4b1d      	ldr	r3, [pc, #116]	; (60005f60 <sys_clock_set_timeout+0xd4>)
60005eea:	601a      	str	r2, [r3, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
60005eec:	4b1d      	ldr	r3, [pc, #116]	; (60005f64 <sys_clock_set_timeout+0xd8>)
	cycle_count += pending;
60005eee:	6008      	str	r0, [r1, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
60005ef0:	681b      	ldr	r3, [r3, #0]
	if ((int32_t)unannounced < 0) {
60005ef2:	1ac2      	subs	r2, r0, r3
60005ef4:	d519      	bpl.n	60005f2a <sys_clock_set_timeout+0x9e>
		last_load = MIN_DELAY;
60005ef6:	f640 63a6 	movw	r3, #3750	; 0xea6
			last_load = MAX_CYCLES;
60005efa:	602b      	str	r3, [r5, #0]
	val2 = SysTick->VAL;
60005efc:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
	SysTick->LOAD = last_load - 1;
60005f00:	682c      	ldr	r4, [r5, #0]
	val2 = SysTick->VAL;
60005f02:	6993      	ldr	r3, [r2, #24]
	SysTick->LOAD = last_load - 1;
60005f04:	3c01      	subs	r4, #1
	if (val1 < val2) {
60005f06:	459c      	cmp	ip, r3
	SysTick->LOAD = last_load - 1;
60005f08:	6154      	str	r4, [r2, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
60005f0a:	f04f 0400 	mov.w	r4, #0
		cycle_count += (val1 + (last_load_ - val2));
60005f0e:	bf38      	it	cc
60005f10:	44bc      	addcc	ip, r7
	SysTick->VAL = 0; /* resets timer to last_load */
60005f12:	6194      	str	r4, [r2, #24]
		cycle_count += (val1 - val2);
60005f14:	ebac 0c03 	sub.w	ip, ip, r3
60005f18:	4460      	add	r0, ip
60005f1a:	6008      	str	r0, [r1, #0]
	__asm__ volatile(
60005f1c:	f386 8811 	msr	BASEPRI, r6
60005f20:	f3bf 8f6f 	isb	sy
60005f24:	e7c0      	b.n	60005ea8 <sys_clock_set_timeout+0x1c>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
60005f26:	2400      	movs	r4, #0
60005f28:	e7cc      	b.n	60005ec4 <sys_clock_set_timeout+0x38>
		delay = ticks * CYC_PER_TICK;
60005f2a:	f64e 2e60 	movw	lr, #60000	; 0xea60
		delay -= unannounced;
60005f2e:	1a1b      	subs	r3, r3, r0
		delay += unannounced;
60005f30:	fb0e 2404 	mla	r4, lr, r4, r2
		 ((delay + CYC_PER_TICK - 1) / CYC_PER_TICK) * CYC_PER_TICK;
60005f34:	f504 446a 	add.w	r4, r4, #59904	; 0xea00
60005f38:	345f      	adds	r4, #95	; 0x5f
60005f3a:	fbb4 f4fe 	udiv	r4, r4, lr
		delay -= unannounced;
60005f3e:	fb0e 3404 	mla	r4, lr, r4, r3
		delay = MAX(delay, MIN_DELAY);
60005f42:	f640 63a6 	movw	r3, #3750	; 0xea6
60005f46:	429c      	cmp	r4, r3
60005f48:	d904      	bls.n	60005f54 <sys_clock_set_timeout+0xc8>
		if (delay > MAX_CYCLES) {
60005f4a:	4b07      	ldr	r3, [pc, #28]	; (60005f68 <sys_clock_set_timeout+0xdc>)
60005f4c:	429c      	cmp	r4, r3
60005f4e:	d8d4      	bhi.n	60005efa <sys_clock_set_timeout+0x6e>
			last_load = delay;
60005f50:	602c      	str	r4, [r5, #0]
60005f52:	e7d3      	b.n	60005efc <sys_clock_set_timeout+0x70>
		delay = MAX(delay, MIN_DELAY);
60005f54:	461c      	mov	r4, r3
60005f56:	e7fb      	b.n	60005f50 <sys_clock_set_timeout+0xc4>
60005f58:	80000e48 	.word	0x80000e48
60005f5c:	80000e44 	.word	0x80000e44
60005f60:	80000e4c 	.word	0x80000e4c
60005f64:	80000e40 	.word	0x80000e40
60005f68:	00fe8440 	.word	0x00fe8440

60005f6c <sys_clock_elapsed>:

uint32_t sys_clock_elapsed(void)
{
60005f6c:	b510      	push	{r4, lr}
	__asm__ volatile(
60005f6e:	f04f 0310 	mov.w	r3, #16
60005f72:	f3ef 8411 	mrs	r4, BASEPRI
60005f76:	f383 8811 	msr	BASEPRI, r3
60005f7a:	f3bf 8f6f 	isb	sy
	if (!TICKLESS) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t cyc = elapsed() + cycle_count - announced_cycles;
60005f7e:	f7ff ff2b 	bl	60005dd8 <elapsed>
60005f82:	4b07      	ldr	r3, [pc, #28]	; (60005fa0 <sys_clock_elapsed+0x34>)
60005f84:	4a07      	ldr	r2, [pc, #28]	; (60005fa4 <sys_clock_elapsed+0x38>)
60005f86:	681b      	ldr	r3, [r3, #0]
60005f88:	6812      	ldr	r2, [r2, #0]
60005f8a:	1a9b      	subs	r3, r3, r2
60005f8c:	4403      	add	r3, r0
	__asm__ volatile(
60005f8e:	f384 8811 	msr	BASEPRI, r4
60005f92:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return cyc / CYC_PER_TICK;
}
60005f96:	f64e 2060 	movw	r0, #60000	; 0xea60
60005f9a:	fbb3 f0f0 	udiv	r0, r3, r0
60005f9e:	bd10      	pop	{r4, pc}
60005fa0:	80000e44 	.word	0x80000e44
60005fa4:	80000e40 	.word	0x80000e40

60005fa8 <sys_clock_cycle_get_32>:

uint32_t sys_clock_cycle_get_32(void)
{
60005fa8:	b510      	push	{r4, lr}
	__asm__ volatile(
60005faa:	f04f 0310 	mov.w	r3, #16
60005fae:	f3ef 8411 	mrs	r4, BASEPRI
60005fb2:	f383 8811 	msr	BASEPRI, r3
60005fb6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = elapsed() + cycle_count;
60005fba:	f7ff ff0d 	bl	60005dd8 <elapsed>
60005fbe:	4b04      	ldr	r3, [pc, #16]	; (60005fd0 <sys_clock_cycle_get_32+0x28>)
60005fc0:	681b      	ldr	r3, [r3, #0]
60005fc2:	4418      	add	r0, r3
	__asm__ volatile(
60005fc4:	f384 8811 	msr	BASEPRI, r4
60005fc8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
60005fcc:	bd10      	pop	{r4, pc}
60005fce:	bf00      	nop
60005fd0:	80000e44 	.word	0x80000e44

60005fd4 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
60005fd4:	4a0a      	ldr	r2, [pc, #40]	; (60006000 <arch_swap+0x2c>)
	_current->arch.swap_return_value = _k_neg_eagain;
60005fd6:	490b      	ldr	r1, [pc, #44]	; (60006004 <arch_swap+0x30>)
	_current->arch.basepri = key;
60005fd8:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
60005fda:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
60005fdc:	f8c3 00b4 	str.w	r0, [r3, #180]	; 0xb4
	_current->arch.swap_return_value = _k_neg_eagain;
60005fe0:	f8c3 10b8 	str.w	r1, [r3, #184]	; 0xb8

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
60005fe4:	4908      	ldr	r1, [pc, #32]	; (60006008 <arch_swap+0x34>)
60005fe6:	684b      	ldr	r3, [r1, #4]
60005fe8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
60005fec:	604b      	str	r3, [r1, #4]
60005fee:	2300      	movs	r3, #0
60005ff0:	f383 8811 	msr	BASEPRI, r3
60005ff4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
60005ff8:	6893      	ldr	r3, [r2, #8]
}
60005ffa:	f8d3 00b8 	ldr.w	r0, [r3, #184]	; 0xb8
60005ffe:	4770      	bx	lr
60006000:	80000ef4 	.word	0x80000ef4
60006004:	6000d6ec 	.word	0x6000d6ec
60006008:	e000ed00 	.word	0xe000ed00

6000600c <z_arm_pendsv>:

SECTION_FUNC(TEXT, z_arm_pendsv)

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
    /* Register the context switch */
    push {r0, lr}
6000600c:	b501      	push	{r0, lr}
    bl z_thread_mark_switched_out
6000600e:	f006 f905 	bl	6000c21c <z_thread_mark_switched_out>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    pop {r0, r1}
    mov lr, r1
#else
    pop {r0, lr}
60006012:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
60006016:	4916      	ldr	r1, [pc, #88]	; (60006070 <z_arm_pendsv+0x64>)
    ldr r2, [r1, #_kernel_offset_to_current]
60006018:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
6000601a:	f04f 0038 	mov.w	r0, #56	; 0x38
    add r0, r2
6000601e:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
60006020:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
60006024:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
60006028:	2010      	movs	r0, #16
    msr BASEPRI, r0
6000602a:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
6000602e:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
60006032:	4f10      	ldr	r7, [pc, #64]	; (60006074 <z_arm_pendsv+0x68>)
    ldr v3, =_SCS_ICSR_UNPENDSV
60006034:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
60006038:	6a0a      	ldr	r2, [r1, #32]

    str r2, [r1, #_kernel_offset_to_current]
6000603a:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
6000603c:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
6000603e:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    movs r3, #0
60006042:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
60006044:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
60006048:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
6000604c:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
6000604e:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
60006050:	f000 fc5c 	bl	6000690c <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
60006054:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
60006058:	f102 0038 	add.w	r0, r2, #56	; 0x38
    ldmia r0, {v1-v8, ip}
6000605c:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
60006060:	f38c 8809 	msr	PSP, ip
    pop {r2, lr}
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
    /* Register the context switch */
    push {r0, lr}
60006064:	b501      	push	{r0, lr}
    bl z_thread_mark_switched_in
60006066:	f006 f8d7 	bl	6000c218 <z_thread_mark_switched_in>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    pop {r0, r1}
    mov lr, r1
#else
    pop {r0, lr}
6000606a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
6000606e:	4770      	bx	lr
    ldr r1, =_kernel
60006070:	80000ef4 	.word	0x80000ef4
    ldr v4, =_SCS_ICSR
60006074:	e000ed04 	.word	0xe000ed04

60006078 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
60006078:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
6000607c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
6000607e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
60006082:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
60006086:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
60006088:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
6000608c:	2902      	cmp	r1, #2
    beq _oops
6000608e:	d0ff      	beq.n	60006090 <_oops>

60006090 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
60006090:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
60006092:	f005 fbb4 	bl	6000b7fe <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
60006096:	bd01      	pop	{r0, pc}

60006098 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
60006098:	b203      	sxth	r3, r0
  if ((int32_t)(IRQn) >= 0)
6000609a:	2b00      	cmp	r3, #0
6000609c:	db08      	blt.n	600060b0 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
6000609e:	2201      	movs	r2, #1
600060a0:	f000 001f 	and.w	r0, r0, #31
600060a4:	095b      	lsrs	r3, r3, #5
600060a6:	fa02 f000 	lsl.w	r0, r2, r0
600060aa:	4a02      	ldr	r2, [pc, #8]	; (600060b4 <arch_irq_enable+0x1c>)
600060ac:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
600060b0:	4770      	bx	lr
600060b2:	bf00      	nop
600060b4:	e000e100 	.word	0xe000e100

600060b8 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
600060b8:	b203      	sxth	r3, r0
		prio += _IRQ_PRIO_OFFSET;
600060ba:	3101      	adds	r1, #1
  if ((int32_t)(IRQn) >= 0)
600060bc:	2b00      	cmp	r3, #0
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
600060be:	ea4f 1101 	mov.w	r1, r1, lsl #4
600060c2:	b2c9      	uxtb	r1, r1
  if ((int32_t)(IRQn) >= 0)
600060c4:	db06      	blt.n	600060d4 <z_arm_irq_priority_set+0x1c>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
600060c6:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
600060ca:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
600060ce:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
600060d2:	4770      	bx	lr
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
600060d4:	f000 000f 	and.w	r0, r0, #15
600060d8:	4b01      	ldr	r3, [pc, #4]	; (600060e0 <z_arm_irq_priority_set+0x28>)
600060da:	5419      	strb	r1, [r3, r0]
}
600060dc:	4770      	bx	lr
600060de:	bf00      	nop
600060e0:	e000ed14 	.word	0xe000ed14

600060e4 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
600060e4:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
600060e8:	3a20      	subs	r2, #32
	iframe->a2 = (uint32_t)p1;
600060ea:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
600060ec:	4908      	ldr	r1, [pc, #32]	; (60006110 <arch_new_thread+0x2c>)
	iframe->a2 = (uint32_t)p1;
600060ee:	6053      	str	r3, [r2, #4]
	iframe->a3 = (uint32_t)p2;
600060f0:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
600060f2:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
600060f6:	6093      	str	r3, [r2, #8]
	iframe->a4 = (uint32_t)p3;
600060f8:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
600060fa:	6191      	str	r1, [r2, #24]
	iframe->a4 = (uint32_t)p3;
600060fc:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
600060fe:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
60006102:	61d3      	str	r3, [r2, #28]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
60006104:	2300      	movs	r3, #0
	thread->callee_saved.psp = (uint32_t)iframe;
60006106:	6582      	str	r2, [r0, #88]	; 0x58
	thread->arch.basepri = 0;
60006108:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
6000610c:	4770      	bx	lr
6000610e:	bf00      	nop
60006110:	6000990b 	.word	0x6000990b

60006114 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
60006114:	4a0a      	ldr	r2, [pc, #40]	; (60006140 <z_check_thread_stack_fail+0x2c>)
{
60006116:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
60006118:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
6000611a:	b178      	cbz	r0, 6000613c <z_check_thread_stack_fail+0x28>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
6000611c:	f113 0f16 	cmn.w	r3, #22
60006120:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
60006124:	d005      	beq.n	60006132 <z_check_thread_stack_fail+0x1e>
60006126:	f1a0 0220 	sub.w	r2, r0, #32
6000612a:	429a      	cmp	r2, r3
6000612c:	d805      	bhi.n	6000613a <z_check_thread_stack_fail+0x26>
6000612e:	4283      	cmp	r3, r0
60006130:	d203      	bcs.n	6000613a <z_check_thread_stack_fail+0x26>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
60006132:	4281      	cmp	r1, r0
60006134:	bf28      	it	cs
60006136:	2000      	movcs	r0, #0
60006138:	4770      	bx	lr
6000613a:	2000      	movs	r0, #0
}
6000613c:	4770      	bx	lr
6000613e:	bf00      	nop
60006140:	80000ef4 	.word	0x80000ef4

60006144 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
60006144:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
60006146:	4b0b      	ldr	r3, [pc, #44]	; (60006174 <arch_switch_to_main_thread+0x30>)
{
60006148:	4604      	mov	r4, r0
6000614a:	460e      	mov	r6, r1
6000614c:	4615      	mov	r5, r2
	_current = main_thread;
6000614e:	6098      	str	r0, [r3, #8]
#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
60006150:	f006 f862 	bl	6000c218 <z_thread_mark_switched_in>
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
60006154:	4620      	mov	r0, r4
60006156:	f000 fbd9 	bl	6000690c <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
6000615a:	4628      	mov	r0, r5
6000615c:	f386 8809 	msr	PSP, r6
60006160:	2100      	movs	r1, #0
60006162:	b663      	cpsie	if
60006164:	f381 8811 	msr	BASEPRI, r1
60006168:	f3bf 8f6f 	isb	sy
6000616c:	2200      	movs	r2, #0
6000616e:	2300      	movs	r3, #0
60006170:	f003 fbcb 	bl	6000990a <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
60006174:	80000ef4 	.word	0x80000ef4

60006178 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
60006178:	4901      	ldr	r1, [pc, #4]	; (60006180 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
6000617a:	2210      	movs	r2, #16
	str	r2, [r1]
6000617c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
6000617e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
60006180:	e000ed10 	.word	0xe000ed10

60006184 <arch_cpu_idle>:

SECTION_FUNC(TEXT, arch_cpu_idle)
#ifdef CONFIG_TRACING
	push	{r0, lr}
60006184:	b501      	push	{r0, lr}
	bl	sys_trace_idle
60006186:	f005 fb2e 	bl	6000b7e6 <sys_trace_idle>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop	{r0, r1}
	mov	lr, r1
#else
	pop	{r0, lr}
6000618a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
6000618e:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
60006190:	4040      	eors	r0, r0
	msr	BASEPRI, r0
60006192:	f380 8811 	msr	BASEPRI, r0
	isb
60006196:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
6000619a:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
6000619e:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
600061a0:	b662      	cpsie	i
	isb
600061a2:	f3bf 8f6f 	isb	sy

	bx	lr
600061a6:	4770      	bx	lr

600061a8 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
600061a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
600061aa:	4607      	mov	r7, r0

	if (esf != NULL) {
600061ac:	460c      	mov	r4, r1
600061ae:	b361      	cbz	r1, 6000620a <z_arm_fatal_error+0x62>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
600061b0:	4e19      	ldr	r6, [pc, #100]	; (60006218 <z_arm_fatal_error+0x70>)
600061b2:	6833      	ldr	r3, [r6, #0]
600061b4:	0758      	lsls	r0, r3, #29
600061b6:	d028      	beq.n	6000620a <z_arm_fatal_error+0x62>
600061b8:	4d18      	ldr	r5, [pc, #96]	; (6000621c <z_arm_fatal_error+0x74>)
600061ba:	4819      	ldr	r0, [pc, #100]	; (60006220 <z_arm_fatal_error+0x78>)
600061bc:	1b75      	subs	r5, r6, r5
600061be:	08ad      	lsrs	r5, r5, #2
600061c0:	01ad      	lsls	r5, r5, #6
600061c2:	f045 0501 	orr.w	r5, r5, #1
600061c6:	f8ad 5000 	strh.w	r5, [sp]
600061ca:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
600061ce:	6809      	ldr	r1, [r1, #0]
600061d0:	f003 ff58 	bl	6000a084 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
600061d4:	6833      	ldr	r3, [r6, #0]
600061d6:	0759      	lsls	r1, r3, #29
600061d8:	d017      	beq.n	6000620a <z_arm_fatal_error+0x62>
600061da:	f8ad 5000 	strh.w	r5, [sp]
600061de:	4811      	ldr	r0, [pc, #68]	; (60006224 <z_arm_fatal_error+0x7c>)
600061e0:	68e1      	ldr	r1, [r4, #12]
600061e2:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
600061e6:	f003 ff4d 	bl	6000a084 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
600061ea:	6833      	ldr	r3, [r6, #0]
600061ec:	075a      	lsls	r2, r3, #29
600061ee:	d00c      	beq.n	6000620a <z_arm_fatal_error+0x62>
600061f0:	462a      	mov	r2, r5
600061f2:	69e1      	ldr	r1, [r4, #28]
600061f4:	480c      	ldr	r0, [pc, #48]	; (60006228 <z_arm_fatal_error+0x80>)
600061f6:	f003 ff18 	bl	6000a02a <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
600061fa:	6833      	ldr	r3, [r6, #0]
600061fc:	075b      	lsls	r3, r3, #29
600061fe:	d004      	beq.n	6000620a <z_arm_fatal_error+0x62>
60006200:	462a      	mov	r2, r5
60006202:	69a1      	ldr	r1, [r4, #24]
60006204:	4809      	ldr	r0, [pc, #36]	; (6000622c <z_arm_fatal_error+0x84>)
60006206:	f003 ff10 	bl	6000a02a <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
6000620a:	4621      	mov	r1, r4
6000620c:	4638      	mov	r0, r7
}
6000620e:	b003      	add	sp, #12
60006210:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	z_fatal_error(reason, esf);
60006214:	f001 be42 	b.w	60007e9c <z_fatal_error>
60006218:	80000240 	.word	0x80000240
6000621c:	80000234 	.word	0x80000234
60006220:	6000e6c4 	.word	0x6000e6c4
60006224:	6000e6f3 	.word	0x6000e6f3
60006228:	6000e722 	.word	0x6000e722
6000622c:	6000e731 	.word	0x6000e731

60006230 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
60006230:	bf30      	wfi
    b z_SysNmiOnReset
60006232:	f7ff bffd 	b.w	60006230 <z_SysNmiOnReset>
60006236:	bf00      	nop

60006238 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
60006238:	4a0e      	ldr	r2, [pc, #56]	; (60006274 <z_arm_prep_c+0x3c>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
6000623a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
6000623c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
60006240:	4b0d      	ldr	r3, [pc, #52]	; (60006278 <z_arm_prep_c+0x40>)
60006242:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
60006244:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60006248:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
6000624c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
60006250:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
60006254:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
60006258:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
6000625c:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
60006260:	f383 8814 	msr	CONTROL, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
60006264:	f001 fe92 	bl	60007f8c <z_bss_zero>
	z_data_copy();
60006268:	f002 ff26 	bl	600090b8 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
6000626c:	f000 fb24 	bl	600068b8 <z_arm_interrupt_init>
	z_cstart();
60006270:	f001 febe 	bl	60007ff0 <z_cstart>
60006274:	60002000 	.word	0x60002000
60006278:	e000ed00 	.word	0xe000ed00

6000627c <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
6000627c:	b501      	push	{r0, lr}
	add r0, r0, #1
	str r0, [r2, #_kernel_offset_to_nested]
#endif /* CONFIG_CPU_CORTEX_M */

#ifdef CONFIG_TRACING_ISR
	bl sys_trace_isr_enter
6000627e:	f005 faae 	bl	6000b7de <sys_trace_isr_enter>
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
60006282:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
60006286:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
6000628a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
6000628e:	4905      	ldr	r1, [pc, #20]	; (600062a4 <_isr_wrapper+0x28>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
60006290:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
60006292:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
60006294:	4798      	blx	r3
	bl z_soc_irq_eoi
#endif /* !CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER */
#endif /* CONFIG_CPU_CORTEX_R */

#ifdef CONFIG_TRACING_ISR
	bl sys_trace_isr_exit
60006296:	f005 faa4 	bl	6000b7e2 <sys_trace_isr_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
6000629a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
6000629e:	4902      	ldr	r1, [pc, #8]	; (600062a8 <_isr_wrapper+0x2c>)
	bx r1
600062a0:	4708      	bx	r1
600062a2:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
600062a4:	6000c9b8 	.word	0x6000c9b8
	ldr r1, =z_arm_int_exit
600062a8:	6000689d 	.word	0x6000689d

600062ac <__start>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
600062ac:	2010      	movs	r0, #16
    msr BASEPRI, r0
600062ae:	f380 8811 	msr	BASEPRI, r0
 * (may be larger due to rounding up for stack pointer aligning
 * purposes but this is sufficient during initialization).
 */

#ifdef CONFIG_INIT_STACKS
    ldr r0, =z_interrupt_stacks
600062b2:	480b      	ldr	r0, [pc, #44]	; (600062e0 <__start+0x34>)
    ldr r1, =0xaa
600062b4:	f04f 01aa 	mov.w	r1, #170	; 0xaa
    ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
600062b8:	f44f 6202 	mov.w	r2, #2080	; 0x820
    bl memset
600062bc:	f005 fb74 	bl	6000b9a8 <memset>

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
600062c0:	4807      	ldr	r0, [pc, #28]	; (600062e0 <__start+0x34>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
600062c2:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
600062c6:	1840      	adds	r0, r0, r1
    msr PSP, r0
600062c8:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
600062cc:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
600062d0:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
600062d2:	4308      	orrs	r0, r1
    msr CONTROL, r0
600062d4:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
600062d8:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
600062dc:	f7ff ffac 	bl	60006238 <z_arm_prep_c>
    ldr r0, =z_interrupt_stacks
600062e0:	800031e0 	.word	0x800031e0

600062e4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
600062e4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
600062e8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
600062ec:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
600062ee:	4672      	mov	r2, lr
	bl z_arm_fault
600062f0:	f000 f9e4 	bl	600066bc <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
600062f4:	bd01      	pop	{r0, pc}
600062f6:	bf00      	nop

600062f8 <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
600062f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
600062fc:	4c4d      	ldr	r4, [pc, #308]	; (60006434 <mem_manage_fault+0x13c>)
{
600062fe:	4688      	mov	r8, r1
60006300:	4607      	mov	r7, r0
60006302:	4615      	mov	r5, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
60006304:	6823      	ldr	r3, [r4, #0]
60006306:	0759      	lsls	r1, r3, #29
60006308:	d008      	beq.n	6000631c <mem_manage_fault+0x24>
6000630a:	494b      	ldr	r1, [pc, #300]	; (60006438 <mem_manage_fault+0x140>)
6000630c:	484b      	ldr	r0, [pc, #300]	; (6000643c <mem_manage_fault+0x144>)
6000630e:	1a61      	subs	r1, r4, r1
60006310:	0889      	lsrs	r1, r1, #2
60006312:	0189      	lsls	r1, r1, #6
60006314:	f041 0101 	orr.w	r1, r1, #1
60006318:	f003 fe7a 	bl	6000a010 <log_0>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
6000631c:	4b48      	ldr	r3, [pc, #288]	; (60006440 <mem_manage_fault+0x148>)
6000631e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60006320:	06da      	lsls	r2, r3, #27
60006322:	d50b      	bpl.n	6000633c <mem_manage_fault+0x44>
		PR_FAULT_INFO("  Stacking error (context area might be"
60006324:	6823      	ldr	r3, [r4, #0]
60006326:	075b      	lsls	r3, r3, #29
60006328:	d008      	beq.n	6000633c <mem_manage_fault+0x44>
6000632a:	4943      	ldr	r1, [pc, #268]	; (60006438 <mem_manage_fault+0x140>)
6000632c:	4845      	ldr	r0, [pc, #276]	; (60006444 <mem_manage_fault+0x14c>)
6000632e:	1a61      	subs	r1, r4, r1
60006330:	0889      	lsrs	r1, r1, #2
60006332:	0189      	lsls	r1, r1, #6
60006334:	f041 0101 	orr.w	r1, r1, #1
60006338:	f003 fe6a 	bl	6000a010 <log_0>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
6000633c:	4b40      	ldr	r3, [pc, #256]	; (60006440 <mem_manage_fault+0x148>)
6000633e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60006340:	071e      	lsls	r6, r3, #28
60006342:	d50b      	bpl.n	6000635c <mem_manage_fault+0x64>
		PR_FAULT_INFO("  Unstacking error");
60006344:	6823      	ldr	r3, [r4, #0]
60006346:	0758      	lsls	r0, r3, #29
60006348:	d008      	beq.n	6000635c <mem_manage_fault+0x64>
6000634a:	493b      	ldr	r1, [pc, #236]	; (60006438 <mem_manage_fault+0x140>)
6000634c:	483e      	ldr	r0, [pc, #248]	; (60006448 <mem_manage_fault+0x150>)
6000634e:	1a61      	subs	r1, r4, r1
60006350:	0889      	lsrs	r1, r1, #2
60006352:	0189      	lsls	r1, r1, #6
60006354:	f041 0101 	orr.w	r1, r1, #1
60006358:	f003 fe5a 	bl	6000a010 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
6000635c:	4b38      	ldr	r3, [pc, #224]	; (60006440 <mem_manage_fault+0x148>)
6000635e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60006360:	0799      	lsls	r1, r3, #30
60006362:	d432      	bmi.n	600063ca <mem_manage_fault+0xd2>
	uint32_t mmfar = -EINVAL;
60006364:	f06f 0615 	mvn.w	r6, #21
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
60006368:	4b35      	ldr	r3, [pc, #212]	; (60006440 <mem_manage_fault+0x148>)
6000636a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
6000636c:	07d9      	lsls	r1, r3, #31
6000636e:	d50b      	bpl.n	60006388 <mem_manage_fault+0x90>
		PR_FAULT_INFO("  Instruction Access Violation");
60006370:	6823      	ldr	r3, [r4, #0]
60006372:	075a      	lsls	r2, r3, #29
60006374:	d008      	beq.n	60006388 <mem_manage_fault+0x90>
60006376:	4930      	ldr	r1, [pc, #192]	; (60006438 <mem_manage_fault+0x140>)
60006378:	4834      	ldr	r0, [pc, #208]	; (6000644c <mem_manage_fault+0x154>)
6000637a:	1a61      	subs	r1, r4, r1
6000637c:	0889      	lsrs	r1, r1, #2
6000637e:	0189      	lsls	r1, r1, #6
60006380:	f041 0101 	orr.w	r1, r1, #1
60006384:	f003 fe44 	bl	6000a010 <log_0>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
60006388:	4b2d      	ldr	r3, [pc, #180]	; (60006440 <mem_manage_fault+0x148>)
6000638a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
6000638c:	069b      	lsls	r3, r3, #26
6000638e:	d50b      	bpl.n	600063a8 <mem_manage_fault+0xb0>
		PR_FAULT_INFO(
60006390:	6823      	ldr	r3, [r4, #0]
60006392:	0758      	lsls	r0, r3, #29
60006394:	d008      	beq.n	600063a8 <mem_manage_fault+0xb0>
60006396:	4928      	ldr	r1, [pc, #160]	; (60006438 <mem_manage_fault+0x140>)
60006398:	482d      	ldr	r0, [pc, #180]	; (60006450 <mem_manage_fault+0x158>)
6000639a:	1a61      	subs	r1, r4, r1
6000639c:	0889      	lsrs	r1, r1, #2
6000639e:	0189      	lsls	r1, r1, #6
600063a0:	f041 0101 	orr.w	r1, r1, #1
600063a4:	f003 fe34 	bl	6000a010 <log_0>
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
600063a8:	4b25      	ldr	r3, [pc, #148]	; (60006440 <mem_manage_fault+0x148>)
600063aa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
600063ac:	06d1      	lsls	r1, r2, #27
600063ae:	d433      	bmi.n	60006418 <mem_manage_fault+0x120>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
600063b0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
600063b2:	0792      	lsls	r2, r2, #30
600063b4:	d430      	bmi.n	60006418 <mem_manage_fault+0x120>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
600063b6:	2000      	movs	r0, #0
		"without stack guard, user-mode or null-pointer detection\n");
#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_USERSPACE */
	}

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
600063b8:	4a21      	ldr	r2, [pc, #132]	; (60006440 <mem_manage_fault+0x148>)
600063ba:	6a93      	ldr	r3, [r2, #40]	; 0x28
600063bc:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
600063c0:	6293      	str	r3, [r2, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
600063c2:	2300      	movs	r3, #0
600063c4:	702b      	strb	r3, [r5, #0]

	return reason;
}
600063c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PR_FAULT_INFO("  Data Access Violation");
600063ca:	6823      	ldr	r3, [r4, #0]
600063cc:	075a      	lsls	r2, r3, #29
600063ce:	d008      	beq.n	600063e2 <mem_manage_fault+0xea>
600063d0:	4919      	ldr	r1, [pc, #100]	; (60006438 <mem_manage_fault+0x140>)
600063d2:	4820      	ldr	r0, [pc, #128]	; (60006454 <mem_manage_fault+0x15c>)
600063d4:	1a61      	subs	r1, r4, r1
600063d6:	0889      	lsrs	r1, r1, #2
600063d8:	0189      	lsls	r1, r1, #6
600063da:	f041 0101 	orr.w	r1, r1, #1
600063de:	f003 fe17 	bl	6000a010 <log_0>
		uint32_t temp = SCB->MMFAR;
600063e2:	4b17      	ldr	r3, [pc, #92]	; (60006440 <mem_manage_fault+0x148>)
600063e4:	6b5e      	ldr	r6, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
600063e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600063e8:	061b      	lsls	r3, r3, #24
600063ea:	d5bb      	bpl.n	60006364 <mem_manage_fault+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
600063ec:	6823      	ldr	r3, [r4, #0]
600063ee:	0758      	lsls	r0, r3, #29
600063f0:	d009      	beq.n	60006406 <mem_manage_fault+0x10e>
600063f2:	4a11      	ldr	r2, [pc, #68]	; (60006438 <mem_manage_fault+0x140>)
600063f4:	4631      	mov	r1, r6
600063f6:	4818      	ldr	r0, [pc, #96]	; (60006458 <mem_manage_fault+0x160>)
600063f8:	1aa2      	subs	r2, r4, r2
600063fa:	0892      	lsrs	r2, r2, #2
600063fc:	0192      	lsls	r2, r2, #6
600063fe:	f042 0201 	orr.w	r2, r2, #1
60006402:	f003 fe12 	bl	6000a02a <log_1>
			if (from_hard_fault != 0) {
60006406:	f1b8 0f00 	cmp.w	r8, #0
6000640a:	d0ad      	beq.n	60006368 <mem_manage_fault+0x70>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
6000640c:	4a0c      	ldr	r2, [pc, #48]	; (60006440 <mem_manage_fault+0x148>)
6000640e:	6a93      	ldr	r3, [r2, #40]	; 0x28
60006410:	f023 0380 	bic.w	r3, r3, #128	; 0x80
60006414:	6293      	str	r3, [r2, #40]	; 0x28
60006416:	e7a7      	b.n	60006368 <mem_manage_fault+0x70>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
60006418:	685b      	ldr	r3, [r3, #4]
6000641a:	051b      	lsls	r3, r3, #20
6000641c:	d5cb      	bpl.n	600063b6 <mem_manage_fault+0xbe>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
6000641e:	4639      	mov	r1, r7
60006420:	4630      	mov	r0, r6
60006422:	f7ff fe77 	bl	60006114 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
60006426:	2800      	cmp	r0, #0
60006428:	d0c5      	beq.n	600063b6 <mem_manage_fault+0xbe>
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
6000642a:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
6000642e:	2002      	movs	r0, #2
60006430:	e7c2      	b.n	600063b8 <mem_manage_fault+0xc0>
60006432:	bf00      	nop
60006434:	80000240 	.word	0x80000240
60006438:	80000234 	.word	0x80000234
6000643c:	6000e75f 	.word	0x6000e75f
60006440:	e000ed00 	.word	0xe000ed00
60006444:	6000e775 	.word	0x6000e775
60006448:	6000e7a8 	.word	0x6000e7a8
6000644c:	6000e7e9 	.word	0x6000e7e9
60006450:	6000e808 	.word	0x6000e808
60006454:	6000e7bb 	.word	0x6000e7bb
60006458:	6000e7d3 	.word	0x6000e7d3

6000645c <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
6000645c:	b510      	push	{r4, lr}
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
6000645e:	4c3b      	ldr	r4, [pc, #236]	; (6000654c <usage_fault.constprop.0+0xf0>)
60006460:	6823      	ldr	r3, [r4, #0]
60006462:	075b      	lsls	r3, r3, #29
60006464:	d008      	beq.n	60006478 <usage_fault.constprop.0+0x1c>
60006466:	493a      	ldr	r1, [pc, #232]	; (60006550 <usage_fault.constprop.0+0xf4>)
60006468:	483a      	ldr	r0, [pc, #232]	; (60006554 <usage_fault.constprop.0+0xf8>)
6000646a:	1a61      	subs	r1, r4, r1
6000646c:	0889      	lsrs	r1, r1, #2
6000646e:	0189      	lsls	r1, r1, #6
60006470:	f041 0101 	orr.w	r1, r1, #1
60006474:	f003 fdcc 	bl	6000a010 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
60006478:	4b37      	ldr	r3, [pc, #220]	; (60006558 <usage_fault.constprop.0+0xfc>)
6000647a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
6000647c:	0198      	lsls	r0, r3, #6
6000647e:	d50b      	bpl.n	60006498 <usage_fault.constprop.0+0x3c>
		PR_FAULT_INFO("  Division by zero");
60006480:	6823      	ldr	r3, [r4, #0]
60006482:	0759      	lsls	r1, r3, #29
60006484:	d008      	beq.n	60006498 <usage_fault.constprop.0+0x3c>
60006486:	4932      	ldr	r1, [pc, #200]	; (60006550 <usage_fault.constprop.0+0xf4>)
60006488:	4834      	ldr	r0, [pc, #208]	; (6000655c <usage_fault.constprop.0+0x100>)
6000648a:	1a61      	subs	r1, r4, r1
6000648c:	0889      	lsrs	r1, r1, #2
6000648e:	0189      	lsls	r1, r1, #6
60006490:	f041 0101 	orr.w	r1, r1, #1
60006494:	f003 fdbc 	bl	6000a010 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
60006498:	4b2f      	ldr	r3, [pc, #188]	; (60006558 <usage_fault.constprop.0+0xfc>)
6000649a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
6000649c:	01da      	lsls	r2, r3, #7
6000649e:	d50b      	bpl.n	600064b8 <usage_fault.constprop.0+0x5c>
		PR_FAULT_INFO("  Unaligned memory access");
600064a0:	6823      	ldr	r3, [r4, #0]
600064a2:	075b      	lsls	r3, r3, #29
600064a4:	d008      	beq.n	600064b8 <usage_fault.constprop.0+0x5c>
600064a6:	492a      	ldr	r1, [pc, #168]	; (60006550 <usage_fault.constprop.0+0xf4>)
600064a8:	482d      	ldr	r0, [pc, #180]	; (60006560 <usage_fault.constprop.0+0x104>)
600064aa:	1a61      	subs	r1, r4, r1
600064ac:	0889      	lsrs	r1, r1, #2
600064ae:	0189      	lsls	r1, r1, #6
600064b0:	f041 0101 	orr.w	r1, r1, #1
600064b4:	f003 fdac 	bl	6000a010 <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
600064b8:	4b27      	ldr	r3, [pc, #156]	; (60006558 <usage_fault.constprop.0+0xfc>)
600064ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600064bc:	0318      	lsls	r0, r3, #12
600064be:	d50b      	bpl.n	600064d8 <usage_fault.constprop.0+0x7c>
		PR_FAULT_INFO("  No coprocessor instructions");
600064c0:	6823      	ldr	r3, [r4, #0]
600064c2:	0759      	lsls	r1, r3, #29
600064c4:	d008      	beq.n	600064d8 <usage_fault.constprop.0+0x7c>
600064c6:	4922      	ldr	r1, [pc, #136]	; (60006550 <usage_fault.constprop.0+0xf4>)
600064c8:	4826      	ldr	r0, [pc, #152]	; (60006564 <usage_fault.constprop.0+0x108>)
600064ca:	1a61      	subs	r1, r4, r1
600064cc:	0889      	lsrs	r1, r1, #2
600064ce:	0189      	lsls	r1, r1, #6
600064d0:	f041 0101 	orr.w	r1, r1, #1
600064d4:	f003 fd9c 	bl	6000a010 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
600064d8:	4b1f      	ldr	r3, [pc, #124]	; (60006558 <usage_fault.constprop.0+0xfc>)
600064da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600064dc:	035a      	lsls	r2, r3, #13
600064de:	d50b      	bpl.n	600064f8 <usage_fault.constprop.0+0x9c>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
600064e0:	6823      	ldr	r3, [r4, #0]
600064e2:	075b      	lsls	r3, r3, #29
600064e4:	d008      	beq.n	600064f8 <usage_fault.constprop.0+0x9c>
600064e6:	491a      	ldr	r1, [pc, #104]	; (60006550 <usage_fault.constprop.0+0xf4>)
600064e8:	481f      	ldr	r0, [pc, #124]	; (60006568 <usage_fault.constprop.0+0x10c>)
600064ea:	1a61      	subs	r1, r4, r1
600064ec:	0889      	lsrs	r1, r1, #2
600064ee:	0189      	lsls	r1, r1, #6
600064f0:	f041 0101 	orr.w	r1, r1, #1
600064f4:	f003 fd8c 	bl	6000a010 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
600064f8:	4b17      	ldr	r3, [pc, #92]	; (60006558 <usage_fault.constprop.0+0xfc>)
600064fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600064fc:	0398      	lsls	r0, r3, #14
600064fe:	d50b      	bpl.n	60006518 <usage_fault.constprop.0+0xbc>
		PR_FAULT_INFO("  Illegal use of the EPSR");
60006500:	6823      	ldr	r3, [r4, #0]
60006502:	0759      	lsls	r1, r3, #29
60006504:	d008      	beq.n	60006518 <usage_fault.constprop.0+0xbc>
60006506:	4912      	ldr	r1, [pc, #72]	; (60006550 <usage_fault.constprop.0+0xf4>)
60006508:	4818      	ldr	r0, [pc, #96]	; (6000656c <usage_fault.constprop.0+0x110>)
6000650a:	1a61      	subs	r1, r4, r1
6000650c:	0889      	lsrs	r1, r1, #2
6000650e:	0189      	lsls	r1, r1, #6
60006510:	f041 0101 	orr.w	r1, r1, #1
60006514:	f003 fd7c 	bl	6000a010 <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
60006518:	4b0f      	ldr	r3, [pc, #60]	; (60006558 <usage_fault.constprop.0+0xfc>)
6000651a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
6000651c:	03da      	lsls	r2, r3, #15
6000651e:	d50b      	bpl.n	60006538 <usage_fault.constprop.0+0xdc>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
60006520:	6823      	ldr	r3, [r4, #0]
60006522:	075b      	lsls	r3, r3, #29
60006524:	d008      	beq.n	60006538 <usage_fault.constprop.0+0xdc>
60006526:	490a      	ldr	r1, [pc, #40]	; (60006550 <usage_fault.constprop.0+0xf4>)
60006528:	4811      	ldr	r0, [pc, #68]	; (60006570 <usage_fault.constprop.0+0x114>)
6000652a:	1a61      	subs	r1, r4, r1
6000652c:	0889      	lsrs	r1, r1, #2
6000652e:	0189      	lsls	r1, r1, #6
60006530:	f041 0101 	orr.w	r1, r1, #1
60006534:	f003 fd6c 	bl	6000a010 <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
60006538:	4a07      	ldr	r2, [pc, #28]	; (60006558 <usage_fault.constprop.0+0xfc>)

	return reason;
}
6000653a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
6000653c:	6a93      	ldr	r3, [r2, #40]	; 0x28
6000653e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
60006542:	ea6f 4313 	mvn.w	r3, r3, lsr #16
60006546:	6293      	str	r3, [r2, #40]	; 0x28
}
60006548:	bd10      	pop	{r4, pc}
6000654a:	bf00      	nop
6000654c:	80000240 	.word	0x80000240
60006550:	80000234 	.word	0x80000234
60006554:	6000e837 	.word	0x6000e837
60006558:	e000ed00 	.word	0xe000ed00
6000655c:	6000e84f 	.word	0x6000e84f
60006560:	6000e862 	.word	0x6000e862
60006564:	6000e87c 	.word	0x6000e87c
60006568:	6000e89a 	.word	0x6000e89a
6000656c:	6000e8bf 	.word	0x6000e8bf
60006570:	6000e8d9 	.word	0x6000e8d9

60006574 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
60006574:	b570      	push	{r4, r5, r6, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
60006576:	4c46      	ldr	r4, [pc, #280]	; (60006690 <bus_fault.constprop.0+0x11c>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
60006578:	460d      	mov	r5, r1
6000657a:	4606      	mov	r6, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
6000657c:	6823      	ldr	r3, [r4, #0]
6000657e:	0759      	lsls	r1, r3, #29
60006580:	d008      	beq.n	60006594 <bus_fault.constprop.0+0x20>
60006582:	4944      	ldr	r1, [pc, #272]	; (60006694 <bus_fault.constprop.0+0x120>)
60006584:	4844      	ldr	r0, [pc, #272]	; (60006698 <bus_fault.constprop.0+0x124>)
60006586:	1a61      	subs	r1, r4, r1
60006588:	0889      	lsrs	r1, r1, #2
6000658a:	0189      	lsls	r1, r1, #6
6000658c:	f041 0101 	orr.w	r1, r1, #1
60006590:	f003 fd3e 	bl	6000a010 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
60006594:	4b41      	ldr	r3, [pc, #260]	; (6000669c <bus_fault.constprop.0+0x128>)
60006596:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60006598:	04da      	lsls	r2, r3, #19
6000659a:	d50b      	bpl.n	600065b4 <bus_fault.constprop.0+0x40>
		PR_FAULT_INFO("  Stacking error");
6000659c:	6823      	ldr	r3, [r4, #0]
6000659e:	075b      	lsls	r3, r3, #29
600065a0:	d008      	beq.n	600065b4 <bus_fault.constprop.0+0x40>
600065a2:	493c      	ldr	r1, [pc, #240]	; (60006694 <bus_fault.constprop.0+0x120>)
600065a4:	483e      	ldr	r0, [pc, #248]	; (600066a0 <bus_fault.constprop.0+0x12c>)
600065a6:	1a61      	subs	r1, r4, r1
600065a8:	0889      	lsrs	r1, r1, #2
600065aa:	0189      	lsls	r1, r1, #6
600065ac:	f041 0101 	orr.w	r1, r1, #1
600065b0:	f003 fd2e 	bl	6000a010 <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
600065b4:	4b39      	ldr	r3, [pc, #228]	; (6000669c <bus_fault.constprop.0+0x128>)
600065b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600065b8:	0518      	lsls	r0, r3, #20
600065ba:	d50b      	bpl.n	600065d4 <bus_fault.constprop.0+0x60>
		PR_FAULT_INFO("  Unstacking error");
600065bc:	6823      	ldr	r3, [r4, #0]
600065be:	0759      	lsls	r1, r3, #29
600065c0:	d008      	beq.n	600065d4 <bus_fault.constprop.0+0x60>
600065c2:	4934      	ldr	r1, [pc, #208]	; (60006694 <bus_fault.constprop.0+0x120>)
600065c4:	4837      	ldr	r0, [pc, #220]	; (600066a4 <bus_fault.constprop.0+0x130>)
600065c6:	1a61      	subs	r1, r4, r1
600065c8:	0889      	lsrs	r1, r1, #2
600065ca:	0189      	lsls	r1, r1, #6
600065cc:	f041 0101 	orr.w	r1, r1, #1
600065d0:	f003 fd1e 	bl	6000a010 <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
600065d4:	4b31      	ldr	r3, [pc, #196]	; (6000669c <bus_fault.constprop.0+0x128>)
600065d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600065d8:	059a      	lsls	r2, r3, #22
600065da:	d522      	bpl.n	60006622 <bus_fault.constprop.0+0xae>
		PR_FAULT_INFO("  Precise data bus error");
600065dc:	6823      	ldr	r3, [r4, #0]
600065de:	075b      	lsls	r3, r3, #29
600065e0:	d008      	beq.n	600065f4 <bus_fault.constprop.0+0x80>
600065e2:	492c      	ldr	r1, [pc, #176]	; (60006694 <bus_fault.constprop.0+0x120>)
600065e4:	4830      	ldr	r0, [pc, #192]	; (600066a8 <bus_fault.constprop.0+0x134>)
600065e6:	1a61      	subs	r1, r4, r1
600065e8:	0889      	lsrs	r1, r1, #2
600065ea:	0189      	lsls	r1, r1, #6
600065ec:	f041 0101 	orr.w	r1, r1, #1
600065f0:	f003 fd0e 	bl	6000a010 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
600065f4:	4b29      	ldr	r3, [pc, #164]	; (6000669c <bus_fault.constprop.0+0x128>)
600065f6:	6b99      	ldr	r1, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
600065f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
600065fa:	0418      	lsls	r0, r3, #16
600065fc:	d511      	bpl.n	60006622 <bus_fault.constprop.0+0xae>
			PR_EXC("  BFAR Address: 0x%x", bfar);
600065fe:	6823      	ldr	r3, [r4, #0]
60006600:	075a      	lsls	r2, r3, #29
60006602:	d008      	beq.n	60006616 <bus_fault.constprop.0+0xa2>
60006604:	4a23      	ldr	r2, [pc, #140]	; (60006694 <bus_fault.constprop.0+0x120>)
60006606:	4829      	ldr	r0, [pc, #164]	; (600066ac <bus_fault.constprop.0+0x138>)
60006608:	1aa2      	subs	r2, r4, r2
6000660a:	0892      	lsrs	r2, r2, #2
6000660c:	0192      	lsls	r2, r2, #6
6000660e:	f042 0201 	orr.w	r2, r2, #1
60006612:	f003 fd0a 	bl	6000a02a <log_1>
			if (from_hard_fault != 0) {
60006616:	b126      	cbz	r6, 60006622 <bus_fault.constprop.0+0xae>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
60006618:	4a20      	ldr	r2, [pc, #128]	; (6000669c <bus_fault.constprop.0+0x128>)
6000661a:	6a93      	ldr	r3, [r2, #40]	; 0x28
6000661c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
60006620:	6293      	str	r3, [r2, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
60006622:	4b1e      	ldr	r3, [pc, #120]	; (6000669c <bus_fault.constprop.0+0x128>)
60006624:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60006626:	055b      	lsls	r3, r3, #21
60006628:	d50b      	bpl.n	60006642 <bus_fault.constprop.0+0xce>
		PR_FAULT_INFO("  Imprecise data bus error");
6000662a:	6823      	ldr	r3, [r4, #0]
6000662c:	075e      	lsls	r6, r3, #29
6000662e:	d008      	beq.n	60006642 <bus_fault.constprop.0+0xce>
60006630:	4918      	ldr	r1, [pc, #96]	; (60006694 <bus_fault.constprop.0+0x120>)
60006632:	481f      	ldr	r0, [pc, #124]	; (600066b0 <bus_fault.constprop.0+0x13c>)
60006634:	1a61      	subs	r1, r4, r1
60006636:	0889      	lsrs	r1, r1, #2
60006638:	0189      	lsls	r1, r1, #6
6000663a:	f041 0101 	orr.w	r1, r1, #1
6000663e:	f003 fce7 	bl	6000a010 <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
60006642:	4b16      	ldr	r3, [pc, #88]	; (6000669c <bus_fault.constprop.0+0x128>)
60006644:	6a9a      	ldr	r2, [r3, #40]	; 0x28
60006646:	05d0      	lsls	r0, r2, #23
60006648:	d513      	bpl.n	60006672 <bus_fault.constprop.0+0xfe>
		PR_FAULT_INFO("  Instruction bus error");
6000664a:	6823      	ldr	r3, [r4, #0]
6000664c:	0759      	lsls	r1, r3, #29
6000664e:	d008      	beq.n	60006662 <bus_fault.constprop.0+0xee>
60006650:	4910      	ldr	r1, [pc, #64]	; (60006694 <bus_fault.constprop.0+0x120>)
60006652:	4818      	ldr	r0, [pc, #96]	; (600066b4 <bus_fault.constprop.0+0x140>)
60006654:	1a64      	subs	r4, r4, r1
60006656:	08a4      	lsrs	r4, r4, #2
60006658:	01a4      	lsls	r4, r4, #6
6000665a:	f044 0101 	orr.w	r1, r4, #1
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
6000665e:	f003 fcd7 	bl	6000a010 <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
60006662:	4a0e      	ldr	r2, [pc, #56]	; (6000669c <bus_fault.constprop.0+0x128>)
	*recoverable = memory_fault_recoverable(esf, true);
60006664:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
60006666:	6a93      	ldr	r3, [r2, #40]	; 0x28
60006668:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
6000666c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
6000666e:	7028      	strb	r0, [r5, #0]
}
60006670:	bd70      	pop	{r4, r5, r6, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
60006672:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60006674:	049a      	lsls	r2, r3, #18
60006676:	d5f4      	bpl.n	60006662 <bus_fault.constprop.0+0xee>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
60006678:	6823      	ldr	r3, [r4, #0]
6000667a:	075b      	lsls	r3, r3, #29
6000667c:	d0f1      	beq.n	60006662 <bus_fault.constprop.0+0xee>
6000667e:	4905      	ldr	r1, [pc, #20]	; (60006694 <bus_fault.constprop.0+0x120>)
60006680:	480d      	ldr	r0, [pc, #52]	; (600066b8 <bus_fault.constprop.0+0x144>)
60006682:	1a64      	subs	r4, r4, r1
60006684:	08a4      	lsrs	r4, r4, #2
60006686:	01a4      	lsls	r4, r4, #6
60006688:	f044 0101 	orr.w	r1, r4, #1
6000668c:	e7e7      	b.n	6000665e <bus_fault.constprop.0+0xea>
6000668e:	bf00      	nop
60006690:	80000240 	.word	0x80000240
60006694:	80000234 	.word	0x80000234
60006698:	6000e904 	.word	0x6000e904
6000669c:	e000ed00 	.word	0xe000ed00
600066a0:	6000e91a 	.word	0x6000e91a
600066a4:	6000e7a8 	.word	0x6000e7a8
600066a8:	6000e92b 	.word	0x6000e92b
600066ac:	6000e944 	.word	0x6000e944
600066b0:	6000e959 	.word	0x6000e959
600066b4:	6000e974 	.word	0x6000e974
600066b8:	6000e808 	.word	0x6000e808

600066bc <z_arm_fault>:
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
600066bc:	4b68      	ldr	r3, [pc, #416]	; (60006860 <z_arm_fault+0x1a4>)
{
600066be:	b5f0      	push	{r4, r5, r6, r7, lr}
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
600066c0:	685f      	ldr	r7, [r3, #4]
{
600066c2:	b08b      	sub	sp, #44	; 0x2c
600066c4:	460e      	mov	r6, r1
600066c6:	2500      	movs	r5, #0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
600066c8:	f3c7 0408 	ubfx	r4, r7, #0, #9
600066cc:	f385 8811 	msr	BASEPRI, r5
600066d0:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
600066d4:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
600066d8:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
600066dc:	d111      	bne.n	60006702 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
600066de:	f002 030c 	and.w	r3, r2, #12
600066e2:	2b08      	cmp	r3, #8
600066e4:	d10f      	bne.n	60006706 <z_arm_fault+0x4a>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
600066e6:	495f      	ldr	r1, [pc, #380]	; (60006864 <z_arm_fault+0x1a8>)
600066e8:	680b      	ldr	r3, [r1, #0]
600066ea:	f013 0307 	ands.w	r3, r3, #7
600066ee:	d01c      	beq.n	6000672a <z_arm_fault+0x6e>
600066f0:	4b5d      	ldr	r3, [pc, #372]	; (60006868 <z_arm_fault+0x1ac>)
600066f2:	485e      	ldr	r0, [pc, #376]	; (6000686c <z_arm_fault+0x1b0>)
600066f4:	1ac9      	subs	r1, r1, r3
600066f6:	0889      	lsrs	r1, r1, #2
600066f8:	0189      	lsls	r1, r1, #6
600066fa:	f041 0101 	orr.w	r1, r1, #1
600066fe:	f003 fc87 	bl	6000a010 <log_0>
		return NULL;
60006702:	462e      	mov	r6, r5
60006704:	e003      	b.n	6000670e <z_arm_fault+0x52>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
60006706:	0713      	lsls	r3, r2, #28
60006708:	d401      	bmi.n	6000670e <z_arm_fault+0x52>
			ptr_esf = (z_arch_esf_t *)msp;
6000670a:	4606      	mov	r6, r0
			*nested_exc = true;
6000670c:	2501      	movs	r5, #1
	*recoverable = false;
6000670e:	2300      	movs	r3, #0
60006710:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
60006714:	1ee3      	subs	r3, r4, #3
60006716:	2b09      	cmp	r3, #9
60006718:	f200 8085 	bhi.w	60006826 <z_arm_fault+0x16a>
6000671c:	e8df f003 	tbb	[pc, r3]
60006720:	69716d07 	.word	0x69716d07
60006724:	83838383 	.word	0x83838383
60006728:	7583      	.short	0x7583
	*nested_exc = false;
6000672a:	461d      	mov	r5, r3
6000672c:	e7e9      	b.n	60006702 <z_arm_fault+0x46>
	PR_FAULT_INFO("***** HARD FAULT *****");
6000672e:	4f4d      	ldr	r7, [pc, #308]	; (60006864 <z_arm_fault+0x1a8>)
60006730:	683b      	ldr	r3, [r7, #0]
60006732:	0758      	lsls	r0, r3, #29
60006734:	d008      	beq.n	60006748 <z_arm_fault+0x8c>
60006736:	494c      	ldr	r1, [pc, #304]	; (60006868 <z_arm_fault+0x1ac>)
60006738:	484d      	ldr	r0, [pc, #308]	; (60006870 <z_arm_fault+0x1b4>)
6000673a:	1a79      	subs	r1, r7, r1
6000673c:	0889      	lsrs	r1, r1, #2
6000673e:	0189      	lsls	r1, r1, #6
60006740:	f041 0101 	orr.w	r1, r1, #1
60006744:	f003 fc64 	bl	6000a010 <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
60006748:	4b45      	ldr	r3, [pc, #276]	; (60006860 <z_arm_fault+0x1a4>)
	*recoverable = false;
6000674a:	2400      	movs	r4, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
6000674c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	*recoverable = false;
6000674e:	f88d 4007 	strb.w	r4, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
60006752:	0791      	lsls	r1, r2, #30
60006754:	d526      	bpl.n	600067a4 <z_arm_fault+0xe8>
		PR_EXC("  Bus fault on vector table read");
60006756:	683b      	ldr	r3, [r7, #0]
60006758:	075a      	lsls	r2, r3, #29
6000675a:	d101      	bne.n	60006760 <z_arm_fault+0xa4>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
6000675c:	2400      	movs	r4, #0
6000675e:	e008      	b.n	60006772 <z_arm_fault+0xb6>
60006760:	4941      	ldr	r1, [pc, #260]	; (60006868 <z_arm_fault+0x1ac>)
		PR_EXC("  Bus fault on vector table read");
60006762:	4844      	ldr	r0, [pc, #272]	; (60006874 <z_arm_fault+0x1b8>)
60006764:	1a79      	subs	r1, r7, r1
60006766:	0889      	lsrs	r1, r1, #2
60006768:	0189      	lsls	r1, r1, #6
6000676a:	f041 0101 	orr.w	r1, r1, #1
6000676e:	f003 fc4f 	bl	6000a010 <log_0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
60006772:	f89d 3007 	ldrb.w	r3, [sp, #7]
60006776:	b99b      	cbnz	r3, 600067a0 <z_arm_fault+0xe4>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
60006778:	2220      	movs	r2, #32
6000677a:	4631      	mov	r1, r6
6000677c:	a802      	add	r0, sp, #8
6000677e:	f005 f8e8 	bl	6000b952 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
60006782:	9b09      	ldr	r3, [sp, #36]	; 0x24
60006784:	2d00      	cmp	r5, #0
60006786:	d065      	beq.n	60006854 <z_arm_fault+0x198>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
60006788:	f3c3 0208 	ubfx	r2, r3, #0, #9
6000678c:	b922      	cbnz	r2, 60006798 <z_arm_fault+0xdc>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
6000678e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
60006792:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
60006796:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
60006798:	a902      	add	r1, sp, #8
6000679a:	4620      	mov	r0, r4
6000679c:	f7ff fd04 	bl	600061a8 <z_arm_fatal_error>
}
600067a0:	b00b      	add	sp, #44	; 0x2c
600067a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
600067a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
600067a6:	005b      	lsls	r3, r3, #1
600067a8:	d5d8      	bpl.n	6000675c <z_arm_fault+0xa0>
		PR_EXC("  Fault escalation (see below)");
600067aa:	683b      	ldr	r3, [r7, #0]
600067ac:	075c      	lsls	r4, r3, #29
600067ae:	d008      	beq.n	600067c2 <z_arm_fault+0x106>
600067b0:	492d      	ldr	r1, [pc, #180]	; (60006868 <z_arm_fault+0x1ac>)
600067b2:	4831      	ldr	r0, [pc, #196]	; (60006878 <z_arm_fault+0x1bc>)
600067b4:	1a79      	subs	r1, r7, r1
600067b6:	0889      	lsrs	r1, r1, #2
600067b8:	0189      	lsls	r1, r1, #6
600067ba:	f041 0101 	orr.w	r1, r1, #1
600067be:	f003 fc27 	bl	6000a010 <log_0>
		if (SCB_MMFSR != 0) {
600067c2:	4b27      	ldr	r3, [pc, #156]	; (60006860 <z_arm_fault+0x1a4>)
600067c4:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
600067c8:	b132      	cbz	r2, 600067d8 <z_arm_fault+0x11c>
			reason = mem_manage_fault(esf, 1, recoverable);
600067ca:	f10d 0207 	add.w	r2, sp, #7
600067ce:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
600067d0:	4630      	mov	r0, r6
600067d2:	f7ff fd91 	bl	600062f8 <mem_manage_fault>
600067d6:	e00e      	b.n	600067f6 <z_arm_fault+0x13a>
		} else if (SCB_BFSR != 0) {
600067d8:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
600067dc:	b12a      	cbz	r2, 600067ea <z_arm_fault+0x12e>
			reason = bus_fault(esf, 1, recoverable);
600067de:	f10d 0107 	add.w	r1, sp, #7
600067e2:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
600067e4:	f7ff fec6 	bl	60006574 <bus_fault.constprop.0>
600067e8:	e005      	b.n	600067f6 <z_arm_fault+0x13a>
		} else if (SCB_UFSR != 0) {
600067ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
600067ec:	b29b      	uxth	r3, r3
600067ee:	2b00      	cmp	r3, #0
600067f0:	d0b4      	beq.n	6000675c <z_arm_fault+0xa0>
			reason = usage_fault(esf);
600067f2:	f7ff fe33 	bl	6000645c <usage_fault.constprop.0>
600067f6:	4604      	mov	r4, r0
600067f8:	e7bb      	b.n	60006772 <z_arm_fault+0xb6>
		reason = mem_manage_fault(esf, 0, recoverable);
600067fa:	f10d 0207 	add.w	r2, sp, #7
600067fe:	2100      	movs	r1, #0
60006800:	e7e6      	b.n	600067d0 <z_arm_fault+0x114>
		reason = bus_fault(esf, 0, recoverable);
60006802:	f10d 0107 	add.w	r1, sp, #7
60006806:	2000      	movs	r0, #0
60006808:	e7ec      	b.n	600067e4 <z_arm_fault+0x128>
	PR_FAULT_INFO(
6000680a:	4916      	ldr	r1, [pc, #88]	; (60006864 <z_arm_fault+0x1a8>)
6000680c:	680b      	ldr	r3, [r1, #0]
6000680e:	0758      	lsls	r0, r3, #29
60006810:	d0a4      	beq.n	6000675c <z_arm_fault+0xa0>
60006812:	4b15      	ldr	r3, [pc, #84]	; (60006868 <z_arm_fault+0x1ac>)
60006814:	4819      	ldr	r0, [pc, #100]	; (6000687c <z_arm_fault+0x1c0>)
60006816:	1ac9      	subs	r1, r1, r3
60006818:	0889      	lsrs	r1, r1, #2
6000681a:	0189      	lsls	r1, r1, #6
6000681c:	f041 0101 	orr.w	r1, r1, #1
60006820:	f003 fbf6 	bl	6000a010 <log_0>
60006824:	e79a      	b.n	6000675c <z_arm_fault+0xa0>
	PR_FAULT_INFO("***** %s %d) *****",
60006826:	4b0f      	ldr	r3, [pc, #60]	; (60006864 <z_arm_fault+0x1a8>)
60006828:	681a      	ldr	r2, [r3, #0]
6000682a:	0752      	lsls	r2, r2, #29
6000682c:	d096      	beq.n	6000675c <z_arm_fault+0xa0>
6000682e:	4a0e      	ldr	r2, [pc, #56]	; (60006868 <z_arm_fault+0x1ac>)
60006830:	f417 7ff8 	tst.w	r7, #496	; 0x1f0
60006834:	4812      	ldr	r0, [pc, #72]	; (60006880 <z_arm_fault+0x1c4>)
60006836:	eba3 0302 	sub.w	r3, r3, r2
6000683a:	4912      	ldr	r1, [pc, #72]	; (60006884 <z_arm_fault+0x1c8>)
6000683c:	f1a4 0210 	sub.w	r2, r4, #16
60006840:	bf18      	it	ne
60006842:	4601      	movne	r1, r0
60006844:	089b      	lsrs	r3, r3, #2
60006846:	4810      	ldr	r0, [pc, #64]	; (60006888 <z_arm_fault+0x1cc>)
60006848:	019b      	lsls	r3, r3, #6
6000684a:	f043 0301 	orr.w	r3, r3, #1
6000684e:	f003 fc00 	bl	6000a052 <log_2>
60006852:	e783      	b.n	6000675c <z_arm_fault+0xa0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
60006854:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
60006858:	f023 0301 	bic.w	r3, r3, #1
6000685c:	e79b      	b.n	60006796 <z_arm_fault+0xda>
6000685e:	bf00      	nop
60006860:	e000ed00 	.word	0xe000ed00
60006864:	80000240 	.word	0x80000240
60006868:	80000234 	.word	0x80000234
6000686c:	6000e98c 	.word	0x6000e98c
60006870:	6000e9b7 	.word	0x6000e9b7
60006874:	6000e9ce 	.word	0x6000e9ce
60006878:	6000e9ef 	.word	0x6000e9ef
6000687c:	6000ea0e 	.word	0x6000ea0e
60006880:	6000ea47 	.word	0x6000ea47
60006884:	6000ea32 	.word	0x6000ea32
60006888:	6000ea60 	.word	0x6000ea60

6000688c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
6000688c:	4a02      	ldr	r2, [pc, #8]	; (60006898 <z_arm_fault_init+0xc>)
6000688e:	6953      	ldr	r3, [r2, #20]
60006890:	f043 0310 	orr.w	r3, r3, #16
60006894:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
60006896:	4770      	bx	lr
60006898:	e000ed00 	.word	0xe000ed00

6000689c <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
6000689c:	4b04      	ldr	r3, [pc, #16]	; (600068b0 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
6000689e:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
600068a0:	6a18      	ldr	r0, [r3, #32]
	cmp r0, r1
600068a2:	4288      	cmp	r0, r1
	beq _EXIT_EXC
600068a4:	d003      	beq.n	600068ae <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
600068a6:	4903      	ldr	r1, [pc, #12]	; (600068b4 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
600068a8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
600068ac:	600a      	str	r2, [r1, #0]

600068ae <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
600068ae:	4770      	bx	lr
	ldr r3, =_kernel
600068b0:	80000ef4 	.word	0x80000ef4
	ldr r1, =_SCS_ICSR
600068b4:	e000ed04 	.word	0xe000ed04

600068b8 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
600068b8:	2300      	movs	r3, #0
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
600068ba:	4804      	ldr	r0, [pc, #16]	; (600068cc <z_arm_interrupt_init+0x14>)
600068bc:	2110      	movs	r1, #16
600068be:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
600068c0:	3301      	adds	r3, #1
600068c2:	2ba0      	cmp	r3, #160	; 0xa0
600068c4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
600068c8:	d1f9      	bne.n	600068be <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
600068ca:	4770      	bx	lr
600068cc:	e000e100 	.word	0xe000e100

600068d0 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
600068d0:	4b06      	ldr	r3, [pc, #24]	; (600068ec <z_impl_k_thread_abort+0x1c>)
600068d2:	689b      	ldr	r3, [r3, #8]
600068d4:	4283      	cmp	r3, r0
600068d6:	d107      	bne.n	600068e8 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
600068d8:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
600068dc:	b123      	cbz	r3, 600068e8 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
600068de:	4a04      	ldr	r2, [pc, #16]	; (600068f0 <z_impl_k_thread_abort+0x20>)
600068e0:	6853      	ldr	r3, [r2, #4]
600068e2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
600068e6:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
600068e8:	f002 bb26 	b.w	60008f38 <z_thread_abort>
600068ec:	80000ef4 	.word	0x80000ef4
600068f0:	e000ed00 	.word	0xe000ed00

600068f4 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
600068f4:	4b02      	ldr	r3, [pc, #8]	; (60006900 <z_arm_configure_static_mpu_regions+0xc>)
600068f6:	2101      	movs	r1, #1
600068f8:	4a02      	ldr	r2, [pc, #8]	; (60006904 <z_arm_configure_static_mpu_regions+0x10>)
600068fa:	4803      	ldr	r0, [pc, #12]	; (60006908 <z_arm_configure_static_mpu_regions+0x14>)
600068fc:	f000 b896 	b.w	60006a2c <arm_core_mpu_configure_static_mpu_regions>
60006900:	82000000 	.word	0x82000000
60006904:	80000000 	.word	0x80000000
60006908:	6000d5dc 	.word	0x6000d5dc

6000690c <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
6000690c:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
60006910:	2120      	movs	r1, #32
	dynamic_regions[region_num].start = guard_start;
60006912:	4b05      	ldr	r3, [pc, #20]	; (60006928 <z_arm_configure_dynamic_mpu_regions+0x1c>)
		guard_start = thread->stack_info.start - guard_size;
60006914:	3a20      	subs	r2, #32

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
60006916:	4618      	mov	r0, r3
	dynamic_regions[region_num].start = guard_start;
60006918:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
6000691a:	4a04      	ldr	r2, [pc, #16]	; (6000692c <z_arm_configure_dynamic_mpu_regions+0x20>)
6000691c:	e9c3 1201 	strd	r1, r2, [r3, #4]
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
60006920:	2101      	movs	r1, #1
60006922:	f000 b88d 	b.w	60006a40 <arm_core_mpu_configure_dynamic_mpu_regions>
60006926:	bf00      	nop
60006928:	80000e50 	.word	0x80000e50
6000692c:	150b0000 	.word	0x150b0000

60006930 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
60006930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60006932:	460e      	mov	r6, r1
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
60006934:	4f2d      	ldr	r7, [pc, #180]	; (600069ec <mpu_configure_regions+0xbc>)
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
60006936:	2100      	movs	r1, #0
60006938:	42b1      	cmp	r1, r6
6000693a:	db01      	blt.n	60006940 <mpu_configure_regions+0x10>
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
6000693c:	4610      	mov	r0, r2
6000693e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (regions[i].size == 0U) {
60006940:	6844      	ldr	r4, [r0, #4]
60006942:	2c00      	cmp	r4, #0
60006944:	d04e      	beq.n	600069e4 <mpu_configure_regions+0xb4>
		if (do_sanity_check &&
60006946:	b1c3      	cbz	r3, 6000697a <mpu_configure_regions+0x4a>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
60006948:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
6000694c:	ea14 0f0c 	tst.w	r4, ip
60006950:	d00d      	beq.n	6000696e <mpu_configure_regions+0x3e>
			LOG_ERR("Partition %u: sanity check failed.", i);
60006952:	4a27      	ldr	r2, [pc, #156]	; (600069f0 <mpu_configure_regions+0xc0>)
60006954:	6813      	ldr	r3, [r2, #0]
60006956:	0758      	lsls	r0, r3, #29
60006958:	d026      	beq.n	600069a8 <mpu_configure_regions+0x78>
6000695a:	4b26      	ldr	r3, [pc, #152]	; (600069f4 <mpu_configure_regions+0xc4>)
6000695c:	4826      	ldr	r0, [pc, #152]	; (600069f8 <mpu_configure_regions+0xc8>)
6000695e:	1ad2      	subs	r2, r2, r3
60006960:	0892      	lsrs	r2, r2, #2
60006962:	0192      	lsls	r2, r2, #6
60006964:	f042 0201 	orr.w	r2, r2, #1
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
60006968:	f003 fb5f 	bl	6000a02a <log_1>
		if (reg_index == -EINVAL) {
6000696c:	e01c      	b.n	600069a8 <mpu_configure_regions+0x78>
		&&
6000696e:	2c1f      	cmp	r4, #31
60006970:	d9ef      	bls.n	60006952 <mpu_configure_regions+0x22>
		((part->start & (part->size - 1U)) == 0U);
60006972:	6805      	ldr	r5, [r0, #0]
		&&
60006974:	ea1c 0f05 	tst.w	ip, r5
60006978:	d1eb      	bne.n	60006952 <mpu_configure_regions+0x22>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
6000697a:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, &regions[i]);
6000697c:	b2d5      	uxtb	r5, r2
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
6000697e:	f8d0 c008 	ldr.w	ip, [r0, #8]
	region_conf.base = new_region->start;
60006982:	6802      	ldr	r2, [r0, #0]
	if (size <= 32U) {
60006984:	d913      	bls.n	600069ae <mpu_configure_regions+0x7e>
	if (size > (1UL << 31)) {
60006986:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
6000698a:	d812      	bhi.n	600069b2 <mpu_configure_regions+0x82>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
6000698c:	3c01      	subs	r4, #1
6000698e:	fab4 f484 	clz	r4, r4
60006992:	f1c4 041f 	rsb	r4, r4, #31
60006996:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
60006998:	2d0f      	cmp	r5, #15
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
6000699a:	ea4c 0404 	orr.w	r4, ip, r4
6000699e:	d913      	bls.n	600069c8 <mpu_configure_regions+0x98>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
600069a0:	4a13      	ldr	r2, [pc, #76]	; (600069f0 <mpu_configure_regions+0xc0>)
600069a2:	6813      	ldr	r3, [r2, #0]
600069a4:	075b      	lsls	r3, r3, #29
600069a6:	d106      	bne.n	600069b6 <mpu_configure_regions+0x86>
			return -EINVAL;
600069a8:	f06f 0215 	mvn.w	r2, #21
600069ac:	e7c6      	b.n	6000693c <mpu_configure_regions+0xc>
		return REGION_32B;
600069ae:	2408      	movs	r4, #8
600069b0:	e7f2      	b.n	60006998 <mpu_configure_regions+0x68>
		return REGION_4G;
600069b2:	243e      	movs	r4, #62	; 0x3e
600069b4:	e7f0      	b.n	60006998 <mpu_configure_regions+0x68>
600069b6:	4b0f      	ldr	r3, [pc, #60]	; (600069f4 <mpu_configure_regions+0xc4>)
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
600069b8:	4629      	mov	r1, r5
600069ba:	4810      	ldr	r0, [pc, #64]	; (600069fc <mpu_configure_regions+0xcc>)
600069bc:	1ad2      	subs	r2, r2, r3
600069be:	0892      	lsrs	r2, r2, #2
600069c0:	0192      	lsls	r2, r2, #6
600069c2:	f042 0201 	orr.w	r2, r2, #1
600069c6:	e7cf      	b.n	60006968 <mpu_configure_regions+0x38>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
600069c8:	f022 021f 	bic.w	r2, r2, #31
	MPU->RNR = index;
600069cc:	f8c7 5098 	str.w	r5, [r7, #152]	; 0x98
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
600069d0:	f044 0401 	orr.w	r4, r4, #1
				| MPU_RBAR_VALID_Msk | index;
600069d4:	432a      	orrs	r2, r5
600069d6:	f042 0210 	orr.w	r2, r2, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
600069da:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
		reg_index++;
600069de:	1c6a      	adds	r2, r5, #1
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
600069e0:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
600069e4:	3101      	adds	r1, #1
600069e6:	300c      	adds	r0, #12
600069e8:	e7a6      	b.n	60006938 <mpu_configure_regions+0x8>
600069ea:	bf00      	nop
600069ec:	e000ed00 	.word	0xe000ed00
600069f0:	8000023c 	.word	0x8000023c
600069f4:	80000234 	.word	0x80000234
600069f8:	6000ea77 	.word	0x6000ea77
600069fc:	6000ea9a 	.word	0x6000ea9a

60006a00 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
60006a00:	4b04      	ldr	r3, [pc, #16]	; (60006a14 <arm_core_mpu_enable+0x14>)
60006a02:	2205      	movs	r2, #5
60006a04:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
60006a08:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
60006a0c:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
60006a10:	4770      	bx	lr
60006a12:	bf00      	nop
60006a14:	e000ed00 	.word	0xe000ed00

60006a18 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
60006a18:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
60006a1c:	4b02      	ldr	r3, [pc, #8]	; (60006a28 <arm_core_mpu_disable+0x10>)
60006a1e:	2200      	movs	r2, #0
60006a20:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
60006a24:	4770      	bx	lr
60006a26:	bf00      	nop
60006a28:	e000ed00 	.word	0xe000ed00

60006a2c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
60006a2c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
60006a2e:	4c03      	ldr	r4, [pc, #12]	; (60006a3c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
60006a30:	2301      	movs	r3, #1
60006a32:	7822      	ldrb	r2, [r4, #0]
60006a34:	f7ff ff7c 	bl	60006930 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
60006a38:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
60006a3a:	bd10      	pop	{r4, pc}
60006a3c:	80000fb7 	.word	0x80000fb7

60006a40 <arm_core_mpu_configure_dynamic_mpu_regions>:

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
60006a40:	4a09      	ldr	r2, [pc, #36]	; (60006a68 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
60006a42:	b508      	push	{r3, lr}
60006a44:	2300      	movs	r3, #0
60006a46:	7812      	ldrb	r2, [r2, #0]
60006a48:	f7ff ff72 	bl	60006930 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
60006a4c:	f110 0f16 	cmn.w	r0, #22
60006a50:	d003      	beq.n	60006a5a <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
60006a52:	4b06      	ldr	r3, [pc, #24]	; (60006a6c <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)
  MPU->RASR = 0U;
60006a54:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
60006a56:	280f      	cmp	r0, #15
60006a58:	dd00      	ble.n	60006a5c <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
60006a5a:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
60006a5c:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
60006a60:	3001      	adds	r0, #1
  MPU->RASR = 0U;
60006a62:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
60006a66:	e7f6      	b.n	60006a56 <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
60006a68:	80000fb7 	.word	0x80000fb7
60006a6c:	e000ed00 	.word	0xe000ed00

60006a70 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
60006a70:	4914      	ldr	r1, [pc, #80]	; (60006ac4 <z_arm_mpu_init+0x54>)
60006a72:	6808      	ldr	r0, [r1, #0]
60006a74:	2810      	cmp	r0, #16
{
60006a76:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
60006a78:	d821      	bhi.n	60006abe <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
60006a7a:	f7ff ffcd 	bl	60006a18 <arm_core_mpu_disable>
	MPU->RNR = index;
60006a7e:	4c12      	ldr	r4, [pc, #72]	; (60006ac8 <z_arm_mpu_init+0x58>)
60006a80:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
60006a82:	2200      	movs	r2, #0
60006a84:	4290      	cmp	r0, r2
60006a86:	f101 010c 	add.w	r1, r1, #12
60006a8a:	d105      	bne.n	60006a98 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
60006a8c:	4b0f      	ldr	r3, [pc, #60]	; (60006acc <z_arm_mpu_init+0x5c>)
60006a8e:	7018      	strb	r0, [r3, #0]
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
60006a90:	2000      	movs	r0, #0
	arm_core_mpu_enable();
60006a92:	f7ff ffb5 	bl	60006a00 <arm_core_mpu_enable>
}
60006a96:	bd10      	pop	{r4, pc}
60006a98:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
60006a9c:	f851 3c0c 	ldr.w	r3, [r1, #-12]
60006aa0:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
60006aa4:	4313      	orrs	r3, r2
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
60006aa6:	3201      	adds	r2, #1
60006aa8:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
60006aac:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
60006ab0:	f851 3c04 	ldr.w	r3, [r1, #-4]
60006ab4:	f043 0301 	orr.w	r3, r3, #1
60006ab8:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
60006abc:	e7e2      	b.n	60006a84 <z_arm_mpu_init+0x14>
		return -1;
60006abe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
60006ac2:	e7e8      	b.n	60006a96 <z_arm_mpu_init+0x26>
60006ac4:	6000d5e8 	.word	0x6000d5e8
60006ac8:	e000ed00 	.word	0xe000ed00
60006acc:	80000fb7 	.word	0x80000fb7

60006ad0 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
60006ad0:	4b01      	ldr	r3, [pc, #4]	; (60006ad8 <__stdout_hook_install+0x8>)
60006ad2:	6018      	str	r0, [r3, #0]
}
60006ad4:	4770      	bx	lr
60006ad6:	bf00      	nop
60006ad8:	8000015c 	.word	0x8000015c

60006adc <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *_MLIBC_RESTRICT str, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
60006adc:	b40c      	push	{r2, r3}
60006ade:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
60006ae0:	b909      	cbnz	r1, 60006ae6 <snprintf+0xa>
		str = &dummy; /* write final NUL to dummy, can't change *s */
60006ae2:	f10d 0003 	add.w	r0, sp, #3
	}

	p.ptr = str;
	p.len = (int) len;

	va_start(vargs, format);
60006ae6:	ab07      	add	r3, sp, #28
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
60006ae8:	9a06      	ldr	r2, [sp, #24]
	p.len = (int) len;
60006aea:	e9cd 0102 	strd	r0, r1, [sp, #8]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
60006aee:	a902      	add	r1, sp, #8
60006af0:	4805      	ldr	r0, [pc, #20]	; (60006b08 <snprintf+0x2c>)
	va_start(vargs, format);
60006af2:	9301      	str	r3, [sp, #4]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
60006af4:	f7fb fe6c 	bl	600027d0 <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
60006af8:	9b02      	ldr	r3, [sp, #8]
60006afa:	2200      	movs	r2, #0
60006afc:	701a      	strb	r2, [r3, #0]
	return r;
}
60006afe:	b005      	add	sp, #20
60006b00:	f85d eb04 	ldr.w	lr, [sp], #4
60006b04:	b002      	add	sp, #8
60006b06:	4770      	bx	lr
60006b08:	6000b9f5 	.word	0x6000b9f5

60006b0c <mimxrt1050_evk_init>:
    *reg = ((*reg) & ~((uint32_t)(3UL << shift))) | (((uint32_t)value) << shift);
60006b0c:	4b11      	ldr	r3, [pc, #68]	; (60006b54 <mimxrt1050_evk_init+0x48>)
                                    uint32_t inputRegister,
                                    uint32_t inputDaisy,
                                    uint32_t configRegister,
                                    uint32_t inputOnfield)
{
    *((volatile uint32_t *)muxRegister) =
60006b0e:	2105      	movs	r1, #5
60006b10:	4811      	ldr	r0, [pc, #68]	; (60006b58 <mimxrt1050_evk_init+0x4c>)
60006b12:	6f9a      	ldr	r2, [r3, #120]	; 0x78
60006b14:	f042 020c 	orr.w	r2, r2, #12
60006b18:	679a      	str	r2, [r3, #120]	; 0x78
60006b1a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
60006b1c:	f042 0230 	orr.w	r2, r2, #48	; 0x30
60006b20:	671a      	str	r2, [r3, #112]	; 0x70
60006b22:	f503 237c 	add.w	r3, r3, #1032192	; 0xfc000
                                       uint32_t configRegister,
                                       uint32_t configValue)
{
    if (configRegister)
    {
        *((volatile uint32_t *)configRegister) = configValue;
60006b26:	f241 02b0 	movw	r2, #4272	; 0x10b0
    *((volatile uint32_t *)muxRegister) =
60006b2a:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
        *((volatile uint32_t *)configRegister) = configValue;
60006b2e:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8
    *((volatile uint32_t *)muxRegister) =
60006b32:	f8c3 10e0 	str.w	r1, [r3, #224]	; 0xe0
        *((volatile uint32_t *)configRegister) = configValue;
60006b36:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
    *((volatile uint32_t *)muxRegister) =
60006b3a:	6001      	str	r1, [r0, #0]
60006b3c:	2102      	movs	r1, #2
	mimxrt1050_evk_usdhc_pinmux(0, true, 2, 1);
	imxrt_usdhc_pinmux_cb_register(mimxrt1050_evk_usdhc_pinmux);
#endif

	return 0;
}
60006b3e:	2000      	movs	r0, #0
60006b40:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
60006b44:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
        *((volatile uint32_t *)configRegister) = configValue;
60006b48:	f8c3 22dc 	str.w	r2, [r3, #732]	; 0x2dc
60006b4c:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
60006b50:	4770      	bx	lr
60006b52:	bf00      	nop
60006b54:	400fc000 	.word	0x400fc000
60006b58:	400a8000 	.word	0x400a8000

60006b5c <mcux_lpuart_init>:

	return 0;
}

static int mcux_lpuart_init(const struct device *dev)
{
60006b5c:	b538      	push	{r3, r4, r5, lr}
	const struct mcux_lpuart_config *config = dev->config;
60006b5e:	6845      	ldr	r5, [r0, #4]
{
60006b60:	4604      	mov	r4, r0
	struct mcux_lpuart_data *data = dev->data;
60006b62:	6901      	ldr	r1, [r0, #16]
	struct uart_config *uart_api_config = &data->uart_config;

	uart_api_config->baudrate = config->baud_rate;
60006b64:	68eb      	ldr	r3, [r5, #12]
	uart_api_config->stop_bits = UART_CFG_STOP_BITS_1;
	uart_api_config->data_bits = UART_CFG_DATA_BITS_8;
	uart_api_config->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;

	/* set initial configuration */
	mcux_lpuart_configure_init(dev, uart_api_config);
60006b66:	3108      	adds	r1, #8
	uart_api_config->baudrate = config->baud_rate;
60006b68:	600b      	str	r3, [r1, #0]
	uart_api_config->parity = UART_CFG_PARITY_NONE;
60006b6a:	4b04      	ldr	r3, [pc, #16]	; (60006b7c <mcux_lpuart_init+0x20>)
60006b6c:	604b      	str	r3, [r1, #4]
	mcux_lpuart_configure_init(dev, uart_api_config);
60006b6e:	f005 f94d 	bl	6000be0c <mcux_lpuart_configure_init>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
60006b72:	4620      	mov	r0, r4
60006b74:	692b      	ldr	r3, [r5, #16]
60006b76:	4798      	blx	r3
#endif

	return 0;
}
60006b78:	2000      	movs	r0, #0
60006b7a:	bd38      	pop	{r3, r4, r5, pc}
60006b7c:	00030100 	.word	0x00030100

60006b80 <CLOCK_GetOscFreq>:
    return ((XTALOSC24M->LOWPWR_CTRL & XTALOSC24M_LOWPWR_CTRL_OSC_SEL_MASK) != 0UL) ? 24000000UL : g_xtalFreq;
60006b80:	4b04      	ldr	r3, [pc, #16]	; (60006b94 <CLOCK_GetOscFreq+0x14>)
60006b82:	f8d3 3270 	ldr.w	r3, [r3, #624]	; 0x270
60006b86:	06db      	lsls	r3, r3, #27
60006b88:	d402      	bmi.n	60006b90 <CLOCK_GetOscFreq+0x10>
60006b8a:	4b03      	ldr	r3, [pc, #12]	; (60006b98 <CLOCK_GetOscFreq+0x18>)
60006b8c:	6818      	ldr	r0, [r3, #0]
60006b8e:	4770      	bx	lr
60006b90:	4802      	ldr	r0, [pc, #8]	; (60006b9c <CLOCK_GetOscFreq+0x1c>)
}
60006b92:	4770      	bx	lr
60006b94:	400d8000 	.word	0x400d8000
60006b98:	80000ec4 	.word	0x80000ec4
60006b9c:	016e3600 	.word	0x016e3600

60006ba0 <CLOCK_InitArmPll>:
 * param config   configuration to set to PLL.
 */
void CLOCK_InitArmPll(const clock_arm_pll_config_t *config)
{
    /* Bypass PLL first */
    CCM_ANALOG->PLL_ARM = (CCM_ANALOG->PLL_ARM & (~CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_MASK)) |
60006ba0:	4a0f      	ldr	r2, [pc, #60]	; (60006be0 <CLOCK_InitArmPll+0x40>)
                          CCM_ANALOG_PLL_ARM_BYPASS_MASK | CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC(config->src);
60006ba2:	7903      	ldrb	r3, [r0, #4]
    CCM_ANALOG->PLL_ARM = (CCM_ANALOG->PLL_ARM & (~CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_MASK)) |
60006ba4:	6811      	ldr	r1, [r2, #0]
                          CCM_ANALOG_PLL_ARM_BYPASS_MASK | CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC(config->src);
60006ba6:	039b      	lsls	r3, r3, #14
    CCM_ANALOG->PLL_ARM = (CCM_ANALOG->PLL_ARM & (~CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_MASK)) |
60006ba8:	f421 31e0 	bic.w	r1, r1, #114688	; 0x1c000
                          CCM_ANALOG_PLL_ARM_BYPASS_MASK | CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC(config->src);
60006bac:	b29b      	uxth	r3, r3
60006bae:	430b      	orrs	r3, r1
60006bb0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    CCM_ANALOG->PLL_ARM = (CCM_ANALOG->PLL_ARM & (~CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_MASK)) |
60006bb4:	6013      	str	r3, [r2, #0]

    CCM_ANALOG->PLL_ARM =
        (CCM_ANALOG->PLL_ARM & (~(CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK | CCM_ANALOG_PLL_ARM_POWERDOWN_MASK))) |
60006bb6:	6811      	ldr	r1, [r2, #0]
        CCM_ANALOG_PLL_ARM_ENABLE_MASK | CCM_ANALOG_PLL_ARM_DIV_SELECT(config->loopDivider);
60006bb8:	6803      	ldr	r3, [r0, #0]
        (CCM_ANALOG->PLL_ARM & (~(CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK | CCM_ANALOG_PLL_ARM_POWERDOWN_MASK))) |
60006bba:	f421 5141 	bic.w	r1, r1, #12352	; 0x3040
        CCM_ANALOG_PLL_ARM_ENABLE_MASK | CCM_ANALOG_PLL_ARM_DIV_SELECT(config->loopDivider);
60006bbe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
        (CCM_ANALOG->PLL_ARM & (~(CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK | CCM_ANALOG_PLL_ARM_POWERDOWN_MASK))) |
60006bc2:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
        CCM_ANALOG_PLL_ARM_ENABLE_MASK | CCM_ANALOG_PLL_ARM_DIV_SELECT(config->loopDivider);
60006bc6:	430b      	orrs	r3, r1
60006bc8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    CCM_ANALOG->PLL_ARM =
60006bcc:	6013      	str	r3, [r2, #0]

    while ((CCM_ANALOG->PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK_MASK) == 0UL)
60006bce:	6813      	ldr	r3, [r2, #0]
60006bd0:	2b00      	cmp	r3, #0
60006bd2:	dafc      	bge.n	60006bce <CLOCK_InitArmPll+0x2e>
    {
    }

    /* Disable Bypass */
    CCM_ANALOG->PLL_ARM &= ~CCM_ANALOG_PLL_ARM_BYPASS_MASK;
60006bd4:	6813      	ldr	r3, [r2, #0]
60006bd6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
60006bda:	6013      	str	r3, [r2, #0]
}
60006bdc:	4770      	bx	lr
60006bde:	bf00      	nop
60006be0:	400d8000 	.word	0x400d8000

60006be4 <CLOCK_InitSysPll>:
 * param config Configuration to set to PLL.
 */
void CLOCK_InitSysPll(const clock_sys_pll_config_t *config)
{
    /* Bypass PLL first */
    CCM_ANALOG->PLL_SYS = (CCM_ANALOG->PLL_SYS & (~CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_MASK)) |
60006be4:	4b18      	ldr	r3, [pc, #96]	; (60006c48 <CLOCK_InitSysPll+0x64>)
                          CCM_ANALOG_PLL_SYS_BYPASS_MASK | CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC(config->src);
60006be6:	7b02      	ldrb	r2, [r0, #12]
    CCM_ANALOG->PLL_SYS = (CCM_ANALOG->PLL_SYS & (~CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_MASK)) |
60006be8:	6b19      	ldr	r1, [r3, #48]	; 0x30
                          CCM_ANALOG_PLL_SYS_BYPASS_MASK | CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC(config->src);
60006bea:	0392      	lsls	r2, r2, #14
    CCM_ANALOG->PLL_SYS = (CCM_ANALOG->PLL_SYS & (~CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_MASK)) |
60006bec:	f421 31e0 	bic.w	r1, r1, #114688	; 0x1c000
                          CCM_ANALOG_PLL_SYS_BYPASS_MASK | CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC(config->src);
60006bf0:	b292      	uxth	r2, r2
60006bf2:	430a      	orrs	r2, r1
60006bf4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    CCM_ANALOG->PLL_SYS = (CCM_ANALOG->PLL_SYS & (~CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_MASK)) |
60006bf8:	631a      	str	r2, [r3, #48]	; 0x30

    CCM_ANALOG->PLL_SYS =
        (CCM_ANALOG->PLL_SYS & (~(CCM_ANALOG_PLL_SYS_DIV_SELECT_MASK | CCM_ANALOG_PLL_SYS_POWERDOWN_MASK))) |
60006bfa:	6b19      	ldr	r1, [r3, #48]	; 0x30
        CCM_ANALOG_PLL_SYS_ENABLE_MASK | CCM_ANALOG_PLL_SYS_DIV_SELECT(config->loopDivider);
60006bfc:	7802      	ldrb	r2, [r0, #0]
        (CCM_ANALOG->PLL_SYS & (~(CCM_ANALOG_PLL_SYS_DIV_SELECT_MASK | CCM_ANALOG_PLL_SYS_POWERDOWN_MASK))) |
60006bfe:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
        CCM_ANALOG_PLL_SYS_ENABLE_MASK | CCM_ANALOG_PLL_SYS_DIV_SELECT(config->loopDivider);
60006c02:	f002 0201 	and.w	r2, r2, #1
        (CCM_ANALOG->PLL_SYS & (~(CCM_ANALOG_PLL_SYS_DIV_SELECT_MASK | CCM_ANALOG_PLL_SYS_POWERDOWN_MASK))) |
60006c06:	f021 0101 	bic.w	r1, r1, #1
        CCM_ANALOG_PLL_SYS_ENABLE_MASK | CCM_ANALOG_PLL_SYS_DIV_SELECT(config->loopDivider);
60006c0a:	430a      	orrs	r2, r1
    CCM_ANALOG->PLL_SYS_DENOM = CCM_ANALOG_PLL_SYS_DENOM_B(config->denominator);

    /* Initialize the spread spectrum mode */
    CCM_ANALOG->PLL_SYS_SS = CCM_ANALOG_PLL_SYS_SS_STEP(config->ss_step) |
                             CCM_ANALOG_PLL_SYS_SS_ENABLE(config->ss_enable) |
                             CCM_ANALOG_PLL_SYS_SS_STOP(config->ss_stop);
60006c0c:	89c1      	ldrh	r1, [r0, #14]
        CCM_ANALOG_PLL_SYS_ENABLE_MASK | CCM_ANALOG_PLL_SYS_DIV_SELECT(config->loopDivider);
60006c0e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    CCM_ANALOG->PLL_SYS =
60006c12:	631a      	str	r2, [r3, #48]	; 0x30
    CCM_ANALOG->PLL_SYS_NUM   = CCM_ANALOG_PLL_SYS_NUM_A(config->numerator);
60006c14:	6842      	ldr	r2, [r0, #4]
60006c16:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
60006c1a:	651a      	str	r2, [r3, #80]	; 0x50
    CCM_ANALOG->PLL_SYS_DENOM = CCM_ANALOG_PLL_SYS_DENOM_B(config->denominator);
60006c1c:	6882      	ldr	r2, [r0, #8]
60006c1e:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
60006c22:	661a      	str	r2, [r3, #96]	; 0x60
    CCM_ANALOG->PLL_SYS_SS = CCM_ANALOG_PLL_SYS_SS_STEP(config->ss_step) |
60006c24:	8a42      	ldrh	r2, [r0, #18]
60006c26:	f3c2 020e 	ubfx	r2, r2, #0, #15
                             CCM_ANALOG_PLL_SYS_SS_ENABLE(config->ss_enable) |
60006c2a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
60006c2e:	7c01      	ldrb	r1, [r0, #16]
60006c30:	03c9      	lsls	r1, r1, #15
60006c32:	b289      	uxth	r1, r1
60006c34:	430a      	orrs	r2, r1
    CCM_ANALOG->PLL_SYS_SS = CCM_ANALOG_PLL_SYS_SS_STEP(config->ss_step) |
60006c36:	641a      	str	r2, [r3, #64]	; 0x40

    while ((CCM_ANALOG->PLL_SYS & CCM_ANALOG_PLL_SYS_LOCK_MASK) == 0UL)
60006c38:	6b1a      	ldr	r2, [r3, #48]	; 0x30
60006c3a:	2a00      	cmp	r2, #0
60006c3c:	dafc      	bge.n	60006c38 <CLOCK_InitSysPll+0x54>
    {
    }

    /* Disable Bypass */
    CCM_ANALOG->PLL_SYS &= ~CCM_ANALOG_PLL_SYS_BYPASS_MASK;
60006c3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
60006c40:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
60006c44:	631a      	str	r2, [r3, #48]	; 0x30
}
60006c46:	4770      	bx	lr
60006c48:	400d8000 	.word	0x400d8000

60006c4c <CLOCK_InitUsb1Pll>:
 * param config Configuration to set to PLL.
 */
void CLOCK_InitUsb1Pll(const clock_usb_pll_config_t *config)
{
    /* Bypass PLL first */
    CCM_ANALOG->PLL_USB1 = (CCM_ANALOG->PLL_USB1 & (~CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_MASK)) |
60006c4c:	4a0f      	ldr	r2, [pc, #60]	; (60006c8c <CLOCK_InitUsb1Pll+0x40>)
                           CCM_ANALOG_PLL_USB1_BYPASS_MASK | CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC(config->src);
60006c4e:	7843      	ldrb	r3, [r0, #1]
    CCM_ANALOG->PLL_USB1 = (CCM_ANALOG->PLL_USB1 & (~CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_MASK)) |
60006c50:	6911      	ldr	r1, [r2, #16]
                           CCM_ANALOG_PLL_USB1_BYPASS_MASK | CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC(config->src);
60006c52:	039b      	lsls	r3, r3, #14
    CCM_ANALOG->PLL_USB1 = (CCM_ANALOG->PLL_USB1 & (~CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_MASK)) |
60006c54:	f421 31e0 	bic.w	r1, r1, #114688	; 0x1c000
                           CCM_ANALOG_PLL_USB1_BYPASS_MASK | CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC(config->src);
60006c58:	b29b      	uxth	r3, r3
60006c5a:	430b      	orrs	r3, r1
60006c5c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    CCM_ANALOG->PLL_USB1 = (CCM_ANALOG->PLL_USB1 & (~CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_MASK)) |
60006c60:	6113      	str	r3, [r2, #16]

    CCM_ANALOG->PLL_USB1 = (CCM_ANALOG->PLL_USB1 & (~CCM_ANALOG_PLL_USB1_DIV_SELECT_MASK)) |
60006c62:	6911      	ldr	r1, [r2, #16]
                           CCM_ANALOG_PLL_USB1_ENABLE_MASK | CCM_ANALOG_PLL_USB1_POWER_MASK |
                           CCM_ANALOG_PLL_USB1_EN_USB_CLKS_MASK | CCM_ANALOG_PLL_USB1_DIV_SELECT(config->loopDivider);
60006c64:	7803      	ldrb	r3, [r0, #0]
                           CCM_ANALOG_PLL_USB1_ENABLE_MASK | CCM_ANALOG_PLL_USB1_POWER_MASK |
60006c66:	f421 5141 	bic.w	r1, r1, #12352	; 0x3040
                           CCM_ANALOG_PLL_USB1_EN_USB_CLKS_MASK | CCM_ANALOG_PLL_USB1_DIV_SELECT(config->loopDivider);
60006c6a:	005b      	lsls	r3, r3, #1
                           CCM_ANALOG_PLL_USB1_ENABLE_MASK | CCM_ANALOG_PLL_USB1_POWER_MASK |
60006c6c:	f021 0102 	bic.w	r1, r1, #2
                           CCM_ANALOG_PLL_USB1_EN_USB_CLKS_MASK | CCM_ANALOG_PLL_USB1_DIV_SELECT(config->loopDivider);
60006c70:	f003 0302 	and.w	r3, r3, #2
60006c74:	430b      	orrs	r3, r1
60006c76:	f443 5341 	orr.w	r3, r3, #12352	; 0x3040
    CCM_ANALOG->PLL_USB1 = (CCM_ANALOG->PLL_USB1 & (~CCM_ANALOG_PLL_USB1_DIV_SELECT_MASK)) |
60006c7a:	6113      	str	r3, [r2, #16]

    while ((CCM_ANALOG->PLL_USB1 & CCM_ANALOG_PLL_USB1_LOCK_MASK) == 0UL)
60006c7c:	6913      	ldr	r3, [r2, #16]
60006c7e:	2b00      	cmp	r3, #0
60006c80:	dafc      	bge.n	60006c7c <CLOCK_InitUsb1Pll+0x30>
    {
    }

    /* Disable Bypass */
    CCM_ANALOG->PLL_USB1 &= ~CCM_ANALOG_PLL_USB1_BYPASS_MASK;
60006c82:	6913      	ldr	r3, [r2, #16]
60006c84:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
60006c88:	6113      	str	r3, [r2, #16]
}
60006c8a:	4770      	bx	lr
60006c8c:	400d8000 	.word	0x400d8000

60006c90 <CLOCK_GetPllFreq>:
 *
 * param pll   pll name to get frequency.
 * return The PLL output frequency in hertz.
 */
uint32_t CLOCK_GetPllFreq(clock_pll_t pll)
{
60006c90:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint32_t freq;
    uint32_t divSelect;
    clock_64b_t freqTmp;

    const uint32_t enetRefClkFreq[] = {
60006c92:	4b5e      	ldr	r3, [pc, #376]	; (60006e0c <CLOCK_GetPllFreq+0x17c>)
{
60006c94:	4604      	mov	r4, r0
    const uint32_t enetRefClkFreq[] = {
60006c96:	ad04      	add	r5, sp, #16
60006c98:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
60006c9a:	e905 000f 	stmdb	r5, {r0, r1, r2, r3}
 *         - true: The PLL is enabled.
 *         - false: The PLL is not enabled.
 */
static inline bool CLOCK_IsPllEnabled(CCM_ANALOG_Type *base, clock_pll_t pll)
{
    return ((CCM_ANALOG_TUPLE_REG(base, pll) & (1UL << CCM_ANALOG_TUPLE_SHIFT(pll))) != 0U);
60006c9e:	f3c4 420b 	ubfx	r2, r4, #16, #12
60006ca2:	f004 001f 	and.w	r0, r4, #31
60006ca6:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
60006caa:	f502 2258 	add.w	r2, r2, #884736	; 0xd8000
60006cae:	6813      	ldr	r3, [r2, #0]
60006cb0:	40c3      	lsrs	r3, r0
        100000000U, /* 100M */
        125000000U  /* 125M */
    };

    /* check if PLL is enabled */
    if (!CLOCK_IsPllEnabled(CCM_ANALOG, pll))
60006cb2:	f013 0301 	ands.w	r3, r3, #1
60006cb6:	d01b      	beq.n	60006cf0 <CLOCK_GetPllFreq+0x60>
 * @param pll PLL control name (see @ref ccm_analog_pll_control_t enumeration)
 * @retval bypass reference clock frequency value.
 */
static inline uint32_t CLOCK_GetPllBypassRefClk(CCM_ANALOG_Type *base, clock_pll_t pll)
{
    return (((CCM_ANALOG_TUPLE_REG(base, pll) & CCM_ANALOG_PLL_BYPASS_CLK_SRC_MASK) >>
60006cb8:	6813      	ldr	r3, [r2, #0]
             CCM_ANALOG_PLL_BYPASS_CLK_SRC_SHIFT) == (uint32_t)kCLOCK_PllClkSrc24M) ?
               CLOCK_GetOscFreq() :
60006cba:	f413 4f40 	tst.w	r3, #49152	; 0xc000
60006cbe:	d11a      	bne.n	60006cf6 <CLOCK_GetPllFreq+0x66>
60006cc0:	f7ff ff5e 	bl	60006b80 <CLOCK_GetOscFreq>
60006cc4:	4605      	mov	r5, r0
    return (bool)(CCM_ANALOG_TUPLE_REG(base, pll) & (1UL << CCM_ANALOG_PLL_BYPASS_SHIFT));
60006cc6:	6813      	ldr	r3, [r2, #0]

    /* get pll reference clock */
    freq = CLOCK_GetPllBypassRefClk(CCM_ANALOG, pll);

    /* check if pll is bypassed */
    if (CLOCK_IsPllBypassed(CCM_ANALOG, pll))
60006cc8:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
60006ccc:	f040 8099 	bne.w	60006e02 <CLOCK_GetPllFreq+0x172>
    {
        return freq;
    }

    switch (pll)
60006cd0:	4a4f      	ldr	r2, [pc, #316]	; (60006e10 <CLOCK_GetPllFreq+0x180>)
60006cd2:	4294      	cmp	r4, r2
60006cd4:	d05e      	beq.n	60006d94 <CLOCK_GetPllFreq+0x104>
60006cd6:	d822      	bhi.n	60006d1e <CLOCK_GetPllFreq+0x8e>
60006cd8:	f5a2 02a0 	sub.w	r2, r2, #5242880	; 0x500000
60006cdc:	4294      	cmp	r4, r2
60006cde:	f000 808d 	beq.w	60006dfc <CLOCK_GetPllFreq+0x16c>
60006ce2:	d80a      	bhi.n	60006cfa <CLOCK_GetPllFreq+0x6a>
60006ce4:	2c0d      	cmp	r4, #13
60006ce6:	d045      	beq.n	60006d74 <CLOCK_GetPllFreq+0xe4>
60006ce8:	f5a2 1280 	sub.w	r2, r2, #1048576	; 0x100000
60006cec:	4294      	cmp	r4, r2
60006cee:	d048      	beq.n	60006d82 <CLOCK_GetPllFreq+0xf2>
            freq = 0U;
            break;
    }

    return freq;
}
60006cf0:	4618      	mov	r0, r3
60006cf2:	b004      	add	sp, #16
60006cf4:	bd70      	pop	{r4, r5, r6, pc}
               CLOCK_GetOscFreq() :
60006cf6:	2500      	movs	r5, #0
60006cf8:	e7e5      	b.n	60006cc6 <CLOCK_GetPllFreq+0x36>
    switch (pll)
60006cfa:	4a46      	ldr	r2, [pc, #280]	; (60006e14 <CLOCK_GetPllFreq+0x184>)
60006cfc:	4294      	cmp	r4, r2
60006cfe:	d1f7      	bne.n	60006cf0 <CLOCK_GetPllFreq+0x60>
            freqTmp = ((clock_64b_t)freq * ((clock_64b_t)(CCM_ANALOG->PLL_SYS_NUM)));
60006d00:	4c45      	ldr	r4, [pc, #276]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
60006d02:	6d20      	ldr	r0, [r4, #80]	; 0x50
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_SYS_DENOM));
60006d04:	6e22      	ldr	r2, [r4, #96]	; 0x60
60006d06:	fba5 0100 	umull	r0, r1, r5, r0
60006d0a:	f7fb fad9 	bl	600022c0 <__aeabi_uldivmod>
            if ((CCM_ANALOG->PLL_SYS & CCM_ANALOG_PLL_SYS_DIV_SELECT_MASK) != 0U)
60006d0e:	6b23      	ldr	r3, [r4, #48]	; 0x30
60006d10:	07db      	lsls	r3, r3, #31
                freq *= 22U;
60006d12:	bf4c      	ite	mi
60006d14:	2316      	movmi	r3, #22
                freq *= 20U;
60006d16:	2314      	movpl	r3, #20
60006d18:	436b      	muls	r3, r5
            freq += (uint32_t)freqTmp;
60006d1a:	4403      	add	r3, r0
            break;
60006d1c:	e7e8      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
    switch (pll)
60006d1e:	4a3f      	ldr	r2, [pc, #252]	; (60006e1c <CLOCK_GetPllFreq+0x18c>)
60006d20:	4294      	cmp	r4, r2
60006d22:	d060      	beq.n	60006de6 <CLOCK_GetPllFreq+0x156>
60006d24:	3208      	adds	r2, #8
60006d26:	4294      	cmp	r4, r2
60006d28:	d06d      	beq.n	60006e06 <CLOCK_GetPllFreq+0x176>
60006d2a:	4a3d      	ldr	r2, [pc, #244]	; (60006e20 <CLOCK_GetPllFreq+0x190>)
60006d2c:	4294      	cmp	r4, r2
60006d2e:	d1df      	bne.n	60006cf0 <CLOCK_GetPllFreq+0x60>
                (CCM_ANALOG->PLL_VIDEO & CCM_ANALOG_PLL_VIDEO_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_VIDEO_DIV_SELECT_SHIFT;
60006d30:	4c39      	ldr	r4, [pc, #228]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
60006d32:	f8d4 60a0 	ldr.w	r6, [r4, #160]	; 0xa0
            freqTmp = ((clock_64b_t)freq * ((clock_64b_t)(CCM_ANALOG->PLL_VIDEO_NUM)));
60006d36:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_VIDEO_DENOM));
60006d3a:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
            divSelect =
60006d3e:	f006 067f 	and.w	r6, r6, #127	; 0x7f
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_VIDEO_DENOM));
60006d42:	fba5 0100 	umull	r0, r1, r5, r0
60006d46:	f7fb fabb 	bl	600022c0 <__aeabi_uldivmod>
            switch (CCM_ANALOG->PLL_VIDEO & CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_MASK)
60006d4a:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
            freq = freq * divSelect + (uint32_t)freqTmp;
60006d4e:	436e      	muls	r6, r5
60006d50:	f412 12c0 	ands.w	r2, r2, #1572864	; 0x180000
60006d54:	eb06 0300 	add.w	r3, r6, r0
            switch (CCM_ANALOG->PLL_VIDEO & CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_MASK)
60006d58:	d041      	beq.n	60006dde <CLOCK_GetPllFreq+0x14e>
60006d5a:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
60006d5e:	d040      	beq.n	60006de2 <CLOCK_GetPllFreq+0x152>
            switch (CCM_ANALOG->MISC2 & CCM_ANALOG_MISC2_VIDEO_DIV_MASK)
60006d60:	f8d4 2170 	ldr.w	r2, [r4, #368]	; 0x170
60006d64:	f002 4240 	and.w	r2, r2, #3221225472	; 0xc0000000
60006d68:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
60006d6c:	d007      	beq.n	60006d7e <CLOCK_GetPllFreq+0xee>
60006d6e:	f1b2 4f40 	cmp.w	r2, #3221225472	; 0xc0000000
60006d72:	e02d      	b.n	60006dd0 <CLOCK_GetPllFreq+0x140>
            freq = ((freq * ((CCM_ANALOG->PLL_ARM & CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK) >>
60006d74:	4b28      	ldr	r3, [pc, #160]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
60006d76:	681b      	ldr	r3, [r3, #0]
60006d78:	f003 037f 	and.w	r3, r3, #127	; 0x7f
60006d7c:	436b      	muls	r3, r5
                    freq >>= 1U;
60006d7e:	085b      	lsrs	r3, r3, #1
                    break;
60006d80:	e7b6      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
            freq = (freq * (((CCM_ANALOG->PLL_USB1 & CCM_ANALOG_PLL_USB1_DIV_SELECT_MASK) != 0UL) ? 22U : 20U));
60006d82:	4b25      	ldr	r3, [pc, #148]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
60006d84:	691b      	ldr	r3, [r3, #16]
            freq = (freq * (((CCM_ANALOG->PLL_USB2 & CCM_ANALOG_PLL_USB2_DIV_SELECT_MASK) != 0U) ? 22U : 20U));
60006d86:	f013 0f02 	tst.w	r3, #2
60006d8a:	bf14      	ite	ne
60006d8c:	2316      	movne	r3, #22
60006d8e:	2314      	moveq	r3, #20
60006d90:	436b      	muls	r3, r5
            break;
60006d92:	e7ad      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
                (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_AUDIO_DIV_SELECT_SHIFT;
60006d94:	4c20      	ldr	r4, [pc, #128]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
60006d96:	6f26      	ldr	r6, [r4, #112]	; 0x70
            freqTmp = ((clock_64b_t)freq * ((clock_64b_t)(CCM_ANALOG->PLL_AUDIO_NUM)));
60006d98:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_AUDIO_DENOM));
60006d9c:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
            divSelect =
60006da0:	f006 067f 	and.w	r6, r6, #127	; 0x7f
            freqTmp /= ((clock_64b_t)(CCM_ANALOG->PLL_AUDIO_DENOM));
60006da4:	fba5 0100 	umull	r0, r1, r5, r0
60006da8:	f7fb fa8a 	bl	600022c0 <__aeabi_uldivmod>
            switch (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_MASK)
60006dac:	6f22      	ldr	r2, [r4, #112]	; 0x70
            freq = freq * divSelect + (uint32_t)freqTmp;
60006dae:	436e      	muls	r6, r5
60006db0:	f412 12c0 	ands.w	r2, r2, #1572864	; 0x180000
60006db4:	eb06 0300 	add.w	r3, r6, r0
            switch (CCM_ANALOG->PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_MASK)
60006db8:	d00d      	beq.n	60006dd6 <CLOCK_GetPllFreq+0x146>
60006dba:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
60006dbe:	d00c      	beq.n	60006dda <CLOCK_GetPllFreq+0x14a>
            switch (CCM_ANALOG->MISC2 & (CCM_ANALOG_MISC2_AUDIO_DIV_MSB_MASK | CCM_ANALOG_MISC2_AUDIO_DIV_LSB_MASK))
60006dc0:	f8d4 2170 	ldr.w	r2, [r4, #368]	; 0x170
60006dc4:	4917      	ldr	r1, [pc, #92]	; (60006e24 <CLOCK_GetPllFreq+0x194>)
60006dc6:	400a      	ands	r2, r1
60006dc8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
60006dcc:	d0d7      	beq.n	60006d7e <CLOCK_GetPllFreq+0xee>
60006dce:	428a      	cmp	r2, r1
60006dd0:	d18e      	bne.n	60006cf0 <CLOCK_GetPllFreq+0x60>
                    freq >>= 2U;
60006dd2:	089b      	lsrs	r3, r3, #2
                    break;
60006dd4:	e78c      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
                    freq = freq >> 2U;
60006dd6:	089b      	lsrs	r3, r3, #2
                    break;
60006dd8:	e7f2      	b.n	60006dc0 <CLOCK_GetPllFreq+0x130>
                    freq = freq >> 1U;
60006dda:	085b      	lsrs	r3, r3, #1
                    break;
60006ddc:	e7f0      	b.n	60006dc0 <CLOCK_GetPllFreq+0x130>
                    freq = freq >> 2U;
60006dde:	089b      	lsrs	r3, r3, #2
                    break;
60006de0:	e7be      	b.n	60006d60 <CLOCK_GetPllFreq+0xd0>
                    freq = freq >> 1U;
60006de2:	085b      	lsrs	r3, r3, #1
                    break;
60006de4:	e7bc      	b.n	60006d60 <CLOCK_GetPllFreq+0xd0>
                (CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_ENET_DIV_SELECT_SHIFT;
60006de6:	4b0c      	ldr	r3, [pc, #48]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
            freq = enetRefClkFreq[divSelect];
60006de8:	aa04      	add	r2, sp, #16
                (CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_DIV_SELECT_MASK) >> CCM_ANALOG_PLL_ENET_DIV_SELECT_SHIFT;
60006dea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
            divSelect =
60006dee:	f003 0303 	and.w	r3, r3, #3
            freq = enetRefClkFreq[divSelect];
60006df2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
60006df6:	f853 3c10 	ldr.w	r3, [r3, #-16]
            break;
60006dfa:	e779      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
            freq = (freq * (((CCM_ANALOG->PLL_USB2 & CCM_ANALOG_PLL_USB2_DIV_SELECT_MASK) != 0U) ? 22U : 20U));
60006dfc:	4b06      	ldr	r3, [pc, #24]	; (60006e18 <CLOCK_GetPllFreq+0x188>)
60006dfe:	6a1b      	ldr	r3, [r3, #32]
60006e00:	e7c1      	b.n	60006d86 <CLOCK_GetPllFreq+0xf6>
        return freq;
60006e02:	462b      	mov	r3, r5
60006e04:	e774      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
            freq = 25000000UL;
60006e06:	4b08      	ldr	r3, [pc, #32]	; (60006e28 <CLOCK_GetPllFreq+0x198>)
60006e08:	e772      	b.n	60006cf0 <CLOCK_GetPllFreq+0x60>
60006e0a:	bf00      	nop
60006e0c:	6000d008 	.word	0x6000d008
60006e10:	0070000d 	.word	0x0070000d
60006e14:	0030000d 	.word	0x0030000d
60006e18:	400d8000 	.word	0x400d8000
60006e1c:	00e0000d 	.word	0x00e0000d
60006e20:	00a0000d 	.word	0x00a0000d
60006e24:	00808000 	.word	0x00808000
60006e28:	017d7840 	.word	0x017d7840

60006e2c <CLOCK_ControlGate>:
{
60006e2c:	b530      	push	{r4, r5, lr}
    *reg = ((*reg) & ~((uint32_t)(3UL << shift))) | (((uint32_t)value) << shift);
60006e2e:	2203      	movs	r2, #3
    uint32_t shift = ((uint32_t)name) & 0x1FU;
60006e30:	f000 051f 	and.w	r5, r0, #31
    reg  = (volatile uint32_t *)(&(((volatile uint32_t *)&CCM->CCGR0)[index]));
60006e34:	4c05      	ldr	r4, [pc, #20]	; (60006e4c <CLOCK_ControlGate+0x20>)
    uint32_t index = ((uint32_t)name) >> 8U;
60006e36:	0a00      	lsrs	r0, r0, #8
    *reg = ((*reg) & ~((uint32_t)(3UL << shift))) | (((uint32_t)value) << shift);
60006e38:	40aa      	lsls	r2, r5
60006e3a:	40a9      	lsls	r1, r5
60006e3c:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
60006e40:	ea23 0302 	bic.w	r3, r3, r2
60006e44:	430b      	orrs	r3, r1
60006e46:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
}
60006e4a:	bd30      	pop	{r4, r5, pc}
60006e4c:	400fc068 	.word	0x400fc068

60006e50 <LPUART_GetInstance>:
 *
 * param base LPUART peripheral base address.
 * return LPUART instance.
 */
uint32_t LPUART_GetInstance(LPUART_Type *base)
{
60006e50:	4603      	mov	r3, r0
60006e52:	4a05      	ldr	r2, [pc, #20]	; (60006e68 <LPUART_GetInstance+0x18>)
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0U; instance < ARRAY_SIZE(s_lpuartBases); instance++)
60006e54:	2000      	movs	r0, #0
    {
        if (s_lpuartBases[instance] == base)
60006e56:	f852 1b04 	ldr.w	r1, [r2], #4
60006e5a:	4299      	cmp	r1, r3
60006e5c:	d002      	beq.n	60006e64 <LPUART_GetInstance+0x14>
    for (instance = 0U; instance < ARRAY_SIZE(s_lpuartBases); instance++)
60006e5e:	3001      	adds	r0, #1
60006e60:	2809      	cmp	r0, #9
60006e62:	d1f8      	bne.n	60006e56 <LPUART_GetInstance+0x6>
    }

    assert(instance < ARRAY_SIZE(s_lpuartBases));

    return instance;
}
60006e64:	4770      	bx	lr
60006e66:	bf00      	nop
60006e68:	6000d6b4 	.word	0x6000d6b4

60006e6c <LPUART_Init>:
 * param srcClock_Hz LPUART clock source frequency in HZ.
 * retval kStatus_LPUART_BaudrateNotSupport Baudrate is not support in current clock source.
 * retval kStatus_Success LPUART initialize succeed
 */
status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz)
{
60006e6c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     * The idea is to use the best OSR (over-sampling rate) possible
     * Note, OSR is typically hard-set to 16 in other LPUART instantiations
     * loop to find the best OSR value possible, one that generates minimum baudDiff
     * iterate through the rest of the supported values of OSR */

    baudDiff = config->baudRate_Bps;
60006e70:	680b      	ldr	r3, [r1, #0]
    osr      = 0U;
    sbr      = 0U;
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
    {
        /* calculate the temporary sbr value   */
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
60006e72:	f04f 090a 	mov.w	r9, #10
    osr      = 0U;
60006e76:	2600      	movs	r6, #0
{
60006e78:	4604      	mov	r4, r0
60006e7a:	460d      	mov	r5, r1
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
60006e7c:	fb09 fa02 	mul.w	sl, r9, r2
60006e80:	ea4f 0883 	mov.w	r8, r3, lsl #2
    baudDiff = config->baudRate_Bps;
60006e84:	469e      	mov	lr, r3
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
60006e86:	f04f 0c04 	mov.w	ip, #4
    sbr      = 0U;
60006e8a:	4637      	mov	r7, r6
60006e8c:	fa5f fb8c 	uxtb.w	fp, ip
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
60006e90:	fbba f1f8 	udiv	r1, sl, r8
60006e94:	3105      	adds	r1, #5
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
60006e96:	4498      	add	r8, r3
        sbrTemp = (uint16_t)((srcClock_Hz * 10U / (config->baudRate_Bps * (uint32_t)osrTemp) + 5U) / 10U);
60006e98:	fbb1 f1f9 	udiv	r1, r1, r9
60006e9c:	b289      	uxth	r1, r1
        /*set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate*/
        if (sbrTemp == 0U)
60006e9e:	2901      	cmp	r1, #1
60006ea0:	bf38      	it	cc
60006ea2:	2101      	movcc	r1, #1
        {
            sbrTemp = 1U;
        }
        /* Calculate the baud rate based on the temporary OSR and SBR values */
        calculatedBaud = (srcClock_Hz / ((uint32_t)osrTemp * (uint32_t)sbrTemp));
60006ea4:	fb0c f001 	mul.w	r0, ip, r1
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
60006ea8:	f10c 0c01 	add.w	ip, ip, #1
        calculatedBaud = (srcClock_Hz / ((uint32_t)osrTemp * (uint32_t)sbrTemp));
60006eac:	fbb2 f0f0 	udiv	r0, r2, r0
        tempDiff       = calculatedBaud > config->baudRate_Bps ? (calculatedBaud - config->baudRate_Bps) :
60006eb0:	4283      	cmp	r3, r0
60006eb2:	bf34      	ite	cc
60006eb4:	1ac0      	subcc	r0, r0, r3
60006eb6:	1a18      	subcs	r0, r3, r0
                                                           (config->baudRate_Bps - calculatedBaud);

        if (tempDiff <= baudDiff)
60006eb8:	4570      	cmp	r0, lr
60006eba:	bf9e      	ittt	ls
60006ebc:	4686      	movls	lr, r0
60006ebe:	465e      	movls	r6, fp
        {
            baudDiff = tempDiff;
            osr      = osrTemp; /* update and store the best OSR value calculated */
            sbr      = sbrTemp; /* update store the best SBR value calculated */
60006ec0:	460f      	movls	r7, r1
    for (osrTemp = 4U; osrTemp <= 32U; osrTemp++)
60006ec2:	f1bc 0f21 	cmp.w	ip, #33	; 0x21
60006ec6:	d1e1      	bne.n	60006e8c <LPUART_Init+0x20>
        }
    }

    /* Check to see if actual baud rate is within 3% of desired baud rate
     * based on the best calculate OSR value */
    if (baudDiff > ((config->baudRate_Bps / 100U) * 3U))
60006ec8:	2264      	movs	r2, #100	; 0x64
60006eca:	fbb3 f3f2 	udiv	r3, r3, r2
60006ece:	eb03 0343 	add.w	r3, r3, r3, lsl #1
60006ed2:	4573      	cmp	r3, lr
60006ed4:	f0c0 808e 	bcc.w	60006ff4 <LPUART_Init+0x188>
    }
    else
    {
#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)

        uint32_t instance = LPUART_GetInstance(base);
60006ed8:	4620      	mov	r0, r4
        temp &= ~LPUART_BAUD_OSR_MASK;
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);

        /* write the sbr value to the BAUD registers */
        temp &= ~LPUART_BAUD_SBR_MASK;
        base->BAUD = temp | LPUART_BAUD_SBR(sbr);
60006eda:	f3c7 070c 	ubfx	r7, r7, #0, #13
        uint32_t instance = LPUART_GetInstance(base);
60006ede:	f7ff ffb7 	bl	60006e50 <LPUART_GetInstance>
    CLOCK_ControlGate(name, kCLOCK_ClockNeededRunWait);
60006ee2:	4b46      	ldr	r3, [pc, #280]	; (60006ffc <LPUART_Init+0x190>)
60006ee4:	2103      	movs	r1, #3
60006ee6:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
60006eea:	f7ff ff9f 	bl	60006e2c <CLOCK_ControlGate>
 *
 * @param base LPUART peripheral base address.
 */
static inline void LPUART_SoftwareReset(LPUART_Type *base)
{
    base->GLOBAL |= LPUART_GLOBAL_RST_MASK;
60006eee:	68a3      	ldr	r3, [r4, #8]
        if ((osr > 3U) && (osr < 8U))
60006ef0:	1f32      	subs	r2, r6, #4
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);
60006ef2:	3e01      	subs	r6, #1
60006ef4:	f043 0302 	orr.w	r3, r3, #2
        if ((osr > 3U) && (osr < 8U))
60006ef8:	2a03      	cmp	r2, #3
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);
60006efa:	ea4f 6606 	mov.w	r6, r6, lsl #24
60006efe:	60a3      	str	r3, [r4, #8]
    base->GLOBAL &= ~LPUART_GLOBAL_RST_MASK;
60006f00:	68a3      	ldr	r3, [r4, #8]
60006f02:	f006 56f8 	and.w	r6, r6, #520093696	; 0x1f000000
60006f06:	f023 0302 	bic.w	r3, r3, #2
60006f0a:	60a3      	str	r3, [r4, #8]
        temp = base->BAUD;
60006f0c:	6923      	ldr	r3, [r4, #16]
            temp |= LPUART_BAUD_BOTHEDGE_MASK;
60006f0e:	bf98      	it	ls
60006f10:	f443 3300 	orrls.w	r3, r3, #131072	; 0x20000
        temp |= LPUART_BAUD_OSR((uint32_t)osr - 1UL);
60006f14:	f023 231f 	bic.w	r3, r3, #520101632	; 0x1f001f00
60006f18:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
        temp &= ~LPUART_BAUD_SBR_MASK;
60006f1c:	431e      	orrs	r6, r3
        base->BAUD = temp | LPUART_BAUD_SBR(sbr);
60006f1e:	433e      	orrs	r6, r7
60006f20:	6126      	str	r6, [r4, #16]

        /* Set bit count and parity mode. */
        base->BAUD &= ~LPUART_BAUD_M10_MASK;
60006f22:	6923      	ldr	r3, [r4, #16]
60006f24:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
60006f28:	6123      	str	r3, [r4, #16]

        temp = base->CTRL & ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
60006f2a:	69a2      	ldr	r2, [r4, #24]
                              LPUART_CTRL_IDLECFG_MASK);

        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60006f2c:	7beb      	ldrb	r3, [r5, #15]
        temp = base->CTRL & ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
60006f2e:	f422 62e2 	bic.w	r2, r2, #1808	; 0x710
        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60006f32:	7929      	ldrb	r1, [r5, #4]
60006f34:	021b      	lsls	r3, r3, #8
        temp = base->CTRL & ~(LPUART_CTRL_PE_MASK | LPUART_CTRL_PT_MASK | LPUART_CTRL_M_MASK | LPUART_CTRL_ILT_MASK |
60006f36:	f022 0207 	bic.w	r2, r2, #7
        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60006f3a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
60006f3e:	430a      	orrs	r2, r1
60006f40:	431a      	orrs	r2, r3
                LPUART_CTRL_ILT(config->rxIdleType);
60006f42:	7bab      	ldrb	r3, [r5, #14]
60006f44:	009b      	lsls	r3, r3, #2
60006f46:	f003 0304 	and.w	r3, r3, #4
        temp |= (uint8_t)config->parityMode | LPUART_CTRL_IDLECFG(config->rxIdleConfig) |
60006f4a:	4313      	orrs	r3, r2

#if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
        if (kLPUART_SevenDataBits == config->dataBitsCount)
60006f4c:	796a      	ldrb	r2, [r5, #5]
60006f4e:	2a01      	cmp	r2, #1
60006f50:	d14b      	bne.n	60006fea <LPUART_Init+0x17e>
        {
            if (kLPUART_ParityDisabled != config->parityMode)
60006f52:	2900      	cmp	r1, #0
60006f54:	d046      	beq.n	60006fe4 <LPUART_Init+0x178>
            {
                temp &= ~LPUART_CTRL_M7_MASK; /* Seven data bits and one parity bit */
60006f56:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
            {
                temp |= LPUART_CTRL_M_MASK; /* Eight data bits and one parity bit */
            }
        }

        base->CTRL = temp;
60006f5a:	61a3      	str	r3, [r4, #24]

#if defined(FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPUART_HAS_STOP_BIT_CONFIG_SUPPORT
        /* set stop bit per char */
        temp       = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
        base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
60006f5c:	79eb      	ldrb	r3, [r5, #7]
        temp       = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
60006f5e:	6922      	ldr	r2, [r4, #16]
        base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
60006f60:	035b      	lsls	r3, r3, #13
        temp       = base->BAUD & ~LPUART_BAUD_SBNS_MASK;
60006f62:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
        base->BAUD = temp | LPUART_BAUD_SBNS((uint8_t)config->stopBitCount);
60006f66:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
60006f6a:	4313      	orrs	r3, r2
60006f6c:	6123      	str	r3, [r4, #16]
           mark larger than 1.
           For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
           5 bytes are received. the last byte will be saved in FIFO but not trigger
           RX interrupt because the water mark is 2.
         */
        base->WATER = (((uint32_t)(config->rxFifoWatermark) << 16U) | config->txFifoWatermark);
60006f6e:	7a6a      	ldrb	r2, [r5, #9]
60006f70:	7a2b      	ldrb	r3, [r5, #8]
60006f72:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
60006f76:	62e3      	str	r3, [r4, #44]	; 0x2c

        /* Enable tx/rx FIFO */
        base->FIFO |= (LPUART_FIFO_TXFE_MASK | LPUART_FIFO_RXFE_MASK);
60006f78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60006f7a:	f043 0388 	orr.w	r3, r3, #136	; 0x88
60006f7e:	62a3      	str	r3, [r4, #40]	; 0x28

        /* Flush FIFO */
        base->FIFO |= (LPUART_FIFO_TXFLUSH_MASK | LPUART_FIFO_RXFLUSH_MASK);
60006f80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
60006f82:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
60006f86:	62a3      	str	r3, [r4, #40]	; 0x28
        temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
#endif

#if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT
        /* Set the CTS configuration/TX CTS source. */
        base->MODIR |= LPUART_MODIR_TXCTSC(config->txCtsConfig) | LPUART_MODIR_TXCTSSRC(config->txCtsSource);
60006f88:	7b6b      	ldrb	r3, [r5, #13]
60006f8a:	7b2a      	ldrb	r2, [r5, #12]
60006f8c:	011b      	lsls	r3, r3, #4
60006f8e:	6a61      	ldr	r1, [r4, #36]	; 0x24
60006f90:	0152      	lsls	r2, r2, #5
60006f92:	f003 0310 	and.w	r3, r3, #16
60006f96:	f002 0220 	and.w	r2, r2, #32
60006f9a:	4313      	orrs	r3, r2
60006f9c:	430b      	orrs	r3, r1
60006f9e:	6263      	str	r3, [r4, #36]	; 0x24
        if (true == config->enableRxRTS)
60006fa0:	7aab      	ldrb	r3, [r5, #10]
60006fa2:	b11b      	cbz	r3, 60006fac <LPUART_Init+0x140>
        {
            /* Enable the receiver RTS(request-to-send) function. */
            base->MODIR |= LPUART_MODIR_RXRTSE_MASK;
60006fa4:	6a63      	ldr	r3, [r4, #36]	; 0x24
60006fa6:	f043 0308 	orr.w	r3, r3, #8
60006faa:	6263      	str	r3, [r4, #36]	; 0x24
        }
        if (true == config->enableTxCTS)
60006fac:	7aeb      	ldrb	r3, [r5, #11]
60006fae:	b11b      	cbz	r3, 60006fb8 <LPUART_Init+0x14c>
        {
            /* Enable the CTS(clear-to-send) function. */
            base->MODIR |= LPUART_MODIR_TXCTSE_MASK;
60006fb0:	6a63      	ldr	r3, [r4, #36]	; 0x24
60006fb2:	f043 0301 	orr.w	r3, r3, #1
60006fb6:	6263      	str	r3, [r4, #36]	; 0x24
        }
#endif

        /* Set data bits order. */
        if (true == config->isMsb)
60006fb8:	79a9      	ldrb	r1, [r5, #6]
        {
            temp |= LPUART_STAT_MSBF_MASK;
        }
        else
        {
            temp &= ~LPUART_STAT_MSBF_MASK;
60006fba:	4b11      	ldr	r3, [pc, #68]	; (60007000 <LPUART_Init+0x194>)
60006fbc:	4a11      	ldr	r2, [pc, #68]	; (60007004 <LPUART_Init+0x198>)
60006fbe:	2900      	cmp	r1, #0
60006fc0:	bf18      	it	ne
60006fc2:	461a      	movne	r2, r3
        }

        base->STAT |= temp;
60006fc4:	6963      	ldr	r3, [r4, #20]
60006fc6:	4313      	orrs	r3, r2

        /* Enable TX/RX base on configure structure. */
        temp = base->CTRL;
        if (true == config->enableTx)
60006fc8:	7c2a      	ldrb	r2, [r5, #16]
        base->STAT |= temp;
60006fca:	6163      	str	r3, [r4, #20]
        temp = base->CTRL;
60006fcc:	69a3      	ldr	r3, [r4, #24]
        if (true == config->enableTx)
60006fce:	b10a      	cbz	r2, 60006fd4 <LPUART_Init+0x168>
        {
            temp |= LPUART_CTRL_TE_MASK;
60006fd0:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
        }

        if (true == config->enableRx)
60006fd4:	7c6a      	ldrb	r2, [r5, #17]
60006fd6:	b10a      	cbz	r2, 60006fdc <LPUART_Init+0x170>
        {
            temp |= LPUART_CTRL_RE_MASK;
60006fd8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    status_t status = kStatus_Success;
60006fdc:	2000      	movs	r0, #0
        }

        base->CTRL = temp;
60006fde:	61a3      	str	r3, [r4, #24]
    }

    return status;
}
60006fe0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                temp |= LPUART_CTRL_M7_MASK;
60006fe4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
60006fe8:	e7b7      	b.n	60006f5a <LPUART_Init+0xee>
            if (kLPUART_ParityDisabled != config->parityMode)
60006fea:	2900      	cmp	r1, #0
60006fec:	d0b5      	beq.n	60006f5a <LPUART_Init+0xee>
                temp |= LPUART_CTRL_M_MASK; /* Eight data bits and one parity bit */
60006fee:	f043 0310 	orr.w	r3, r3, #16
60006ff2:	e7b2      	b.n	60006f5a <LPUART_Init+0xee>
        status = kStatus_LPUART_BaudrateNotSupport;
60006ff4:	f240 5021 	movw	r0, #1313	; 0x521
    return status;
60006ff8:	e7f2      	b.n	60006fe0 <LPUART_Init+0x174>
60006ffa:	bf00      	nop
60006ffc:	6000d704 	.word	0x6000d704
60007000:	e01fc000 	.word	0xe01fc000
60007004:	c01fc000 	.word	0xc01fc000

60007008 <LPUART_Deinit>:
 * This function waits for transmit to complete, disables TX and RX, and disables the LPUART clock.
 *
 * param base LPUART peripheral base address.
 */
void LPUART_Deinit(LPUART_Type *base)
{
60007008:	b510      	push	{r4, lr}
    uint32_t temp;

#if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    /* Wait tx FIFO send out*/
    while (0U != ((base->WATER & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXWATER_SHIFT))
6000700a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
6000700c:	f413 6fe0 	tst.w	r3, #1792	; 0x700
60007010:	d1fb      	bne.n	6000700a <LPUART_Deinit+0x2>
    {
    }
#endif
    /* Wait last char shift out */
    while (0U == (base->STAT & LPUART_STAT_TC_MASK))
60007012:	6943      	ldr	r3, [r0, #20]
60007014:	025b      	lsls	r3, r3, #9
60007016:	d5fc      	bpl.n	60007012 <LPUART_Deinit+0xa>

#if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
    temp |= (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK);
#endif

    base->STAT |= temp;
60007018:	6943      	ldr	r3, [r0, #20]

    /* Disable the module. */
    base->CTRL = 0U;
6000701a:	2400      	movs	r4, #0
    base->STAT |= temp;
6000701c:	f043 23c0 	orr.w	r3, r3, #3221274624	; 0xc000c000
60007020:	f443 13f8 	orr.w	r3, r3, #2031616	; 0x1f0000
60007024:	6143      	str	r3, [r0, #20]
    base->CTRL = 0U;
60007026:	6184      	str	r4, [r0, #24]

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    uint32_t instance = LPUART_GetInstance(base);
60007028:	f7ff ff12 	bl	60006e50 <LPUART_GetInstance>
    CLOCK_ControlGate(name, kCLOCK_ClockNotNeeded);
6000702c:	4b03      	ldr	r3, [pc, #12]	; (6000703c <LPUART_Deinit+0x34>)
6000702e:	4621      	mov	r1, r4
60007030:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
#if defined(LPUART_PERIPH_CLOCKS)
    CLOCK_DisableClock(s_lpuartPeriphClocks[instance]);
#endif

#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}
60007034:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
60007038:	f7ff bef8 	b.w	60006e2c <CLOCK_ControlGate>
6000703c:	6000d704 	.word	0x6000d704

60007040 <LPUART_ClearStatusFlags>:
 * retval kStatus_LPUART_FlagCannotClearManually The flag can't be cleared by this function but
 *         it is cleared automatically by hardware.
 * retval kStatus_Success Status in the mask are cleared.
 */
status_t LPUART_ClearStatusFlags(LPUART_Type *base, uint32_t mask)
{
60007040:	b510      	push	{r4, lr}
    uint32_t temp;
    status_t status;
#if defined(FSL_FEATURE_LPUART_HAS_FIFO) && FSL_FEATURE_LPUART_HAS_FIFO
    temp = (uint32_t)base->FIFO;
    temp &= (uint32_t)(~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK));
    temp |= (mask << 16U) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
60007042:	040b      	lsls	r3, r1, #16
    temp = (uint32_t)base->FIFO;
60007044:	6a84      	ldr	r4, [r0, #40]	; 0x28
    temp |= (mask << 16U) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
60007046:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
    temp &= (uint32_t)(~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK));
6000704a:	f424 3440 	bic.w	r4, r4, #196608	; 0x30000
    temp |= (mask << 16U) & (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK);
6000704e:	4323      	orrs	r3, r4
    base->FIFO = temp;
#endif
    temp = (uint32_t)base->STAT;
#if defined(FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPUART_HAS_LIN_BREAK_DETECT
    temp &= (uint32_t)(~(LPUART_STAT_LBKDIF_MASK));
    temp |= mask & LPUART_STAT_LBKDIF_MASK;
60007050:	f001 4400 	and.w	r4, r1, #2147483648	; 0x80000000
    base->FIFO = temp;
60007054:	6283      	str	r3, [r0, #40]	; 0x28
    temp = (uint32_t)base->STAT;
60007056:	6943      	ldr	r3, [r0, #20]
    temp |= mask & LPUART_STAT_LBKDIF_MASK;
60007058:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
6000705c:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
#endif
    temp &= (uint32_t)(~(LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF_MASK |
60007060:	4323      	orrs	r3, r4
                         LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK));
    temp |= mask & (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_NF_MASK |
60007062:	4c08      	ldr	r4, [pc, #32]	; (60007084 <LPUART_ClearStatusFlags+0x44>)
60007064:	400c      	ands	r4, r1
60007066:	4323      	orrs	r3, r4
                    LPUART_STAT_FE_MASK | LPUART_STAT_PF_MASK);
#if defined(FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING) && FSL_FEATURE_LPUART_HAS_ADDRESS_MATCHING
    temp &= (uint32_t)(~(LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK));
    temp |= mask & (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK);
60007068:	f401 4440 	and.w	r4, r1, #49152	; 0xc000
    temp &= (uint32_t)(~(LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK));
6000706c:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
    temp |= mask & (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK);
60007070:	4323      	orrs	r3, r4
#endif
    base->STAT = temp;
60007072:	6143      	str	r3, [r0, #20]
    /* If some flags still pending. */
    if (0U != (mask & LPUART_GetStatusFlags(base)))
60007074:	f004 ffbe 	bl	6000bff4 <LPUART_GetStatusFlags>
        kLPUART_TxFifoEmptyFlag, kLPUART_RxFifoEmptyFlag. */
        status = kStatus_LPUART_FlagCannotClearManually; /* flags can not clear manually */
    }
    else
    {
        status = kStatus_Success;
60007078:	4208      	tst	r0, r1
    }

    return status;
}
6000707a:	f240 501a 	movw	r0, #1306	; 0x51a
6000707e:	bf08      	it	eq
60007080:	2000      	moveq	r0, #0
60007082:	bd10      	pop	{r4, pc}
60007084:	401f0000 	.word	0x401f0000

60007088 <_DoInit>:
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
60007088:	2303      	movs	r3, #3
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
6000708a:	4a12      	ldr	r2, [pc, #72]	; (600070d4 <_DoInit+0x4c>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
6000708c:	4912      	ldr	r1, [pc, #72]	; (600070d8 <_DoInit+0x50>)
static void _DoInit(void) {
6000708e:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
60007090:	4c12      	ldr	r4, [pc, #72]	; (600070dc <_DoInit+0x54>)
60007092:	6123      	str	r3, [r4, #16]
  STRCPY((char*)&p->acID[7], "RTT");
60007094:	1de0      	adds	r0, r4, #7
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
60007096:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
60007098:	f104 03a8 	add.w	r3, r4, #168	; 0xa8
  p->aUp[0].sName         = "Terminal";
6000709c:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
6000709e:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
600070a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
600070a4:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
600070a6:	2300      	movs	r3, #0
600070a8:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
600070aa:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
600070ac:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].sName         = "Terminal";
600070ae:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
600070b0:	f504 6295 	add.w	r2, r4, #1192	; 0x4a8
600070b4:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
600070b6:	2210      	movs	r2, #16
600070b8:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
600070ba:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
600070bc:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
600070be:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
600070c0:	f004 fbc8 	bl	6000b854 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
600070c4:	4906      	ldr	r1, [pc, #24]	; (600070e0 <_DoInit+0x58>)
600070c6:	4620      	mov	r0, r4
600070c8:	f004 fbc4 	bl	6000b854 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
600070cc:	2320      	movs	r3, #32
600070ce:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
600070d0:	bd10      	pop	{r4, pc}
600070d2:	bf00      	nop
600070d4:	6000eaf2 	.word	0x6000eaf2
600070d8:	6000eafb 	.word	0x6000eafb
600070dc:	20000000 	.word	0x20000000
600070e0:	6000eaff 	.word	0x6000eaff

600070e4 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
600070e4:	4602      	mov	r2, r0
600070e6:	460b      	mov	r3, r1
	return z_impl_k_mutex_lock(mutex, timeout);
600070e8:	4801      	ldr	r0, [pc, #4]	; (600070f0 <k_mutex_lock.constprop.0.isra.0+0xc>)
600070ea:	f001 baa3 	b.w	60008634 <z_impl_k_mutex_lock>
600070ee:	bf00      	nop
600070f0:	8000024c 	.word	0x8000024c

600070f4 <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
600070f4:	4801      	ldr	r0, [pc, #4]	; (600070fc <k_mutex_unlock.constprop.0.isra.0+0x8>)
600070f6:	f001 bb27 	b.w	60008748 <z_impl_k_mutex_unlock>
600070fa:	bf00      	nop
600070fc:	8000024c 	.word	0x8000024c

60007100 <SEGGER_RTT_ReadNoLock>:
*    BufferSize   Size of the target application buffer.
*
*  Return value
*    Number of bytes that have been read.
*/
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
60007100:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned                WrOff;
  unsigned char*          pBuffer;
  SEGGER_RTT_BUFFER_DOWN* pRing;
  volatile char*          pSrc;
  //
  INIT();
60007104:	f8df 807c 	ldr.w	r8, [pc, #124]	; 60007184 <SEGGER_RTT_ReadNoLock+0x84>
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
60007108:	4682      	mov	sl, r0
6000710a:	4689      	mov	r9, r1
6000710c:	4616      	mov	r6, r2
  INIT();
6000710e:	f898 3000 	ldrb.w	r3, [r8]
60007112:	b90b      	cbnz	r3, 60007118 <SEGGER_RTT_ReadNoLock+0x18>
60007114:	f7ff ffb8 	bl	60007088 <_DoInit>
  pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  pBuffer = (unsigned char*)pData;
  RdOff = pRing->RdOff;
60007118:	2718      	movs	r7, #24
6000711a:	fb07 870a 	mla	r7, r7, sl, r8
6000711e:	6f3d      	ldr	r5, [r7, #112]	; 0x70
  WrOff = pRing->WrOff;
60007120:	f8d7 b06c 	ldr.w	fp, [r7, #108]	; 0x6c
  NumBytesRead = 0u;
  //
  // Read from current read position to wrap-around of buffer, first
  //
  if (RdOff > WrOff) {
60007124:	455d      	cmp	r5, fp
60007126:	d92b      	bls.n	60007180 <SEGGER_RTT_ReadNoLock+0x80>
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
60007128:	6ebc      	ldr	r4, [r7, #104]	; 0x68
    RdOff        += NumBytesRem;
    while (NumBytesRem--) {
      *pBuffer++ = *pSrc++;
    };
#else
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
6000712a:	4648      	mov	r0, r9
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
6000712c:	6e79      	ldr	r1, [r7, #100]	; 0x64
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
6000712e:	1b64      	subs	r4, r4, r5
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
60007130:	4429      	add	r1, r5
    NumBytesRem = MIN(NumBytesRem, BufferSize);
60007132:	42b4      	cmp	r4, r6
60007134:	bf28      	it	cs
60007136:	4634      	movcs	r4, r6
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
60007138:	4622      	mov	r2, r4
    NumBytesRead += NumBytesRem;
    pBuffer      += NumBytesRem;
    BufferSize   -= NumBytesRem;
    RdOff        += NumBytesRem;
6000713a:	4425      	add	r5, r4
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
6000713c:	f004 fc09 	bl	6000b952 <memcpy>
#endif
    //
    // Handle wrap-around of buffer
    //
    if (RdOff == pRing->SizeOfBuffer) {
60007140:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    pBuffer      += NumBytesRem;
60007142:	44a1      	add	r9, r4
    BufferSize   -= NumBytesRem;
60007144:	1b36      	subs	r6, r6, r4
      RdOff = 0u;
60007146:	42ab      	cmp	r3, r5
60007148:	bf08      	it	eq
6000714a:	2500      	moveq	r5, #0
    }
  }
  //
  // Read remaining items of buffer
  //
  NumBytesRem = WrOff - RdOff;
6000714c:	ebab 0205 	sub.w	r2, fp, r5
  NumBytesRem = MIN(NumBytesRem, BufferSize);
60007150:	4296      	cmp	r6, r2
60007152:	bf28      	it	cs
60007154:	4616      	movcs	r6, r2
  if (NumBytesRem > 0u) {
60007156:	b156      	cbz	r6, 6000716e <SEGGER_RTT_ReadNoLock+0x6e>
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
60007158:	2318      	movs	r3, #24
    while (NumBytesRem--) {
      *pBuffer++ = *pSrc++;
    };
#else
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
    NumBytesRead += NumBytesRem;
6000715a:	4434      	add	r4, r6
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
6000715c:	4632      	mov	r2, r6
6000715e:	4648      	mov	r0, r9
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
60007160:	fb03 830a 	mla	r3, r3, sl, r8
60007164:	6e59      	ldr	r1, [r3, #100]	; 0x64
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
60007166:	4429      	add	r1, r5
    pBuffer      += NumBytesRem;
    BufferSize   -= NumBytesRem;
    RdOff        += NumBytesRem;
60007168:	4435      	add	r5, r6
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
6000716a:	f004 fbf2 	bl	6000b952 <memcpy>
#endif
  }
  if (NumBytesRead) {
6000716e:	b124      	cbz	r4, 6000717a <SEGGER_RTT_ReadNoLock+0x7a>
    pRing->RdOff = RdOff;
60007170:	2018      	movs	r0, #24
60007172:	fb00 880a 	mla	r8, r0, sl, r8
60007176:	f8c8 5070 	str.w	r5, [r8, #112]	; 0x70
  }
  //
  return NumBytesRead;
}
6000717a:	4620      	mov	r0, r4
6000717c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  NumBytesRead = 0u;
60007180:	2400      	movs	r4, #0
60007182:	e7e3      	b.n	6000714c <SEGGER_RTT_ReadNoLock+0x4c>
60007184:	20000000 	.word	0x20000000

60007188 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
60007188:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
6000718c:	4f23      	ldr	r7, [pc, #140]	; (6000721c <SEGGER_RTT_WriteSkipNoLock+0x94>)
6000718e:	f04f 0b18 	mov.w	fp, #24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
60007192:	4614      	mov	r4, r2
60007194:	4606      	mov	r6, r0
  RdOff = pRing->RdOff;
60007196:	fb0b 7200 	mla	r2, fp, r0, r7
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
6000719a:	4688      	mov	r8, r1
  RdOff = pRing->RdOff;
6000719c:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
6000719e:	6a55      	ldr	r5, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
600071a0:	42ab      	cmp	r3, r5
600071a2:	d834      	bhi.n	6000720e <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
600071a4:	f8d2 a020 	ldr.w	sl, [r2, #32]
600071a8:	ebaa 0905 	sub.w	r9, sl, r5
600071ac:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
600071b0:	4294      	cmp	r4, r2
600071b2:	d811      	bhi.n	600071d8 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
600071b4:	f04f 0918 	mov.w	r9, #24
      memcpy((void*)pDst, pData, NumBytes);
600071b8:	4622      	mov	r2, r4
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
600071ba:	442c      	add	r4, r5
      memcpy((void*)pDst, pData, NumBytes);
600071bc:	4641      	mov	r1, r8
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
600071be:	fb06 9309 	mla	r3, r6, r9, r9
      pRing->WrOff = WrOff + NumBytes;
600071c2:	fb09 7606 	mla	r6, r9, r6, r7
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
600071c6:	443b      	add	r3, r7
600071c8:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
600071ca:	4428      	add	r0, r5
600071cc:	f004 fbc1 	bl	6000b952 <memcpy>
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
      return 1;
600071d0:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
600071d2:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
600071d4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
600071d8:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
600071da:	429c      	cmp	r4, r3
600071dc:	d81b      	bhi.n	60007216 <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
600071de:	fb00 bb0b 	mla	fp, r0, fp, fp
600071e2:	442c      	add	r4, r5
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
600071e4:	464a      	mov	r2, r9
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
600071e6:	44bb      	add	fp, r7
600071e8:	f8db 0004 	ldr.w	r0, [fp, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
600071ec:	4428      	add	r0, r5
600071ee:	f004 fbb0 	bl	6000b952 <memcpy>
      if (NumBytes) {
600071f2:	ebb4 040a 	subs.w	r4, r4, sl
600071f6:	d006      	beq.n	60007206 <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
600071f8:	4622      	mov	r2, r4
600071fa:	eb08 0109 	add.w	r1, r8, r9
600071fe:	f8db 0004 	ldr.w	r0, [fp, #4]
60007202:	f004 fba6 	bl	6000b952 <memcpy>
      pRing->WrOff = NumBytes;
60007206:	2018      	movs	r0, #24
60007208:	fb00 7606 	mla	r6, r0, r6, r7
6000720c:	e7e0      	b.n	600071d0 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
6000720e:	3b01      	subs	r3, #1
60007210:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
60007212:	42a3      	cmp	r3, r4
60007214:	d2ce      	bcs.n	600071b4 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
60007216:	2000      	movs	r0, #0
60007218:	e7dc      	b.n	600071d4 <SEGGER_RTT_WriteSkipNoLock+0x4c>
6000721a:	bf00      	nop
6000721c:	20000000 	.word	0x20000000

60007220 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
60007220:	b570      	push	{r4, r5, r6, lr}
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
60007222:	2418      	movs	r4, #24
60007224:	4b15      	ldr	r3, [pc, #84]	; (6000727c <SEGGER_RTT_WriteNoLock+0x5c>)
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
60007226:	4616      	mov	r6, r2
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
60007228:	fb00 4504 	mla	r5, r0, r4, r4
6000722c:	441d      	add	r5, r3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
6000722e:	fb04 3300 	mla	r3, r4, r0, r3
60007232:	6adc      	ldr	r4, [r3, #44]	; 0x2c
60007234:	2c01      	cmp	r4, #1
60007236:	d00e      	beq.n	60007256 <SEGGER_RTT_WriteNoLock+0x36>
60007238:	2c02      	cmp	r4, #2
6000723a:	d018      	beq.n	6000726e <SEGGER_RTT_WriteNoLock+0x4e>
6000723c:	b9e4      	cbnz	r4, 60007278 <SEGGER_RTT_WriteNoLock+0x58>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
6000723e:	4628      	mov	r0, r5
60007240:	f004 fee0 	bl	6000c004 <_GetAvailWriteSpace>
    if (Avail < NumBytes) {
60007244:	4286      	cmp	r6, r0
60007246:	d804      	bhi.n	60007252 <SEGGER_RTT_WriteNoLock+0x32>
      Status = 0u;
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
60007248:	4634      	mov	r4, r6
6000724a:	4632      	mov	r2, r6
6000724c:	4628      	mov	r0, r5
6000724e:	f004 fee2 	bl	6000c016 <_WriteNoCheck>
  }
  //
  // Finish up.
  //
  return Status;
}
60007252:	4620      	mov	r0, r4
60007254:	bd70      	pop	{r4, r5, r6, pc}
    Avail = _GetAvailWriteSpace(pRing);
60007256:	4628      	mov	r0, r5
    Status = Avail < NumBytes ? Avail : NumBytes;
60007258:	4634      	mov	r4, r6
    Avail = _GetAvailWriteSpace(pRing);
6000725a:	f004 fed3 	bl	6000c004 <_GetAvailWriteSpace>
    Status = Avail < NumBytes ? Avail : NumBytes;
6000725e:	4286      	cmp	r6, r0
60007260:	bf28      	it	cs
60007262:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
60007264:	4628      	mov	r0, r5
60007266:	4622      	mov	r2, r4
60007268:	f004 fed5 	bl	6000c016 <_WriteNoCheck>
    break;
6000726c:	e7f1      	b.n	60007252 <SEGGER_RTT_WriteNoLock+0x32>
    Status = _WriteBlocking(pRing, pData, NumBytes);
6000726e:	4628      	mov	r0, r5
}
60007270:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Status = _WriteBlocking(pRing, pData, NumBytes);
60007274:	f004 beeb 	b.w	6000c04e <_WriteBlocking>
  switch (pRing->Flags) {
60007278:	2400      	movs	r4, #0
  return Status;
6000727a:	e7ea      	b.n	60007252 <SEGGER_RTT_WriteNoLock+0x32>
6000727c:	20000000 	.word	0x20000000

60007280 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
60007280:	2218      	movs	r2, #24
60007282:	4b03      	ldr	r3, [pc, #12]	; (60007290 <SEGGER_RTT_HasDataUp+0x10>)
60007284:	fb02 3300 	mla	r3, r2, r0, r3
60007288:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
6000728a:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
6000728c:	1a80      	subs	r0, r0, r2
6000728e:	4770      	bx	lr
60007290:	20000000 	.word	0x20000000

60007294 <SEGGER_RTT_AllocUpBuffer>:
*
*  Return value
*    >= 0 - O.K. Buffer Index
*     < 0 - Error
*/
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
60007294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int BufferIndex;
  volatile SEGGER_RTT_CB* pRTTCB;

  INIT();
60007298:	4c1a      	ldr	r4, [pc, #104]	; (60007304 <SEGGER_RTT_AllocUpBuffer+0x70>)
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
6000729a:	461e      	mov	r6, r3
6000729c:	4681      	mov	r9, r0
6000729e:	4688      	mov	r8, r1
  INIT();
600072a0:	7823      	ldrb	r3, [r4, #0]
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
600072a2:	4617      	mov	r7, r2
  INIT();
600072a4:	b90b      	cbnz	r3, 600072aa <SEGGER_RTT_AllocUpBuffer+0x16>
600072a6:	f7ff feef 	bl	60007088 <_DoInit>
  SEGGER_RTT_LOCK();
600072aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
600072ae:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
600072b2:	f7ff ff17 	bl	600070e4 <k_mutex_lock.constprop.0.isra.0>
  pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  BufferIndex = 0;
600072b6:	2500      	movs	r5, #0
  do {
    if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
600072b8:	2218      	movs	r2, #24
600072ba:	fb05 2302 	mla	r3, r5, r2, r2
600072be:	1c69      	adds	r1, r5, #1
600072c0:	4423      	add	r3, r4
600072c2:	685b      	ldr	r3, [r3, #4]
600072c4:	b11b      	cbz	r3, 600072ce <SEGGER_RTT_AllocUpBuffer+0x3a>
      break;
    }
    BufferIndex++;
  } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
600072c6:	6923      	ldr	r3, [r4, #16]
    BufferIndex++;
600072c8:	460d      	mov	r5, r1
  } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
600072ca:	428b      	cmp	r3, r1
600072cc:	dcf5      	bgt.n	600072ba <SEGGER_RTT_AllocUpBuffer+0x26>
  if (BufferIndex < pRTTCB->MaxNumUpBuffers) {
600072ce:	6923      	ldr	r3, [r4, #16]
600072d0:	42ab      	cmp	r3, r5
600072d2:	dd13      	ble.n	600072fc <SEGGER_RTT_AllocUpBuffer+0x68>
    pRTTCB->aUp[BufferIndex].sName        = sName;
600072d4:	2318      	movs	r3, #24
600072d6:	fb05 3203 	mla	r2, r5, r3, r3
600072da:	f844 9002 	str.w	r9, [r4, r2]
600072de:	18a1      	adds	r1, r4, r2
    pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
    pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
600072e0:	fb03 4405 	mla	r4, r3, r5, r4
    pRTTCB->aUp[BufferIndex].RdOff        = 0u;
600072e4:	2300      	movs	r3, #0
    pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
600072e6:	f8c1 8004 	str.w	r8, [r1, #4]
    pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
600072ea:	6227      	str	r7, [r4, #32]
    pRTTCB->aUp[BufferIndex].RdOff        = 0u;
600072ec:	62a3      	str	r3, [r4, #40]	; 0x28
    pRTTCB->aUp[BufferIndex].WrOff        = 0u;
600072ee:	6263      	str	r3, [r4, #36]	; 0x24
    pRTTCB->aUp[BufferIndex].Flags        = Flags;
600072f0:	62e6      	str	r6, [r4, #44]	; 0x2c
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
  } else {
    BufferIndex = -1;
  }
  SEGGER_RTT_UNLOCK();
600072f2:	f7ff feff 	bl	600070f4 <k_mutex_unlock.constprop.0.isra.0>
  return BufferIndex;
}
600072f6:	4628      	mov	r0, r5
600072f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    BufferIndex = -1;
600072fc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
60007300:	e7f7      	b.n	600072f2 <SEGGER_RTT_AllocUpBuffer+0x5e>
60007302:	bf00      	nop
60007304:	20000000 	.word	0x20000000

60007308 <SEGGER_RTT_ConfigDownBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
60007308:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int r;
  volatile SEGGER_RTT_CB* pRTTCB;
  volatile SEGGER_RTT_BUFFER_DOWN* pDown;

  INIT();
6000730c:	4e13      	ldr	r6, [pc, #76]	; (6000735c <SEGGER_RTT_ConfigDownBuffer+0x54>)
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
6000730e:	461f      	mov	r7, r3
60007310:	4605      	mov	r5, r0
60007312:	4689      	mov	r9, r1
  INIT();
60007314:	7833      	ldrb	r3, [r6, #0]
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
60007316:	4690      	mov	r8, r2
  INIT();
60007318:	b90b      	cbnz	r3, 6000731e <SEGGER_RTT_ConfigDownBuffer+0x16>
6000731a:	f7ff feb5 	bl	60007088 <_DoInit>
  pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
6000731e:	2d02      	cmp	r5, #2
    SEGGER_RTT_LOCK();
60007320:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
60007324:	d817      	bhi.n	60007356 <SEGGER_RTT_ConfigDownBuffer+0x4e>
    SEGGER_RTT_LOCK();
60007326:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
6000732a:	f7ff fedb 	bl	600070e4 <k_mutex_lock.constprop.0.isra.0>
    pDown = &pRTTCB->aDown[BufferIndex];
    if (BufferIndex) {
6000732e:	b155      	cbz	r5, 60007346 <SEGGER_RTT_ConfigDownBuffer+0x3e>
      pDown->sName        = sName;
60007330:	2418      	movs	r4, #24
      pDown->pBuffer      = (char*)pBuffer;
      pDown->SizeOfBuffer = BufferSize;
      pDown->RdOff        = 0u;
60007332:	2300      	movs	r3, #0
      pDown->sName        = sName;
60007334:	fb04 6405 	mla	r4, r4, r5, r6
60007338:	f8c4 9060 	str.w	r9, [r4, #96]	; 0x60
      pDown->pBuffer      = (char*)pBuffer;
6000733c:	f8c4 8064 	str.w	r8, [r4, #100]	; 0x64
      pDown->SizeOfBuffer = BufferSize;
60007340:	66a7      	str	r7, [r4, #104]	; 0x68
      pDown->RdOff        = 0u;
60007342:	6723      	str	r3, [r4, #112]	; 0x70
      pDown->WrOff        = 0u;
60007344:	66e3      	str	r3, [r4, #108]	; 0x6c
    }
    pDown->Flags          = Flags;
60007346:	2018      	movs	r0, #24
60007348:	9b08      	ldr	r3, [sp, #32]
6000734a:	fb00 6505 	mla	r5, r0, r5, r6
6000734e:	676b      	str	r3, [r5, #116]	; 0x74
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    SEGGER_RTT_UNLOCK();
60007350:	f7ff fed0 	bl	600070f4 <k_mutex_unlock.constprop.0.isra.0>
    r =  0;
60007354:	2000      	movs	r0, #0
  } else {
    r = -1;
  }
  return r;
}
60007356:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
6000735a:	bf00      	nop
6000735c:	20000000 	.word	0x20000000

60007360 <SEGGER_SYSVIEW_Init>:
*    The channel is assigned the label "SysView" for client software 
*    to identify the SystemView channel.
*
*    The channel is configured with the macro SEGGER_SYSVIEW_RTT_CHANNEL.
*/
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
60007360:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
#else
  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
60007364:	f8df 9054 	ldr.w	r9, [pc, #84]	; 600073bc <SEGGER_SYSVIEW_Init+0x5c>
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
60007368:	4607      	mov	r7, r0
6000736a:	460e      	mov	r6, r1
6000736c:	4690      	mov	r8, r2
6000736e:	461d      	mov	r5, r3
  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
60007370:	f04f 0a00 	mov.w	sl, #0
  SEGGER_RTT_Init();
60007374:	f004 fe94 	bl	6000c0a0 <SEGGER_RTT_Init>
  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
60007378:	2300      	movs	r3, #0
6000737a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
6000737e:	4910      	ldr	r1, [pc, #64]	; (600073c0 <SEGGER_SYSVIEW_Init+0x60>)
60007380:	4648      	mov	r0, r9
60007382:	4c10      	ldr	r4, [pc, #64]	; (600073c4 <SEGGER_SYSVIEW_Init+0x64>)
60007384:	f7ff ff86 	bl	60007294 <SEGGER_RTT_AllocUpBuffer>
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
60007388:	2308      	movs	r3, #8
  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
6000738a:	b2c0      	uxtb	r0, r0
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
6000738c:	4a0e      	ldr	r2, [pc, #56]	; (600073c8 <SEGGER_SYSVIEW_Init+0x68>)
6000738e:	4649      	mov	r1, r9
60007390:	f8cd a000 	str.w	sl, [sp]
  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
60007394:	7060      	strb	r0, [r4, #1]
  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
60007396:	7620      	strb	r0, [r4, #24]
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
60007398:	f7ff ffb6 	bl	60007308 <SEGGER_RTT_ConfigDownBuffer>
#endif
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
6000739c:	f8c4 a010 	str.w	sl, [r4, #16]
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
600073a0:	f004 fa19 	bl	6000b7d6 <sysview_get_timestamp>
  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
600073a4:	f8c4 8020 	str.w	r8, [r4, #32]
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
600073a8:	60e0      	str	r0, [r4, #12]
  _SYSVIEW_Globals.SysFreq          = SysFreq;
  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
600073aa:	6265      	str	r5, [r4, #36]	; 0x24
  _SYSVIEW_Globals.EnableState      = 0;
600073ac:	f884 a000 	strb.w	sl, [r4]
  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
600073b0:	e9c4 7601 	strd	r7, r6, [r4, #4]
#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
}
600073b4:	b002      	add	sp, #8
600073b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
600073ba:	bf00      	nop
600073bc:	6000e67f 	.word	0x6000e67f
600073c0:	200004c0 	.word	0x200004c0
600073c4:	80000ec8 	.word	0x80000ec8
600073c8:	200004b8 	.word	0x200004b8

600073cc <SEGGER_SYSVIEW_SetRAMBase>:
*
*  Parameters
*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
*/
void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
600073cc:	4b01      	ldr	r3, [pc, #4]	; (600073d4 <SEGGER_SYSVIEW_SetRAMBase+0x8>)
600073ce:	6118      	str	r0, [r3, #16]
}
600073d0:	4770      	bx	lr
600073d2:	bf00      	nop
600073d4:	80000ec8 	.word	0x80000ec8

600073d8 <SEGGER_SYSVIEW_SendTaskList>:
*
*  Function description
*    Send all tasks descriptors to the host.
*/
void SEGGER_SYSVIEW_SendTaskList(void) {
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
600073d8:	4b03      	ldr	r3, [pc, #12]	; (600073e8 <SEGGER_SYSVIEW_SendTaskList+0x10>)
600073da:	6a1b      	ldr	r3, [r3, #32]
600073dc:	b113      	cbz	r3, 600073e4 <SEGGER_SYSVIEW_SendTaskList+0xc>
600073de:	685b      	ldr	r3, [r3, #4]
600073e0:	b103      	cbz	r3, 600073e4 <SEGGER_SYSVIEW_SendTaskList+0xc>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
600073e2:	4718      	bx	r3
  }
}
600073e4:	4770      	bx	lr
600073e6:	bf00      	nop
600073e8:	80000ec8 	.word	0x80000ec8

600073ec <SEGGER_SYSVIEW_ShrinkId>:
*       (i.e. 0x20000000 when all Ids are an address in this RAM)
*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
*/
U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
  return SHRINK_ID(Id);
600073ec:	4b01      	ldr	r3, [pc, #4]	; (600073f4 <SEGGER_SYSVIEW_ShrinkId+0x8>)
600073ee:	691b      	ldr	r3, [r3, #16]
}
600073f0:	1ac0      	subs	r0, r0, r3
600073f2:	4770      	bx	lr
600073f4:	80000ec8 	.word	0x80000ec8

600073f8 <SEGGER_SYSVIEW_SendModuleDescription>:
*
*/
void SEGGER_SYSVIEW_SendModuleDescription(void) {
  SEGGER_SYSVIEW_MODULE* pModule;

  if (_pFirstModule != 0) {
600073f8:	4b04      	ldr	r3, [pc, #16]	; (6000740c <SEGGER_SYSVIEW_SendModuleDescription+0x14>)
void SEGGER_SYSVIEW_SendModuleDescription(void) {
600073fa:	b510      	push	{r4, lr}
  if (_pFirstModule != 0) {
600073fc:	681c      	ldr	r4, [r3, #0]
600073fe:	b124      	cbz	r4, 6000740a <SEGGER_SYSVIEW_SendModuleDescription+0x12>
    pModule = _pFirstModule;
    do {
      if (pModule->pfSendModuleDesc) {
60007400:	68e3      	ldr	r3, [r4, #12]
60007402:	b103      	cbz	r3, 60007406 <SEGGER_SYSVIEW_SendModuleDescription+0xe>
        pModule->pfSendModuleDesc();
60007404:	4798      	blx	r3
      }
      pModule = pModule->pNext;
60007406:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
60007408:	e7f9      	b.n	600073fe <SEGGER_SYSVIEW_SendModuleDescription+0x6>
  }
}
6000740a:	bd10      	pop	{r4, pc}
6000740c:	80000ef0 	.word	0x80000ef0

60007410 <SEGGER_SYSVIEW_SendNumModules>:
*       SEGGER_SYSVIEW_SendNumModules()
*
*  Function description
*    Send the number of registered modules to the host.
*/
void SEGGER_SYSVIEW_SendNumModules(void) {
60007410:	b510      	push	{r4, lr}
	__asm__ volatile(
60007412:	f04f 0310 	mov.w	r3, #16
60007416:	f3ef 8411 	mrs	r4, BASEPRI
6000741a:	f383 8811 	msr	BASEPRI, r3
6000741e:	f3bf 8f6f 	isb	sy
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
  pPayload = pPayloadStart;
  ENCODE_U32(pPayload, _NumModules);
60007422:	4b0a      	ldr	r3, [pc, #40]	; (6000744c <SEGGER_SYSVIEW_SendNumModules+0x3c>)
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
60007424:	221b      	movs	r2, #27
60007426:	480a      	ldr	r0, [pc, #40]	; (60007450 <SEGGER_SYSVIEW_SendNumModules+0x40>)
  ENCODE_U32(pPayload, _NumModules);
60007428:	781b      	ldrb	r3, [r3, #0]
6000742a:	2b7f      	cmp	r3, #127	; 0x7f
6000742c:	bf89      	itett	hi
6000742e:	4909      	ldrhi	r1, [pc, #36]	; (60007454 <SEGGER_SYSVIEW_SendNumModules+0x44>)
60007430:	4907      	ldrls	r1, [pc, #28]	; (60007450 <SEGGER_SYSVIEW_SendNumModules+0x40>)
60007432:	710b      	strbhi	r3, [r1, #4]
60007434:	2301      	movhi	r3, #1
60007436:	bf88      	it	hi
60007438:	3105      	addhi	r1, #5
6000743a:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
6000743e:	f000 f8bb 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007442:	f384 8811 	msr	BASEPRI, r4
60007446:	f3bf 8f6f 	isb	sy
  RECORD_END();
}
6000744a:	bd10      	pop	{r4, pc}
6000744c:	80000fb8 	.word	0x80000fb8
60007450:	80000fbd 	.word	0x80000fbd
60007454:	80000fb9 	.word	0x80000fb9

60007458 <SEGGER_SYSVIEW_Start>:
void SEGGER_SYSVIEW_Start(void) {
60007458:	b538      	push	{r3, r4, r5, lr}
    _SYSVIEW_Globals.EnableState = 1;
6000745a:	4c2f      	ldr	r4, [pc, #188]	; (60007518 <SEGGER_SYSVIEW_Start+0xc0>)
6000745c:	2301      	movs	r3, #1
6000745e:	7023      	strb	r3, [r4, #0]
	__asm__ volatile(
60007460:	f04f 0310 	mov.w	r3, #16
60007464:	f3ef 8511 	mrs	r5, BASEPRI
60007468:	f383 8811 	msr	BASEPRI, r3
6000746c:	f3bf 8f6f 	isb	sy
    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
60007470:	220a      	movs	r2, #10
60007472:	492a      	ldr	r1, [pc, #168]	; (6000751c <SEGGER_SYSVIEW_Start+0xc4>)
60007474:	7860      	ldrb	r0, [r4, #1]
60007476:	f7ff fe87 	bl	60007188 <SEGGER_RTT_WriteSkipNoLock>
	__asm__ volatile(
6000747a:	f385 8811 	msr	BASEPRI, r5
6000747e:	f3bf 8f6f 	isb	sy
    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
60007482:	200a      	movs	r0, #10
60007484:	f000 f944 	bl	60007710 <SEGGER_SYSVIEW_RecordVoid>
	__asm__ volatile(
60007488:	f04f 0310 	mov.w	r3, #16
6000748c:	f3ef 8511 	mrs	r5, BASEPRI
60007490:	f383 8811 	msr	BASEPRI, r3
60007494:	f3bf 8f6f 	isb	sy
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
60007498:	4821      	ldr	r0, [pc, #132]	; (60007520 <SEGGER_SYSVIEW_Start+0xc8>)
6000749a:	6861      	ldr	r1, [r4, #4]
6000749c:	297f      	cmp	r1, #127	; 0x7f
6000749e:	b2ca      	uxtb	r2, r1
600074a0:	f100 0301 	add.w	r3, r0, #1
600074a4:	d823      	bhi.n	600074ee <SEGGER_SYSVIEW_Start+0x96>
600074a6:	7002      	strb	r2, [r0, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
600074a8:	68a0      	ldr	r0, [r4, #8]
600074aa:	287f      	cmp	r0, #127	; 0x7f
600074ac:	b2c2      	uxtb	r2, r0
600074ae:	f103 0101 	add.w	r1, r3, #1
600074b2:	d823      	bhi.n	600074fc <SEGGER_SYSVIEW_Start+0xa4>
600074b4:	701a      	strb	r2, [r3, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
600074b6:	6922      	ldr	r2, [r4, #16]
600074b8:	2a7f      	cmp	r2, #127	; 0x7f
600074ba:	b2d3      	uxtb	r3, r2
600074bc:	d825      	bhi.n	6000750a <SEGGER_SYSVIEW_Start+0xb2>
600074be:	700b      	strb	r3, [r1, #0]
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
600074c0:	2300      	movs	r3, #0
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
600074c2:	2218      	movs	r2, #24
600074c4:	3102      	adds	r1, #2
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
600074c6:	f801 3c01 	strb.w	r3, [r1, #-1]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
600074ca:	4815      	ldr	r0, [pc, #84]	; (60007520 <SEGGER_SYSVIEW_Start+0xc8>)
600074cc:	f000 f874 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
600074d0:	f385 8811 	msr	BASEPRI, r5
600074d4:	f3bf 8f6f 	isb	sy
    if (_SYSVIEW_Globals.pfSendSysDesc) {
600074d8:	6a63      	ldr	r3, [r4, #36]	; 0x24
600074da:	b103      	cbz	r3, 600074de <SEGGER_SYSVIEW_Start+0x86>
      _SYSVIEW_Globals.pfSendSysDesc();
600074dc:	4798      	blx	r3
    SEGGER_SYSVIEW_RecordSystime();
600074de:	f000 f981 	bl	600077e4 <SEGGER_SYSVIEW_RecordSystime>
    SEGGER_SYSVIEW_SendTaskList();
600074e2:	f7ff ff79 	bl	600073d8 <SEGGER_SYSVIEW_SendTaskList>
}
600074e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SEGGER_SYSVIEW_SendNumModules();
600074ea:	f7ff bf91 	b.w	60007410 <SEGGER_SYSVIEW_SendNumModules>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
600074ee:	f062 027f 	orn	r2, r2, #127	; 0x7f
600074f2:	09c9      	lsrs	r1, r1, #7
600074f4:	4618      	mov	r0, r3
600074f6:	f803 2c01 	strb.w	r2, [r3, #-1]
600074fa:	e7cf      	b.n	6000749c <SEGGER_SYSVIEW_Start+0x44>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
600074fc:	f062 027f 	orn	r2, r2, #127	; 0x7f
60007500:	09c0      	lsrs	r0, r0, #7
60007502:	460b      	mov	r3, r1
60007504:	f801 2c01 	strb.w	r2, [r1, #-1]
60007508:	e7cf      	b.n	600074aa <SEGGER_SYSVIEW_Start+0x52>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
6000750a:	f063 037f 	orn	r3, r3, #127	; 0x7f
6000750e:	09d2      	lsrs	r2, r2, #7
60007510:	f801 3b01 	strb.w	r3, [r1], #1
60007514:	e7d0      	b.n	600074b8 <SEGGER_SYSVIEW_Start+0x60>
60007516:	bf00      	nop
60007518:	80000ec8 	.word	0x80000ec8
6000751c:	6000eb06 	.word	0x6000eb06
60007520:	80000fbd 	.word	0x80000fbd

60007524 <_HandleIncomingPacket>:
static void _HandleIncomingPacket(void) {
60007524:	b513      	push	{r0, r1, r4, lr}
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
60007526:	4c23      	ldr	r4, [pc, #140]	; (600075b4 <_HandleIncomingPacket+0x90>)
60007528:	2201      	movs	r2, #1
6000752a:	f10d 0107 	add.w	r1, sp, #7
6000752e:	7e20      	ldrb	r0, [r4, #24]
60007530:	f7ff fde6 	bl	60007100 <SEGGER_RTT_ReadNoLock>
  if (Status > 0) {
60007534:	2800      	cmp	r0, #0
60007536:	dd1b      	ble.n	60007570 <_HandleIncomingPacket+0x4c>
    switch (Cmd) {
60007538:	f89d 3007 	ldrb.w	r3, [sp, #7]
6000753c:	2b07      	cmp	r3, #7
6000753e:	d808      	bhi.n	60007552 <_HandleIncomingPacket+0x2e>
60007540:	b15b      	cbz	r3, 6000755a <_HandleIncomingPacket+0x36>
60007542:	3b02      	subs	r3, #2
60007544:	2b05      	cmp	r3, #5
60007546:	d811      	bhi.n	6000756c <_HandleIncomingPacket+0x48>
60007548:	e8df f003 	tbb	[pc, r3]
6000754c:	1d1a1714 	.word	0x1d1a1714
60007550:	2320      	.short	0x2320
60007552:	2b7f      	cmp	r3, #127	; 0x7f
60007554:	d00c      	beq.n	60007570 <_HandleIncomingPacket+0x4c>
60007556:	2b80      	cmp	r3, #128	; 0x80
60007558:	d01e      	beq.n	60007598 <_HandleIncomingPacket+0x74>
      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
6000755a:	061b      	lsls	r3, r3, #24
6000755c:	d508      	bpl.n	60007570 <_HandleIncomingPacket+0x4c>
        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
6000755e:	2201      	movs	r2, #1
60007560:	f10d 0107 	add.w	r1, sp, #7
60007564:	7e20      	ldrb	r0, [r4, #24]
60007566:	f7ff fdcb 	bl	60007100 <SEGGER_RTT_ReadNoLock>
}
6000756a:	e001      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      SEGGER_SYSVIEW_Start();
6000756c:	f7ff ff74 	bl	60007458 <SEGGER_SYSVIEW_Start>
}
60007570:	b002      	add	sp, #8
60007572:	bd10      	pop	{r4, pc}
      SEGGER_SYSVIEW_Stop();
60007574:	f000 f94e 	bl	60007814 <SEGGER_SYSVIEW_Stop>
      break;
60007578:	e7fa      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      SEGGER_SYSVIEW_RecordSystime();
6000757a:	f000 f933 	bl	600077e4 <SEGGER_SYSVIEW_RecordSystime>
      break;
6000757e:	e7f7      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      SEGGER_SYSVIEW_SendTaskList();
60007580:	f7ff ff2a 	bl	600073d8 <SEGGER_SYSVIEW_SendTaskList>
      break;
60007584:	e7f4      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      SEGGER_SYSVIEW_GetSysDesc();
60007586:	f000 f961 	bl	6000784c <SEGGER_SYSVIEW_GetSysDesc>
      break;
6000758a:	e7f1      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      SEGGER_SYSVIEW_SendNumModules();
6000758c:	f7ff ff40 	bl	60007410 <SEGGER_SYSVIEW_SendNumModules>
      break;
60007590:	e7ee      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      SEGGER_SYSVIEW_SendModuleDescription();
60007592:	f7ff ff31 	bl	600073f8 <SEGGER_SYSVIEW_SendModuleDescription>
      break;
60007596:	e7eb      	b.n	60007570 <_HandleIncomingPacket+0x4c>
      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
60007598:	2201      	movs	r2, #1
6000759a:	f10d 0107 	add.w	r1, sp, #7
6000759e:	7e20      	ldrb	r0, [r4, #24]
600075a0:	f7ff fdae 	bl	60007100 <SEGGER_RTT_ReadNoLock>
      if (Status > 0) {
600075a4:	2800      	cmp	r0, #0
600075a6:	dde3      	ble.n	60007570 <_HandleIncomingPacket+0x4c>
        SEGGER_SYSVIEW_SendModule(Cmd);
600075a8:	f89d 0007 	ldrb.w	r0, [sp, #7]
600075ac:	f000 fb86 	bl	60007cbc <SEGGER_SYSVIEW_SendModule>
600075b0:	e7de      	b.n	60007570 <_HandleIncomingPacket+0x4c>
600075b2:	bf00      	nop
600075b4:	80000ec8 	.word	0x80000ec8

600075b8 <_SendPacket>:
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
600075b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
600075bc:	4c52      	ldr	r4, [pc, #328]	; (60007708 <_SendPacket+0x150>)
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
600075be:	b085      	sub	sp, #20
600075c0:	4606      	mov	r6, r0
600075c2:	460f      	mov	r7, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
600075c4:	7823      	ldrb	r3, [r4, #0]
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
600075c6:	4615      	mov	r5, r2
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
600075c8:	2b01      	cmp	r3, #1
600075ca:	d124      	bne.n	60007616 <_SendPacket+0x5e>
  if (EventId < 32) {
600075cc:	2d1f      	cmp	r5, #31
600075ce:	d970      	bls.n	600076b2 <_SendPacket+0xfa>
    NumBytes = pEndPacket - pStartPacket;
600075d0:	1bbb      	subs	r3, r7, r6
    if (NumBytes > 127) {
600075d2:	2b7f      	cmp	r3, #127	; 0x7f
      *--pStartPacket = NumBytes | 0x80;
600075d4:	b2da      	uxtb	r2, r3
      *--pStartPacket = (NumBytes >> 7);
600075d6:	bf87      	ittee	hi
600075d8:	09db      	lsrhi	r3, r3, #7
      *--pStartPacket = NumBytes | 0x80;
600075da:	f062 027f 	ornhi	r2, r2, #127	; 0x7f
      *--pStartPacket = NumBytes;
600075de:	f106 33ff 	addls.w	r3, r6, #4294967295	; 0xffffffff
600075e2:	f806 2c01 	strbls.w	r2, [r6, #-1]
      *--pStartPacket = (NumBytes >> 7);
600075e6:	bf82      	ittt	hi
600075e8:	f806 3c01 	strbhi.w	r3, [r6, #-1]
      *--pStartPacket = NumBytes | 0x80;
600075ec:	1eb3      	subhi	r3, r6, #2
600075ee:	f806 2c02 	strbhi.w	r2, [r6, #-2]
    if (EventId > 127) {
600075f2:	2d7f      	cmp	r5, #127	; 0x7f
    *--pStartPacket = EventId;
600075f4:	b2ea      	uxtb	r2, r5
      *--pStartPacket = (EventId >> 7);
600075f6:	bf83      	ittte	hi
600075f8:	09ed      	lsrhi	r5, r5, #7
      *--pStartPacket = EventId | 0x80;
600075fa:	f1a3 0802 	subhi.w	r8, r3, #2
600075fe:	f062 027f 	ornhi	r2, r2, #127	; 0x7f
      *--pStartPacket = EventId;
60007602:	f103 38ff 	addls.w	r8, r3, #4294967295	; 0xffffffff
      *--pStartPacket = (EventId >> 7);
60007606:	bf86      	itte	hi
60007608:	f803 5c01 	strbhi.w	r5, [r3, #-1]
      *--pStartPacket = EventId | 0x80;
6000760c:	f803 2c02 	strbhi.w	r2, [r3, #-2]
      *--pStartPacket = EventId;
60007610:	f803 2c01 	strbls.w	r2, [r3, #-1]
60007614:	e058      	b.n	600076c8 <_SendPacket+0x110>
  if (_SYSVIEW_Globals.EnableState == 0) {
60007616:	b33b      	cbz	r3, 60007668 <_SendPacket+0xb0>
  if (_SYSVIEW_Globals.EnableState == 2) {
60007618:	2b02      	cmp	r3, #2
6000761a:	d1d7      	bne.n	600075cc <_SendPacket+0x14>
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
6000761c:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
6000761e:	6962      	ldr	r2, [r4, #20]
60007620:	f10d 0105 	add.w	r1, sp, #5
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
60007624:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
60007628:	2a7f      	cmp	r2, #127	; 0x7f
6000762a:	b2d3      	uxtb	r3, r2
6000762c:	f101 0801 	add.w	r8, r1, #1
60007630:	d82d      	bhi.n	6000768e <_SendPacket+0xd6>
60007632:	700b      	strb	r3, [r1, #0]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
60007634:	f004 f8cf 	bl	6000b7d6 <sysview_get_timestamp>
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
60007638:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
6000763a:	4681      	mov	r9, r0
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
6000763c:	1ac3      	subs	r3, r0, r3
  ENCODE_U32(pPayload, Delta);
6000763e:	2b7f      	cmp	r3, #127	; 0x7f
60007640:	b2d9      	uxtb	r1, r3
60007642:	f108 0201 	add.w	r2, r8, #1
60007646:	d829      	bhi.n	6000769c <_SendPacket+0xe4>
60007648:	f888 1000 	strb.w	r1, [r8]
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
6000764c:	a901      	add	r1, sp, #4
6000764e:	7860      	ldrb	r0, [r4, #1]
60007650:	1a52      	subs	r2, r2, r1
60007652:	f7ff fd99 	bl	60007188 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
60007656:	b340      	cbz	r0, 600076aa <_SendPacket+0xf2>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
60007658:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
6000765a:	f8c4 900c 	str.w	r9, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
6000765e:	3b01      	subs	r3, #1
60007660:	7023      	strb	r3, [r4, #0]
    if (_SYSVIEW_Globals.EnableState != 1) {
60007662:	7823      	ldrb	r3, [r4, #0]
60007664:	2b01      	cmp	r3, #1
60007666:	d0b1      	beq.n	600075cc <_SendPacket+0x14>
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
60007668:	7e22      	ldrb	r2, [r4, #24]
6000766a:	2118      	movs	r1, #24
6000766c:	4b27      	ldr	r3, [pc, #156]	; (6000770c <_SendPacket+0x154>)
6000766e:	fb01 3302 	mla	r3, r1, r2, r3
60007672:	6eda      	ldr	r2, [r3, #108]	; 0x6c
60007674:	6f1b      	ldr	r3, [r3, #112]	; 0x70
60007676:	429a      	cmp	r2, r3
60007678:	d006      	beq.n	60007688 <_SendPacket+0xd0>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
6000767a:	78a5      	ldrb	r5, [r4, #2]
6000767c:	b925      	cbnz	r5, 60007688 <_SendPacket+0xd0>
      _SYSVIEW_Globals.RecursionCnt = 1;
6000767e:	2301      	movs	r3, #1
60007680:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
60007682:	f7ff ff4f 	bl	60007524 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
60007686:	70a5      	strb	r5, [r4, #2]
}
60007688:	b005      	add	sp, #20
6000768a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
6000768e:	f063 037f 	orn	r3, r3, #127	; 0x7f
60007692:	09d2      	lsrs	r2, r2, #7
60007694:	4641      	mov	r1, r8
60007696:	f808 3c01 	strb.w	r3, [r8, #-1]
6000769a:	e7c5      	b.n	60007628 <_SendPacket+0x70>
  ENCODE_U32(pPayload, Delta);
6000769c:	f061 017f 	orn	r1, r1, #127	; 0x7f
600076a0:	09db      	lsrs	r3, r3, #7
600076a2:	4690      	mov	r8, r2
600076a4:	f802 1c01 	strb.w	r1, [r2, #-1]
600076a8:	e7c9      	b.n	6000763e <_SendPacket+0x86>
    _SYSVIEW_Globals.DropCount++;
600076aa:	6963      	ldr	r3, [r4, #20]
600076ac:	3301      	adds	r3, #1
600076ae:	6163      	str	r3, [r4, #20]
600076b0:	e7d7      	b.n	60007662 <_SendPacket+0xaa>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
600076b2:	69e3      	ldr	r3, [r4, #28]
600076b4:	40eb      	lsrs	r3, r5
600076b6:	07db      	lsls	r3, r3, #31
600076b8:	d4d6      	bmi.n	60007668 <_SendPacket+0xb0>
  if (EventId < 24) {
600076ba:	2d17      	cmp	r5, #23
    *--pStartPacket = EventId;
600076bc:	b2eb      	uxtb	r3, r5
  if (EventId < 24) {
600076be:	d887      	bhi.n	600075d0 <_SendPacket+0x18>
    *--pStartPacket = EventId;
600076c0:	f106 38ff 	add.w	r8, r6, #4294967295	; 0xffffffff
600076c4:	f806 3c01 	strb.w	r3, [r6, #-1]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
600076c8:	f004 f885 	bl	6000b7d6 <sysview_get_timestamp>
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
600076cc:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
600076ce:	4605      	mov	r5, r0
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
600076d0:	1ac3      	subs	r3, r0, r3
  ENCODE_U32(pEndPacket, Delta);
600076d2:	2b7f      	cmp	r3, #127	; 0x7f
600076d4:	b2d9      	uxtb	r1, r3
600076d6:	f107 0201 	add.w	r2, r7, #1
600076da:	d809      	bhi.n	600076f0 <_SendPacket+0x138>
600076dc:	7039      	strb	r1, [r7, #0]
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
600076de:	eba2 0208 	sub.w	r2, r2, r8
600076e2:	4641      	mov	r1, r8
600076e4:	7860      	ldrb	r0, [r4, #1]
600076e6:	f7ff fd4f 	bl	60007188 <SEGGER_RTT_WriteSkipNoLock>
  if (Status) {
600076ea:	b140      	cbz	r0, 600076fe <_SendPacket+0x146>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
600076ec:	60e5      	str	r5, [r4, #12]
600076ee:	e7bb      	b.n	60007668 <_SendPacket+0xb0>
  ENCODE_U32(pEndPacket, Delta);
600076f0:	f061 017f 	orn	r1, r1, #127	; 0x7f
600076f4:	09db      	lsrs	r3, r3, #7
600076f6:	4617      	mov	r7, r2
600076f8:	f802 1c01 	strb.w	r1, [r2, #-1]
600076fc:	e7e9      	b.n	600076d2 <_SendPacket+0x11a>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
600076fe:	7823      	ldrb	r3, [r4, #0]
60007700:	3301      	adds	r3, #1
60007702:	7023      	strb	r3, [r4, #0]
60007704:	e7b0      	b.n	60007668 <_SendPacket+0xb0>
60007706:	bf00      	nop
60007708:	80000ec8 	.word	0x80000ec8
6000770c:	20000000 	.word	0x20000000

60007710 <SEGGER_SYSVIEW_RecordVoid>:
void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
60007710:	4602      	mov	r2, r0
60007712:	b510      	push	{r4, lr}
	__asm__ volatile(
60007714:	f04f 0310 	mov.w	r3, #16
60007718:	f3ef 8411 	mrs	r4, BASEPRI
6000771c:	f383 8811 	msr	BASEPRI, r3
60007720:	f3bf 8f6f 	isb	sy
  _SendPacket(pPayloadStart, pPayloadStart, EventID);
60007724:	4904      	ldr	r1, [pc, #16]	; (60007738 <SEGGER_SYSVIEW_RecordVoid+0x28>)
60007726:	4608      	mov	r0, r1
60007728:	f7ff ff46 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
6000772c:	f384 8811 	msr	BASEPRI, r4
60007730:	f3bf 8f6f 	isb	sy
}
60007734:	bd10      	pop	{r4, pc}
60007736:	bf00      	nop
60007738:	80000fbd 	.word	0x80000fbd

6000773c <SEGGER_SYSVIEW_RecordU32>:
void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
6000773c:	b538      	push	{r3, r4, r5, lr}
6000773e:	4602      	mov	r2, r0
60007740:	460b      	mov	r3, r1
	__asm__ volatile(
60007742:	f04f 0110 	mov.w	r1, #16
60007746:	f3ef 8511 	mrs	r5, BASEPRI
6000774a:	f381 8811 	msr	BASEPRI, r1
6000774e:	f3bf 8f6f 	isb	sy
  ENCODE_U32(pPayload, Value);
60007752:	480b      	ldr	r0, [pc, #44]	; (60007780 <SEGGER_SYSVIEW_RecordU32+0x44>)
60007754:	2b7f      	cmp	r3, #127	; 0x7f
60007756:	b2dc      	uxtb	r4, r3
60007758:	f100 0101 	add.w	r1, r0, #1
6000775c:	d808      	bhi.n	60007770 <SEGGER_SYSVIEW_RecordU32+0x34>
6000775e:	7004      	strb	r4, [r0, #0]
  _SendPacket(pPayloadStart, pPayload, EventID);
60007760:	4807      	ldr	r0, [pc, #28]	; (60007780 <SEGGER_SYSVIEW_RecordU32+0x44>)
60007762:	f7ff ff29 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007766:	f385 8811 	msr	BASEPRI, r5
6000776a:	f3bf 8f6f 	isb	sy
}
6000776e:	bd38      	pop	{r3, r4, r5, pc}
  ENCODE_U32(pPayload, Value);
60007770:	f064 047f 	orn	r4, r4, #127	; 0x7f
60007774:	09db      	lsrs	r3, r3, #7
60007776:	4608      	mov	r0, r1
60007778:	f801 4c01 	strb.w	r4, [r1, #-1]
6000777c:	e7ea      	b.n	60007754 <SEGGER_SYSVIEW_RecordU32+0x18>
6000777e:	bf00      	nop
60007780:	80000fbd 	.word	0x80000fbd

60007784 <SEGGER_SYSVIEW_RecordU32x2>:
void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
60007784:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
60007786:	f04f 0310 	mov.w	r3, #16
6000778a:	f3ef 8511 	mrs	r5, BASEPRI
6000778e:	f383 8811 	msr	BASEPRI, r3
60007792:	f3bf 8f6f 	isb	sy
  ENCODE_U32(pPayload, Para0);
60007796:	4e12      	ldr	r6, [pc, #72]	; (600077e0 <SEGGER_SYSVIEW_RecordU32x2+0x5c>)
60007798:	297f      	cmp	r1, #127	; 0x7f
6000779a:	b2cc      	uxtb	r4, r1
6000779c:	f106 0301 	add.w	r3, r6, #1
600077a0:	d80f      	bhi.n	600077c2 <SEGGER_SYSVIEW_RecordU32x2+0x3e>
600077a2:	7034      	strb	r4, [r6, #0]
  ENCODE_U32(pPayload, Para1);
600077a4:	2a7f      	cmp	r2, #127	; 0x7f
600077a6:	b2d4      	uxtb	r4, r2
600077a8:	f103 0101 	add.w	r1, r3, #1
600077ac:	d810      	bhi.n	600077d0 <SEGGER_SYSVIEW_RecordU32x2+0x4c>
  _SendPacket(pPayloadStart, pPayload, EventID);
600077ae:	4602      	mov	r2, r0
  ENCODE_U32(pPayload, Para1);
600077b0:	701c      	strb	r4, [r3, #0]
  _SendPacket(pPayloadStart, pPayload, EventID);
600077b2:	480b      	ldr	r0, [pc, #44]	; (600077e0 <SEGGER_SYSVIEW_RecordU32x2+0x5c>)
600077b4:	f7ff ff00 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
600077b8:	f385 8811 	msr	BASEPRI, r5
600077bc:	f3bf 8f6f 	isb	sy
}
600077c0:	bd70      	pop	{r4, r5, r6, pc}
  ENCODE_U32(pPayload, Para0);
600077c2:	f064 047f 	orn	r4, r4, #127	; 0x7f
600077c6:	09c9      	lsrs	r1, r1, #7
600077c8:	461e      	mov	r6, r3
600077ca:	f803 4c01 	strb.w	r4, [r3, #-1]
600077ce:	e7e3      	b.n	60007798 <SEGGER_SYSVIEW_RecordU32x2+0x14>
  ENCODE_U32(pPayload, Para1);
600077d0:	f064 047f 	orn	r4, r4, #127	; 0x7f
600077d4:	09d2      	lsrs	r2, r2, #7
600077d6:	460b      	mov	r3, r1
600077d8:	f801 4c01 	strb.w	r4, [r1, #-1]
600077dc:	e7e2      	b.n	600077a4 <SEGGER_SYSVIEW_RecordU32x2+0x20>
600077de:	bf00      	nop
600077e0:	80000fbd 	.word	0x80000fbd

600077e4 <SEGGER_SYSVIEW_RecordSystime>:
void SEGGER_SYSVIEW_RecordSystime(void) {
600077e4:	b508      	push	{r3, lr}
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
600077e6:	4b0a      	ldr	r3, [pc, #40]	; (60007810 <SEGGER_SYSVIEW_RecordSystime+0x2c>)
600077e8:	6a1b      	ldr	r3, [r3, #32]
600077ea:	b14b      	cbz	r3, 60007800 <SEGGER_SYSVIEW_RecordSystime+0x1c>
600077ec:	681b      	ldr	r3, [r3, #0]
600077ee:	b13b      	cbz	r3, 60007800 <SEGGER_SYSVIEW_RecordSystime+0x1c>
    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
600077f0:	4798      	blx	r3
600077f2:	460a      	mov	r2, r1
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
600077f4:	4601      	mov	r1, r0
600077f6:	200d      	movs	r0, #13
}
600077f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
600077fc:	f7ff bfc2 	b.w	60007784 <SEGGER_SYSVIEW_RecordU32x2>
    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
60007800:	f003 ffe9 	bl	6000b7d6 <sysview_get_timestamp>
60007804:	4601      	mov	r1, r0
60007806:	200c      	movs	r0, #12
}
60007808:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
6000780c:	f7ff bf96 	b.w	6000773c <SEGGER_SYSVIEW_RecordU32>
60007810:	80000ec8 	.word	0x80000ec8

60007814 <SEGGER_SYSVIEW_Stop>:
void SEGGER_SYSVIEW_Stop(void) {
60007814:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
60007816:	f04f 0310 	mov.w	r3, #16
6000781a:	f3ef 8511 	mrs	r5, BASEPRI
6000781e:	f383 8811 	msr	BASEPRI, r3
60007822:	f3bf 8f6f 	isb	sy
  if (_SYSVIEW_Globals.EnableState) {
60007826:	4c07      	ldr	r4, [pc, #28]	; (60007844 <SEGGER_SYSVIEW_Stop+0x30>)
60007828:	7823      	ldrb	r3, [r4, #0]
6000782a:	b133      	cbz	r3, 6000783a <SEGGER_SYSVIEW_Stop+0x26>
    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
6000782c:	4906      	ldr	r1, [pc, #24]	; (60007848 <SEGGER_SYSVIEW_Stop+0x34>)
6000782e:	220b      	movs	r2, #11
60007830:	4608      	mov	r0, r1
60007832:	f7ff fec1 	bl	600075b8 <_SendPacket>
    _SYSVIEW_Globals.EnableState = 0;
60007836:	2300      	movs	r3, #0
60007838:	7023      	strb	r3, [r4, #0]
	__asm__ volatile(
6000783a:	f385 8811 	msr	BASEPRI, r5
6000783e:	f3bf 8f6f 	isb	sy
}
60007842:	bd38      	pop	{r3, r4, r5, pc}
60007844:	80000ec8 	.word	0x80000ec8
60007848:	80000fbd 	.word	0x80000fbd

6000784c <SEGGER_SYSVIEW_GetSysDesc>:
void SEGGER_SYSVIEW_GetSysDesc(void) {
6000784c:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
6000784e:	f04f 0310 	mov.w	r3, #16
60007852:	f3ef 8511 	mrs	r5, BASEPRI
60007856:	f383 8811 	msr	BASEPRI, r3
6000785a:	f3bf 8f6f 	isb	sy
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
6000785e:	4c1d      	ldr	r4, [pc, #116]	; (600078d4 <SEGGER_SYSVIEW_GetSysDesc+0x88>)
60007860:	481d      	ldr	r0, [pc, #116]	; (600078d8 <SEGGER_SYSVIEW_GetSysDesc+0x8c>)
60007862:	6861      	ldr	r1, [r4, #4]
60007864:	297f      	cmp	r1, #127	; 0x7f
60007866:	b2ca      	uxtb	r2, r1
60007868:	f100 0301 	add.w	r3, r0, #1
6000786c:	d81d      	bhi.n	600078aa <SEGGER_SYSVIEW_GetSysDesc+0x5e>
6000786e:	7002      	strb	r2, [r0, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
60007870:	68a0      	ldr	r0, [r4, #8]
60007872:	287f      	cmp	r0, #127	; 0x7f
60007874:	b2c2      	uxtb	r2, r0
60007876:	f103 0101 	add.w	r1, r3, #1
6000787a:	d81d      	bhi.n	600078b8 <SEGGER_SYSVIEW_GetSysDesc+0x6c>
6000787c:	701a      	strb	r2, [r3, #0]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
6000787e:	6922      	ldr	r2, [r4, #16]
60007880:	2a7f      	cmp	r2, #127	; 0x7f
60007882:	b2d3      	uxtb	r3, r2
60007884:	d81f      	bhi.n	600078c6 <SEGGER_SYSVIEW_GetSysDesc+0x7a>
60007886:	700b      	strb	r3, [r1, #0]
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
60007888:	2300      	movs	r3, #0
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
6000788a:	2218      	movs	r2, #24
6000788c:	3102      	adds	r1, #2
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
6000788e:	f801 3c01 	strb.w	r3, [r1, #-1]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
60007892:	4811      	ldr	r0, [pc, #68]	; (600078d8 <SEGGER_SYSVIEW_GetSysDesc+0x8c>)
60007894:	f7ff fe90 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007898:	f385 8811 	msr	BASEPRI, r5
6000789c:	f3bf 8f6f 	isb	sy
  if (_SYSVIEW_Globals.pfSendSysDesc) {
600078a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
600078a2:	b1b3      	cbz	r3, 600078d2 <SEGGER_SYSVIEW_GetSysDesc+0x86>
}
600078a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _SYSVIEW_Globals.pfSendSysDesc();
600078a8:	4718      	bx	r3
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
600078aa:	f062 027f 	orn	r2, r2, #127	; 0x7f
600078ae:	09c9      	lsrs	r1, r1, #7
600078b0:	4618      	mov	r0, r3
600078b2:	f803 2c01 	strb.w	r2, [r3, #-1]
600078b6:	e7d5      	b.n	60007864 <SEGGER_SYSVIEW_GetSysDesc+0x18>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
600078b8:	f062 027f 	orn	r2, r2, #127	; 0x7f
600078bc:	09c0      	lsrs	r0, r0, #7
600078be:	460b      	mov	r3, r1
600078c0:	f801 2c01 	strb.w	r2, [r1, #-1]
600078c4:	e7d5      	b.n	60007872 <SEGGER_SYSVIEW_GetSysDesc+0x26>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
600078c6:	f063 037f 	orn	r3, r3, #127	; 0x7f
600078ca:	09d2      	lsrs	r2, r2, #7
600078cc:	f801 3b01 	strb.w	r3, [r1], #1
600078d0:	e7d6      	b.n	60007880 <SEGGER_SYSVIEW_GetSysDesc+0x34>
}
600078d2:	bd70      	pop	{r4, r5, r6, pc}
600078d4:	80000ec8 	.word	0x80000ec8
600078d8:	80000fbd 	.word	0x80000fbd

600078dc <SEGGER_SYSVIEW_SendTaskInfo>:
void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
600078dc:	b570      	push	{r4, r5, r6, lr}
600078de:	4604      	mov	r4, r0
	__asm__ volatile(
600078e0:	f04f 0310 	mov.w	r3, #16
600078e4:	f3ef 8511 	mrs	r5, BASEPRI
600078e8:	f383 8811 	msr	BASEPRI, r3
600078ec:	f3bf 8f6f 	isb	sy
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
600078f0:	4e2f      	ldr	r6, [pc, #188]	; (600079b0 <SEGGER_SYSVIEW_SendTaskInfo+0xd4>)
600078f2:	6803      	ldr	r3, [r0, #0]
600078f4:	6932      	ldr	r2, [r6, #16]
600078f6:	482f      	ldr	r0, [pc, #188]	; (600079b4 <SEGGER_SYSVIEW_SendTaskInfo+0xd8>)
600078f8:	1a9b      	subs	r3, r3, r2
600078fa:	2b7f      	cmp	r3, #127	; 0x7f
600078fc:	b2d9      	uxtb	r1, r3
600078fe:	f100 0201 	add.w	r2, r0, #1
60007902:	d833      	bhi.n	6000796c <SEGGER_SYSVIEW_SendTaskInfo+0x90>
60007904:	7001      	strb	r1, [r0, #0]
  ENCODE_U32(pPayload, pInfo->Prio);
60007906:	68a1      	ldr	r1, [r4, #8]
60007908:	297f      	cmp	r1, #127	; 0x7f
6000790a:	b2cb      	uxtb	r3, r1
6000790c:	f102 0001 	add.w	r0, r2, #1
60007910:	d833      	bhi.n	6000797a <SEGGER_SYSVIEW_SendTaskInfo+0x9e>
60007912:	7013      	strb	r3, [r2, #0]
  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
60007914:	2220      	movs	r2, #32
60007916:	6861      	ldr	r1, [r4, #4]
60007918:	f004 fbc9 	bl	6000c0ae <_EncodeStr>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
6000791c:	2209      	movs	r2, #9
  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
6000791e:	4601      	mov	r1, r0
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
60007920:	4824      	ldr	r0, [pc, #144]	; (600079b4 <SEGGER_SYSVIEW_SendTaskInfo+0xd8>)
60007922:	f7ff fe49 	bl	600075b8 <_SendPacket>
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
60007926:	6823      	ldr	r3, [r4, #0]
60007928:	6932      	ldr	r2, [r6, #16]
6000792a:	4822      	ldr	r0, [pc, #136]	; (600079b4 <SEGGER_SYSVIEW_SendTaskInfo+0xd8>)
6000792c:	1a9b      	subs	r3, r3, r2
6000792e:	2b7f      	cmp	r3, #127	; 0x7f
60007930:	b2d9      	uxtb	r1, r3
60007932:	f100 0201 	add.w	r2, r0, #1
60007936:	d827      	bhi.n	60007988 <SEGGER_SYSVIEW_SendTaskInfo+0xac>
60007938:	7001      	strb	r1, [r0, #0]
  ENCODE_U32(pPayload, pInfo->StackBase);
6000793a:	68e0      	ldr	r0, [r4, #12]
6000793c:	287f      	cmp	r0, #127	; 0x7f
6000793e:	b2c3      	uxtb	r3, r0
60007940:	f102 0101 	add.w	r1, r2, #1
60007944:	d827      	bhi.n	60007996 <SEGGER_SYSVIEW_SendTaskInfo+0xba>
60007946:	7013      	strb	r3, [r2, #0]
  ENCODE_U32(pPayload, pInfo->StackSize);
60007948:	6922      	ldr	r2, [r4, #16]
6000794a:	2a7f      	cmp	r2, #127	; 0x7f
6000794c:	b2d3      	uxtb	r3, r2
6000794e:	d829      	bhi.n	600079a4 <SEGGER_SYSVIEW_SendTaskInfo+0xc8>
60007950:	700b      	strb	r3, [r1, #0]
  ENCODE_U32(pPayload, 0); // Stack End, future use
60007952:	2300      	movs	r3, #0
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
60007954:	2215      	movs	r2, #21
60007956:	3102      	adds	r1, #2
  ENCODE_U32(pPayload, 0); // Stack End, future use
60007958:	f801 3c01 	strb.w	r3, [r1, #-1]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
6000795c:	4815      	ldr	r0, [pc, #84]	; (600079b4 <SEGGER_SYSVIEW_SendTaskInfo+0xd8>)
6000795e:	f7ff fe2b 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007962:	f385 8811 	msr	BASEPRI, r5
60007966:	f3bf 8f6f 	isb	sy
}
6000796a:	bd70      	pop	{r4, r5, r6, pc}
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
6000796c:	f061 017f 	orn	r1, r1, #127	; 0x7f
60007970:	09db      	lsrs	r3, r3, #7
60007972:	4610      	mov	r0, r2
60007974:	f802 1c01 	strb.w	r1, [r2, #-1]
60007978:	e7bf      	b.n	600078fa <SEGGER_SYSVIEW_SendTaskInfo+0x1e>
  ENCODE_U32(pPayload, pInfo->Prio);
6000797a:	f063 037f 	orn	r3, r3, #127	; 0x7f
6000797e:	09c9      	lsrs	r1, r1, #7
60007980:	4602      	mov	r2, r0
60007982:	f800 3c01 	strb.w	r3, [r0, #-1]
60007986:	e7bf      	b.n	60007908 <SEGGER_SYSVIEW_SendTaskInfo+0x2c>
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
60007988:	f061 017f 	orn	r1, r1, #127	; 0x7f
6000798c:	09db      	lsrs	r3, r3, #7
6000798e:	4610      	mov	r0, r2
60007990:	f802 1c01 	strb.w	r1, [r2, #-1]
60007994:	e7cb      	b.n	6000792e <SEGGER_SYSVIEW_SendTaskInfo+0x52>
  ENCODE_U32(pPayload, pInfo->StackBase);
60007996:	f063 037f 	orn	r3, r3, #127	; 0x7f
6000799a:	09c0      	lsrs	r0, r0, #7
6000799c:	460a      	mov	r2, r1
6000799e:	f801 3c01 	strb.w	r3, [r1, #-1]
600079a2:	e7cb      	b.n	6000793c <SEGGER_SYSVIEW_SendTaskInfo+0x60>
  ENCODE_U32(pPayload, pInfo->StackSize);
600079a4:	f063 037f 	orn	r3, r3, #127	; 0x7f
600079a8:	09d2      	lsrs	r2, r2, #7
600079aa:	f801 3b01 	strb.w	r3, [r1], #1
600079ae:	e7cc      	b.n	6000794a <SEGGER_SYSVIEW_SendTaskInfo+0x6e>
600079b0:	80000ec8 	.word	0x80000ec8
600079b4:	80000fbd 	.word	0x80000fbd

600079b8 <SEGGER_SYSVIEW_SendSysDesc>:
void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
600079b8:	4601      	mov	r1, r0
600079ba:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
600079bc:	f04f 0310 	mov.w	r3, #16
600079c0:	f3ef 8511 	mrs	r5, BASEPRI
600079c4:	f383 8811 	msr	BASEPRI, r3
600079c8:	f3bf 8f6f 	isb	sy
  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
600079cc:	4c07      	ldr	r4, [pc, #28]	; (600079ec <SEGGER_SYSVIEW_SendSysDesc+0x34>)
600079ce:	2280      	movs	r2, #128	; 0x80
600079d0:	4620      	mov	r0, r4
600079d2:	f004 fb6c 	bl	6000c0ae <_EncodeStr>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
600079d6:	220e      	movs	r2, #14
  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
600079d8:	4601      	mov	r1, r0
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
600079da:	4620      	mov	r0, r4
600079dc:	f7ff fdec 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
600079e0:	f385 8811 	msr	BASEPRI, r5
600079e4:	f3bf 8f6f 	isb	sy
}
600079e8:	bd38      	pop	{r3, r4, r5, pc}
600079ea:	bf00      	nop
600079ec:	80000fbd 	.word	0x80000fbd

600079f0 <SEGGER_SYSVIEW_RecordEnterISR>:
void SEGGER_SYSVIEW_RecordEnterISR(void) {
600079f0:	b510      	push	{r4, lr}
	__asm__ volatile(
600079f2:	f04f 0310 	mov.w	r3, #16
600079f6:	f3ef 8411 	mrs	r4, BASEPRI
600079fa:	f383 8811 	msr	BASEPRI, r3
600079fe:	f3bf 8f6f 	isb	sy
  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
60007a02:	f7fe f933 	bl	60005c6c <sysview_get_interrupt>
  ENCODE_U32(pPayload, v);
60007a06:	4a0b      	ldr	r2, [pc, #44]	; (60007a34 <SEGGER_SYSVIEW_RecordEnterISR+0x44>)
60007a08:	287f      	cmp	r0, #127	; 0x7f
60007a0a:	b2c3      	uxtb	r3, r0
60007a0c:	f102 0101 	add.w	r1, r2, #1
60007a10:	d809      	bhi.n	60007a26 <SEGGER_SYSVIEW_RecordEnterISR+0x36>
60007a12:	7013      	strb	r3, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
60007a14:	2202      	movs	r2, #2
60007a16:	4807      	ldr	r0, [pc, #28]	; (60007a34 <SEGGER_SYSVIEW_RecordEnterISR+0x44>)
60007a18:	f7ff fdce 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007a1c:	f384 8811 	msr	BASEPRI, r4
60007a20:	f3bf 8f6f 	isb	sy
}
60007a24:	bd10      	pop	{r4, pc}
  ENCODE_U32(pPayload, v);
60007a26:	f063 037f 	orn	r3, r3, #127	; 0x7f
60007a2a:	09c0      	lsrs	r0, r0, #7
60007a2c:	460a      	mov	r2, r1
60007a2e:	f801 3c01 	strb.w	r3, [r1, #-1]
60007a32:	e7e9      	b.n	60007a08 <SEGGER_SYSVIEW_RecordEnterISR+0x18>
60007a34:	80000fbd 	.word	0x80000fbd

60007a38 <SEGGER_SYSVIEW_RecordExitISR>:
void SEGGER_SYSVIEW_RecordExitISR(void) {
60007a38:	b510      	push	{r4, lr}
	__asm__ volatile(
60007a3a:	f04f 0310 	mov.w	r3, #16
60007a3e:	f3ef 8411 	mrs	r4, BASEPRI
60007a42:	f383 8811 	msr	BASEPRI, r3
60007a46:	f3bf 8f6f 	isb	sy
  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
60007a4a:	4905      	ldr	r1, [pc, #20]	; (60007a60 <SEGGER_SYSVIEW_RecordExitISR+0x28>)
60007a4c:	2203      	movs	r2, #3
60007a4e:	4608      	mov	r0, r1
60007a50:	f7ff fdb2 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007a54:	f384 8811 	msr	BASEPRI, r4
60007a58:	f3bf 8f6f 	isb	sy
}
60007a5c:	bd10      	pop	{r4, pc}
60007a5e:	bf00      	nop
60007a60:	80000fbd 	.word	0x80000fbd

60007a64 <SEGGER_SYSVIEW_RecordEndCall>:
void SEGGER_SYSVIEW_RecordEndCall(unsigned int EventID) {
60007a64:	b510      	push	{r4, lr}
	__asm__ volatile(
60007a66:	f04f 0310 	mov.w	r3, #16
60007a6a:	f3ef 8411 	mrs	r4, BASEPRI
60007a6e:	f383 8811 	msr	BASEPRI, r3
60007a72:	f3bf 8f6f 	isb	sy
  ENCODE_U32(pPayload, EventID);
60007a76:	4a0b      	ldr	r2, [pc, #44]	; (60007aa4 <SEGGER_SYSVIEW_RecordEndCall+0x40>)
60007a78:	287f      	cmp	r0, #127	; 0x7f
60007a7a:	b2c3      	uxtb	r3, r0
60007a7c:	f102 0101 	add.w	r1, r2, #1
60007a80:	d809      	bhi.n	60007a96 <SEGGER_SYSVIEW_RecordEndCall+0x32>
60007a82:	7013      	strb	r3, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
60007a84:	221c      	movs	r2, #28
60007a86:	4807      	ldr	r0, [pc, #28]	; (60007aa4 <SEGGER_SYSVIEW_RecordEndCall+0x40>)
60007a88:	f7ff fd96 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007a8c:	f384 8811 	msr	BASEPRI, r4
60007a90:	f3bf 8f6f 	isb	sy
}
60007a94:	bd10      	pop	{r4, pc}
  ENCODE_U32(pPayload, EventID);
60007a96:	f063 037f 	orn	r3, r3, #127	; 0x7f
60007a9a:	09c0      	lsrs	r0, r0, #7
60007a9c:	460a      	mov	r2, r1
60007a9e:	f801 3c01 	strb.w	r3, [r1, #-1]
60007aa2:	e7e9      	b.n	60007a78 <SEGGER_SYSVIEW_RecordEndCall+0x14>
60007aa4:	80000fbd 	.word	0x80000fbd

60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>:
void SEGGER_SYSVIEW_RecordEndCallU32(unsigned int EventID, U32 Para0) {
60007aa8:	b538      	push	{r3, r4, r5, lr}
60007aaa:	460b      	mov	r3, r1
	__asm__ volatile(
60007aac:	f04f 0210 	mov.w	r2, #16
60007ab0:	f3ef 8411 	mrs	r4, BASEPRI
60007ab4:	f382 8811 	msr	BASEPRI, r2
60007ab8:	f3bf 8f6f 	isb	sy
  ENCODE_U32(pPayload, EventID);
60007abc:	4d11      	ldr	r5, [pc, #68]	; (60007b04 <SEGGER_SYSVIEW_RecordEndCallU32+0x5c>)
60007abe:	287f      	cmp	r0, #127	; 0x7f
60007ac0:	b2c1      	uxtb	r1, r0
60007ac2:	f105 0201 	add.w	r2, r5, #1
60007ac6:	d80f      	bhi.n	60007ae8 <SEGGER_SYSVIEW_RecordEndCallU32+0x40>
60007ac8:	7029      	strb	r1, [r5, #0]
  ENCODE_U32(pPayload, Para0);
60007aca:	2b7f      	cmp	r3, #127	; 0x7f
60007acc:	b2d8      	uxtb	r0, r3
60007ace:	f102 0101 	add.w	r1, r2, #1
60007ad2:	d810      	bhi.n	60007af6 <SEGGER_SYSVIEW_RecordEndCallU32+0x4e>
60007ad4:	7010      	strb	r0, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
60007ad6:	221c      	movs	r2, #28
60007ad8:	480a      	ldr	r0, [pc, #40]	; (60007b04 <SEGGER_SYSVIEW_RecordEndCallU32+0x5c>)
60007ada:	f7ff fd6d 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007ade:	f384 8811 	msr	BASEPRI, r4
60007ae2:	f3bf 8f6f 	isb	sy
}
60007ae6:	bd38      	pop	{r3, r4, r5, pc}
  ENCODE_U32(pPayload, EventID);
60007ae8:	f061 017f 	orn	r1, r1, #127	; 0x7f
60007aec:	09c0      	lsrs	r0, r0, #7
60007aee:	4615      	mov	r5, r2
60007af0:	f802 1c01 	strb.w	r1, [r2, #-1]
60007af4:	e7e3      	b.n	60007abe <SEGGER_SYSVIEW_RecordEndCallU32+0x16>
  ENCODE_U32(pPayload, Para0);
60007af6:	f060 007f 	orn	r0, r0, #127	; 0x7f
60007afa:	09db      	lsrs	r3, r3, #7
60007afc:	460a      	mov	r2, r1
60007afe:	f801 0c01 	strb.w	r0, [r1, #-1]
60007b02:	e7e2      	b.n	60007aca <SEGGER_SYSVIEW_RecordEndCallU32+0x22>
60007b04:	80000fbd 	.word	0x80000fbd

60007b08 <SEGGER_SYSVIEW_OnIdle>:
void SEGGER_SYSVIEW_OnIdle(void) {
60007b08:	b510      	push	{r4, lr}
	__asm__ volatile(
60007b0a:	f04f 0310 	mov.w	r3, #16
60007b0e:	f3ef 8411 	mrs	r4, BASEPRI
60007b12:	f383 8811 	msr	BASEPRI, r3
60007b16:	f3bf 8f6f 	isb	sy
  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
60007b1a:	4905      	ldr	r1, [pc, #20]	; (60007b30 <SEGGER_SYSVIEW_OnIdle+0x28>)
60007b1c:	2211      	movs	r2, #17
60007b1e:	4608      	mov	r0, r1
60007b20:	f7ff fd4a 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007b24:	f384 8811 	msr	BASEPRI, r4
60007b28:	f3bf 8f6f 	isb	sy
}
60007b2c:	bd10      	pop	{r4, pc}
60007b2e:	bf00      	nop
60007b30:	80000fbd 	.word	0x80000fbd

60007b34 <SEGGER_SYSVIEW_OnTaskCreate>:
void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
60007b34:	b510      	push	{r4, lr}
	__asm__ volatile(
60007b36:	f04f 0310 	mov.w	r3, #16
60007b3a:	f3ef 8411 	mrs	r4, BASEPRI
60007b3e:	f383 8811 	msr	BASEPRI, r3
60007b42:	f3bf 8f6f 	isb	sy
  TaskId = SHRINK_ID(TaskId);
60007b46:	4b0d      	ldr	r3, [pc, #52]	; (60007b7c <SEGGER_SYSVIEW_OnTaskCreate+0x48>)
  ENCODE_U32(pPayload, TaskId);
60007b48:	4a0d      	ldr	r2, [pc, #52]	; (60007b80 <SEGGER_SYSVIEW_OnTaskCreate+0x4c>)
  TaskId = SHRINK_ID(TaskId);
60007b4a:	691b      	ldr	r3, [r3, #16]
60007b4c:	1ac0      	subs	r0, r0, r3
  ENCODE_U32(pPayload, TaskId);
60007b4e:	287f      	cmp	r0, #127	; 0x7f
60007b50:	b2c3      	uxtb	r3, r0
60007b52:	f102 0101 	add.w	r1, r2, #1
60007b56:	d809      	bhi.n	60007b6c <SEGGER_SYSVIEW_OnTaskCreate+0x38>
60007b58:	7013      	strb	r3, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
60007b5a:	2208      	movs	r2, #8
60007b5c:	4808      	ldr	r0, [pc, #32]	; (60007b80 <SEGGER_SYSVIEW_OnTaskCreate+0x4c>)
60007b5e:	f7ff fd2b 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007b62:	f384 8811 	msr	BASEPRI, r4
60007b66:	f3bf 8f6f 	isb	sy
}
60007b6a:	bd10      	pop	{r4, pc}
  ENCODE_U32(pPayload, TaskId);
60007b6c:	f063 037f 	orn	r3, r3, #127	; 0x7f
60007b70:	09c0      	lsrs	r0, r0, #7
60007b72:	460a      	mov	r2, r1
60007b74:	f801 3c01 	strb.w	r3, [r1, #-1]
60007b78:	e7e9      	b.n	60007b4e <SEGGER_SYSVIEW_OnTaskCreate+0x1a>
60007b7a:	bf00      	nop
60007b7c:	80000ec8 	.word	0x80000ec8
60007b80:	80000fbd 	.word	0x80000fbd

60007b84 <SEGGER_SYSVIEW_OnTaskStartExec>:
void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
60007b84:	b510      	push	{r4, lr}
	__asm__ volatile(
60007b86:	f04f 0310 	mov.w	r3, #16
60007b8a:	f3ef 8411 	mrs	r4, BASEPRI
60007b8e:	f383 8811 	msr	BASEPRI, r3
60007b92:	f3bf 8f6f 	isb	sy
  TaskId = SHRINK_ID(TaskId);
60007b96:	4b0d      	ldr	r3, [pc, #52]	; (60007bcc <SEGGER_SYSVIEW_OnTaskStartExec+0x48>)
  ENCODE_U32(pPayload, TaskId);
60007b98:	4a0d      	ldr	r2, [pc, #52]	; (60007bd0 <SEGGER_SYSVIEW_OnTaskStartExec+0x4c>)
  TaskId = SHRINK_ID(TaskId);
60007b9a:	691b      	ldr	r3, [r3, #16]
60007b9c:	1ac0      	subs	r0, r0, r3
  ENCODE_U32(pPayload, TaskId);
60007b9e:	287f      	cmp	r0, #127	; 0x7f
60007ba0:	b2c3      	uxtb	r3, r0
60007ba2:	f102 0101 	add.w	r1, r2, #1
60007ba6:	d809      	bhi.n	60007bbc <SEGGER_SYSVIEW_OnTaskStartExec+0x38>
60007ba8:	7013      	strb	r3, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
60007baa:	2204      	movs	r2, #4
60007bac:	4808      	ldr	r0, [pc, #32]	; (60007bd0 <SEGGER_SYSVIEW_OnTaskStartExec+0x4c>)
60007bae:	f7ff fd03 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007bb2:	f384 8811 	msr	BASEPRI, r4
60007bb6:	f3bf 8f6f 	isb	sy
}
60007bba:	bd10      	pop	{r4, pc}
  ENCODE_U32(pPayload, TaskId);
60007bbc:	f063 037f 	orn	r3, r3, #127	; 0x7f
60007bc0:	09c0      	lsrs	r0, r0, #7
60007bc2:	460a      	mov	r2, r1
60007bc4:	f801 3c01 	strb.w	r3, [r1, #-1]
60007bc8:	e7e9      	b.n	60007b9e <SEGGER_SYSVIEW_OnTaskStartExec+0x1a>
60007bca:	bf00      	nop
60007bcc:	80000ec8 	.word	0x80000ec8
60007bd0:	80000fbd 	.word	0x80000fbd

60007bd4 <SEGGER_SYSVIEW_OnTaskStopExec>:
void SEGGER_SYSVIEW_OnTaskStopExec(void) {
60007bd4:	b510      	push	{r4, lr}
	__asm__ volatile(
60007bd6:	f04f 0310 	mov.w	r3, #16
60007bda:	f3ef 8411 	mrs	r4, BASEPRI
60007bde:	f383 8811 	msr	BASEPRI, r3
60007be2:	f3bf 8f6f 	isb	sy
  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TASK_STOP_EXEC);
60007be6:	4905      	ldr	r1, [pc, #20]	; (60007bfc <SEGGER_SYSVIEW_OnTaskStopExec+0x28>)
60007be8:	2205      	movs	r2, #5
60007bea:	4608      	mov	r0, r1
60007bec:	f7ff fce4 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007bf0:	f384 8811 	msr	BASEPRI, r4
60007bf4:	f3bf 8f6f 	isb	sy
}
60007bf8:	bd10      	pop	{r4, pc}
60007bfa:	bf00      	nop
60007bfc:	80000fbd 	.word	0x80000fbd

60007c00 <SEGGER_SYSVIEW_OnTaskStartReady>:
void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
60007c00:	b510      	push	{r4, lr}
	__asm__ volatile(
60007c02:	f04f 0310 	mov.w	r3, #16
60007c06:	f3ef 8411 	mrs	r4, BASEPRI
60007c0a:	f383 8811 	msr	BASEPRI, r3
60007c0e:	f3bf 8f6f 	isb	sy
  TaskId = SHRINK_ID(TaskId);
60007c12:	4b0d      	ldr	r3, [pc, #52]	; (60007c48 <SEGGER_SYSVIEW_OnTaskStartReady+0x48>)
  ENCODE_U32(pPayload, TaskId);
60007c14:	4a0d      	ldr	r2, [pc, #52]	; (60007c4c <SEGGER_SYSVIEW_OnTaskStartReady+0x4c>)
  TaskId = SHRINK_ID(TaskId);
60007c16:	691b      	ldr	r3, [r3, #16]
60007c18:	1ac0      	subs	r0, r0, r3
  ENCODE_U32(pPayload, TaskId);
60007c1a:	287f      	cmp	r0, #127	; 0x7f
60007c1c:	b2c3      	uxtb	r3, r0
60007c1e:	f102 0101 	add.w	r1, r2, #1
60007c22:	d809      	bhi.n	60007c38 <SEGGER_SYSVIEW_OnTaskStartReady+0x38>
60007c24:	7013      	strb	r3, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
60007c26:	2206      	movs	r2, #6
60007c28:	4808      	ldr	r0, [pc, #32]	; (60007c4c <SEGGER_SYSVIEW_OnTaskStartReady+0x4c>)
60007c2a:	f7ff fcc5 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007c2e:	f384 8811 	msr	BASEPRI, r4
60007c32:	f3bf 8f6f 	isb	sy
}
60007c36:	bd10      	pop	{r4, pc}
  ENCODE_U32(pPayload, TaskId);
60007c38:	f063 037f 	orn	r3, r3, #127	; 0x7f
60007c3c:	09c0      	lsrs	r0, r0, #7
60007c3e:	460a      	mov	r2, r1
60007c40:	f801 3c01 	strb.w	r3, [r1, #-1]
60007c44:	e7e9      	b.n	60007c1a <SEGGER_SYSVIEW_OnTaskStartReady+0x1a>
60007c46:	bf00      	nop
60007c48:	80000ec8 	.word	0x80000ec8
60007c4c:	80000fbd 	.word	0x80000fbd

60007c50 <SEGGER_SYSVIEW_OnTaskStopReady>:
void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
60007c50:	b538      	push	{r3, r4, r5, lr}
60007c52:	460b      	mov	r3, r1
	__asm__ volatile(
60007c54:	f04f 0210 	mov.w	r2, #16
60007c58:	f3ef 8411 	mrs	r4, BASEPRI
60007c5c:	f382 8811 	msr	BASEPRI, r2
60007c60:	f3bf 8f6f 	isb	sy
  TaskId = SHRINK_ID(TaskId);
60007c64:	4a13      	ldr	r2, [pc, #76]	; (60007cb4 <SEGGER_SYSVIEW_OnTaskStopReady+0x64>)
  ENCODE_U32(pPayload, TaskId);
60007c66:	4d14      	ldr	r5, [pc, #80]	; (60007cb8 <SEGGER_SYSVIEW_OnTaskStopReady+0x68>)
  TaskId = SHRINK_ID(TaskId);
60007c68:	6912      	ldr	r2, [r2, #16]
60007c6a:	1a80      	subs	r0, r0, r2
  ENCODE_U32(pPayload, TaskId);
60007c6c:	287f      	cmp	r0, #127	; 0x7f
60007c6e:	b2c1      	uxtb	r1, r0
60007c70:	f105 0201 	add.w	r2, r5, #1
60007c74:	d80f      	bhi.n	60007c96 <SEGGER_SYSVIEW_OnTaskStopReady+0x46>
60007c76:	7029      	strb	r1, [r5, #0]
  ENCODE_U32(pPayload, Cause);
60007c78:	2b7f      	cmp	r3, #127	; 0x7f
60007c7a:	b2d8      	uxtb	r0, r3
60007c7c:	f102 0101 	add.w	r1, r2, #1
60007c80:	d810      	bhi.n	60007ca4 <SEGGER_SYSVIEW_OnTaskStopReady+0x54>
60007c82:	7010      	strb	r0, [r2, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
60007c84:	2207      	movs	r2, #7
60007c86:	480c      	ldr	r0, [pc, #48]	; (60007cb8 <SEGGER_SYSVIEW_OnTaskStopReady+0x68>)
60007c88:	f7ff fc96 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007c8c:	f384 8811 	msr	BASEPRI, r4
60007c90:	f3bf 8f6f 	isb	sy
}
60007c94:	bd38      	pop	{r3, r4, r5, pc}
  ENCODE_U32(pPayload, TaskId);
60007c96:	f061 017f 	orn	r1, r1, #127	; 0x7f
60007c9a:	09c0      	lsrs	r0, r0, #7
60007c9c:	4615      	mov	r5, r2
60007c9e:	f802 1c01 	strb.w	r1, [r2, #-1]
60007ca2:	e7e3      	b.n	60007c6c <SEGGER_SYSVIEW_OnTaskStopReady+0x1c>
  ENCODE_U32(pPayload, Cause);
60007ca4:	f060 007f 	orn	r0, r0, #127	; 0x7f
60007ca8:	09db      	lsrs	r3, r3, #7
60007caa:	460a      	mov	r2, r1
60007cac:	f801 0c01 	strb.w	r0, [r1, #-1]
60007cb0:	e7e2      	b.n	60007c78 <SEGGER_SYSVIEW_OnTaskStopReady+0x28>
60007cb2:	bf00      	nop
60007cb4:	80000ec8 	.word	0x80000ec8
60007cb8:	80000fbd 	.word	0x80000fbd

60007cbc <SEGGER_SYSVIEW_SendModule>:
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
60007cbc:	b538      	push	{r3, r4, r5, lr}
  if (_pFirstModule != 0) {
60007cbe:	4b1d      	ldr	r3, [pc, #116]	; (60007d34 <SEGGER_SYSVIEW_SendModule+0x78>)
60007cc0:	6819      	ldr	r1, [r3, #0]
60007cc2:	b991      	cbnz	r1, 60007cea <SEGGER_SYSVIEW_SendModule+0x2e>
}
60007cc4:	bd38      	pop	{r3, r4, r5, pc}
      pModule = pModule->pNext;
60007cc6:	6909      	ldr	r1, [r1, #16]
      if (pModule == 0) {
60007cc8:	2900      	cmp	r1, #0
60007cca:	d0fb      	beq.n	60007cc4 <SEGGER_SYSVIEW_SendModule+0x8>
    for (n = 0; n < ModuleId; n++) {
60007ccc:	3301      	adds	r3, #1
60007cce:	4298      	cmp	r0, r3
60007cd0:	d8f9      	bhi.n	60007cc6 <SEGGER_SYSVIEW_SendModule+0xa>
	__asm__ volatile(
60007cd2:	f04f 0310 	mov.w	r3, #16
60007cd6:	f3ef 8511 	mrs	r5, BASEPRI
60007cda:	f383 8811 	msr	BASEPRI, r3
60007cde:	f3bf 8f6f 	isb	sy
      ENCODE_U32(pPayload, ModuleId);
60007ce2:	287f      	cmp	r0, #127	; 0x7f
60007ce4:	d804      	bhi.n	60007cf0 <SEGGER_SYSVIEW_SendModule+0x34>
60007ce6:	4b14      	ldr	r3, [pc, #80]	; (60007d38 <SEGGER_SYSVIEW_SendModule+0x7c>)
60007ce8:	e006      	b.n	60007cf8 <SEGGER_SYSVIEW_SendModule+0x3c>
    for (n = 0; n < ModuleId; n++) {
60007cea:	2300      	movs	r3, #0
60007cec:	4602      	mov	r2, r0
60007cee:	e7ee      	b.n	60007cce <SEGGER_SYSVIEW_SendModule+0x12>
      ENCODE_U32(pPayload, ModuleId);
60007cf0:	4b12      	ldr	r3, [pc, #72]	; (60007d3c <SEGGER_SYSVIEW_SendModule+0x80>)
60007cf2:	2201      	movs	r2, #1
60007cf4:	7118      	strb	r0, [r3, #4]
60007cf6:	3305      	adds	r3, #5
60007cf8:	f803 2b01 	strb.w	r2, [r3], #1
      ENCODE_U32(pPayload, (pModule->EventOffset));
60007cfc:	688c      	ldr	r4, [r1, #8]
60007cfe:	2c7f      	cmp	r4, #127	; 0x7f
60007d00:	b2e2      	uxtb	r2, r4
60007d02:	f103 0001 	add.w	r0, r3, #1
60007d06:	d80e      	bhi.n	60007d26 <SEGGER_SYSVIEW_SendModule+0x6a>
60007d08:	701a      	strb	r2, [r3, #0]
      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
60007d0a:	2280      	movs	r2, #128	; 0x80
60007d0c:	6809      	ldr	r1, [r1, #0]
60007d0e:	f004 f9ce 	bl	6000c0ae <_EncodeStr>
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
60007d12:	2216      	movs	r2, #22
      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
60007d14:	4601      	mov	r1, r0
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
60007d16:	4808      	ldr	r0, [pc, #32]	; (60007d38 <SEGGER_SYSVIEW_SendModule+0x7c>)
60007d18:	f7ff fc4e 	bl	600075b8 <_SendPacket>
	__asm__ volatile(
60007d1c:	f385 8811 	msr	BASEPRI, r5
60007d20:	f3bf 8f6f 	isb	sy
}
60007d24:	e7ce      	b.n	60007cc4 <SEGGER_SYSVIEW_SendModule+0x8>
      ENCODE_U32(pPayload, (pModule->EventOffset));
60007d26:	f062 027f 	orn	r2, r2, #127	; 0x7f
60007d2a:	09e4      	lsrs	r4, r4, #7
60007d2c:	4603      	mov	r3, r0
60007d2e:	f800 2c01 	strb.w	r2, [r0, #-1]
60007d32:	e7e4      	b.n	60007cfe <SEGGER_SYSVIEW_SendModule+0x42>
60007d34:	80000ef0 	.word	0x80000ef0
60007d38:	80000fbd 	.word	0x80000fbd
60007d3c:	80000fb9 	.word	0x80000fb9

60007d40 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
60007d40:	4b0e      	ldr	r3, [pc, #56]	; (60007d7c <z_sys_init_run_level+0x3c>)
{
60007d42:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
60007d44:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
60007d48:	3001      	adds	r0, #1
60007d4a:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
60007d4e:	42a6      	cmp	r6, r4
60007d50:	d800      	bhi.n	60007d54 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
60007d52:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
60007d54:	e9d4 3500 	ldrd	r3, r5, [r4]
60007d58:	4628      	mov	r0, r5
60007d5a:	4798      	blx	r3
		if (dev != NULL) {
60007d5c:	b165      	cbz	r5, 60007d78 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
60007d5e:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
60007d60:	b130      	cbz	r0, 60007d70 <z_sys_init_run_level+0x30>
				if (rc < 0) {
60007d62:	2800      	cmp	r0, #0
60007d64:	bfb8      	it	lt
60007d66:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
60007d68:	28ff      	cmp	r0, #255	; 0xff
60007d6a:	bfa8      	it	ge
60007d6c:	20ff      	movge	r0, #255	; 0xff
60007d6e:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
60007d70:	785a      	ldrb	r2, [r3, #1]
60007d72:	f042 0201 	orr.w	r2, r2, #1
60007d76:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
60007d78:	3408      	adds	r4, #8
60007d7a:	e7e8      	b.n	60007d4e <z_sys_init_run_level+0xe>
60007d7c:	6000d6d8 	.word	0x6000d6d8

60007d80 <z_device_get_all_static>:
#include <syscalls/device_usable_check_mrsh.c>
#endif /* CONFIG_USERSPACE */

size_t z_device_get_all_static(struct device const **devices)
{
	*devices = __device_start;
60007d80:	4a03      	ldr	r2, [pc, #12]	; (60007d90 <z_device_get_all_static+0x10>)
	return __device_end - __device_start;
60007d82:	4b04      	ldr	r3, [pc, #16]	; (60007d94 <z_device_get_all_static+0x14>)
	*devices = __device_start;
60007d84:	6002      	str	r2, [r0, #0]
	return __device_end - __device_start;
60007d86:	1a9b      	subs	r3, r3, r2
}
60007d88:	4803      	ldr	r0, [pc, #12]	; (60007d98 <z_device_get_all_static+0x18>)
	return __device_end - __device_start;
60007d8a:	10db      	asrs	r3, r3, #3
}
60007d8c:	4358      	muls	r0, r3
60007d8e:	4770      	bx	lr
60007d90:	80000174 	.word	0x80000174
60007d94:	80000234 	.word	0x80000234
60007d98:	aaaaaaab 	.word	0xaaaaaaab

60007d9c <z_impl_device_get_binding>:
{
60007d9c:	b570      	push	{r4, r5, r6, lr}
	if ((name == NULL) || (name[0] == '\0')) {
60007d9e:	4605      	mov	r5, r0
60007da0:	b910      	cbnz	r0, 60007da8 <z_impl_device_get_binding+0xc>
		return NULL;
60007da2:	2400      	movs	r4, #0
}
60007da4:	4620      	mov	r0, r4
60007da6:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
60007da8:	7803      	ldrb	r3, [r0, #0]
60007daa:	2b00      	cmp	r3, #0
60007dac:	d0f9      	beq.n	60007da2 <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
60007dae:	4c0e      	ldr	r4, [pc, #56]	; (60007de8 <z_impl_device_get_binding+0x4c>)
60007db0:	4e0e      	ldr	r6, [pc, #56]	; (60007dec <z_impl_device_get_binding+0x50>)
60007db2:	42b4      	cmp	r4, r6
60007db4:	d108      	bne.n	60007dc8 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
60007db6:	4c0c      	ldr	r4, [pc, #48]	; (60007de8 <z_impl_device_get_binding+0x4c>)
60007db8:	42b4      	cmp	r4, r6
60007dba:	d0f2      	beq.n	60007da2 <z_impl_device_get_binding+0x6>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
60007dbc:	4620      	mov	r0, r4
60007dbe:	f004 f99b 	bl	6000c0f8 <z_device_ready>
60007dc2:	b950      	cbnz	r0, 60007dda <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
60007dc4:	3418      	adds	r4, #24
60007dc6:	e7f7      	b.n	60007db8 <z_impl_device_get_binding+0x1c>
		if (z_device_ready(dev) && (dev->name == name)) {
60007dc8:	4620      	mov	r0, r4
60007dca:	f004 f995 	bl	6000c0f8 <z_device_ready>
60007dce:	b110      	cbz	r0, 60007dd6 <z_impl_device_get_binding+0x3a>
60007dd0:	6823      	ldr	r3, [r4, #0]
60007dd2:	42ab      	cmp	r3, r5
60007dd4:	d0e6      	beq.n	60007da4 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
60007dd6:	3418      	adds	r4, #24
60007dd8:	e7eb      	b.n	60007db2 <z_impl_device_get_binding+0x16>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
60007dda:	6821      	ldr	r1, [r4, #0]
60007ddc:	4628      	mov	r0, r5
60007dde:	f003 fd72 	bl	6000b8c6 <strcmp>
60007de2:	2800      	cmp	r0, #0
60007de4:	d1ee      	bne.n	60007dc4 <z_impl_device_get_binding+0x28>
60007de6:	e7dd      	b.n	60007da4 <z_impl_device_get_binding+0x8>
60007de8:	80000174 	.word	0x80000174
60007dec:	80000234 	.word	0x80000234

60007df0 <device_required_foreach>:
}

int device_required_foreach(const struct device *dev,
			  device_visitor_callback_t visitor_cb,
			  void *context)
{
60007df0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
60007df4:	6944      	ldr	r4, [r0, #20]
60007df6:	460f      	mov	r7, r1
60007df8:	4692      	mov	sl, r2
	if (rv != NULL) {
60007dfa:	bb3c      	cbnz	r4, 60007e4c <device_required_foreach+0x5c>
	size_t handle_count = 0;
60007dfc:	4626      	mov	r6, r4
		if (rc < 0) {
			return rc;
		}
	}

	return handle_count;
60007dfe:	4630      	mov	r0, r6
60007e00:	e022      	b.n	60007e48 <device_required_foreach+0x58>
			++i;
60007e02:	3601      	adds	r6, #1
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
60007e04:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
60007e08:	440b      	add	r3, r1
		while ((rv[i] != DEVICE_HANDLE_ENDS)
60007e0a:	b29b      	uxth	r3, r3
60007e0c:	4293      	cmp	r3, r2
60007e0e:	d9f8      	bls.n	60007e02 <device_required_foreach+0x12>
	size_t numdev = __device_end - __device_start;
60007e10:	f8df 8048 	ldr.w	r8, [pc, #72]	; 60007e5c <device_required_foreach+0x6c>
60007e14:	eb04 0946 	add.w	r9, r4, r6, lsl #1
60007e18:	4d11      	ldr	r5, [pc, #68]	; (60007e60 <device_required_foreach+0x70>)
60007e1a:	4b12      	ldr	r3, [pc, #72]	; (60007e64 <device_required_foreach+0x74>)
60007e1c:	eba5 0508 	sub.w	r5, r5, r8
60007e20:	10ed      	asrs	r5, r5, #3
60007e22:	435d      	muls	r5, r3
	for (size_t i = 0; i < handle_count; ++i) {
60007e24:	45a1      	cmp	r9, r4
60007e26:	d0ea      	beq.n	60007dfe <device_required_foreach+0xe>
		device_handle_t dh = handles[i];
60007e28:	f934 0b02 	ldrsh.w	r0, [r4], #2
	if ((dev_handle > 0) && ((size_t)dev_handle < numdev)) {
60007e2c:	2800      	cmp	r0, #0
60007e2e:	dd13      	ble.n	60007e58 <device_required_foreach+0x68>
60007e30:	4285      	cmp	r5, r0
60007e32:	d911      	bls.n	60007e58 <device_required_foreach+0x68>
		dev = &__device_start[dev_handle - 1];
60007e34:	3801      	subs	r0, #1
60007e36:	b200      	sxth	r0, r0
60007e38:	eb00 0040 	add.w	r0, r0, r0, lsl #1
60007e3c:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
		int rc = visitor_cb(rdev, context);
60007e40:	4651      	mov	r1, sl
60007e42:	47b8      	blx	r7
		if (rc < 0) {
60007e44:	2800      	cmp	r0, #0
60007e46:	daed      	bge.n	60007e24 <device_required_foreach+0x34>
}
60007e48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		size_t i = 0;
60007e4c:	2600      	movs	r6, #0
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
60007e4e:	f647 71ff 	movw	r1, #32767	; 0x7fff
		while ((rv[i] != DEVICE_HANDLE_ENDS)
60007e52:	f64f 72fd 	movw	r2, #65533	; 0xfffd
60007e56:	e7d5      	b.n	60007e04 <device_required_foreach+0x14>
	const struct device *dev = NULL;
60007e58:	2000      	movs	r0, #0
60007e5a:	e7f1      	b.n	60007e40 <device_required_foreach+0x50>
60007e5c:	80000174 	.word	0x80000174
60007e60:	80000234 	.word	0x80000234
60007e64:	aaaaaaab 	.word	0xaaaaaaab

60007e68 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
60007e68:	b510      	push	{r4, lr}
60007e6a:	4604      	mov	r4, r0
	z_impl_log_panic();
60007e6c:	f7fb fc92 	bl	60003794 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
60007e70:	4907      	ldr	r1, [pc, #28]	; (60007e90 <k_sys_fatal_error_handler+0x28>)
60007e72:	680b      	ldr	r3, [r1, #0]
60007e74:	075b      	lsls	r3, r3, #29
60007e76:	d008      	beq.n	60007e8a <k_sys_fatal_error_handler+0x22>
60007e78:	4b06      	ldr	r3, [pc, #24]	; (60007e94 <k_sys_fatal_error_handler+0x2c>)
60007e7a:	4807      	ldr	r0, [pc, #28]	; (60007e98 <k_sys_fatal_error_handler+0x30>)
60007e7c:	1ac9      	subs	r1, r1, r3
60007e7e:	0889      	lsrs	r1, r1, #2
60007e80:	0189      	lsls	r1, r1, #6
60007e82:	f041 0101 	orr.w	r1, r1, #1
60007e86:	f002 f8c3 	bl	6000a010 <log_0>
	arch_system_halt(reason);
60007e8a:	4620      	mov	r0, r4
60007e8c:	f004 f93e 	bl	6000c10c <arch_system_halt>
60007e90:	80000240 	.word	0x80000240
60007e94:	80000234 	.word	0x80000234
60007e98:	6000eb10 	.word	0x6000eb10

60007e9c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
60007e9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
60007ea0:	4606      	mov	r6, r0
60007ea2:	460f      	mov	r7, r1
	__asm__ volatile(
60007ea4:	f04f 0310 	mov.w	r3, #16
60007ea8:	f3ef 8811 	mrs	r8, BASEPRI
60007eac:	f383 8811 	msr	BASEPRI, r3
60007eb0:	f3bf 8f6f 	isb	sy
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
60007eb4:	4c2d      	ldr	r4, [pc, #180]	; (60007f6c <z_fatal_error+0xd0>)
	return z_impl_k_current_get();
60007eb6:	f001 f829 	bl	60008f0c <z_impl_k_current_get>
60007eba:	4605      	mov	r5, r0
60007ebc:	6823      	ldr	r3, [r4, #0]
60007ebe:	0759      	lsls	r1, r3, #29
60007ec0:	d050      	beq.n	60007f64 <z_fatal_error+0xc8>
60007ec2:	4b2b      	ldr	r3, [pc, #172]	; (60007f70 <z_fatal_error+0xd4>)
60007ec4:	2e04      	cmp	r6, #4
60007ec6:	4631      	mov	r1, r6
60007ec8:	482a      	ldr	r0, [pc, #168]	; (60007f74 <z_fatal_error+0xd8>)
60007eca:	eba4 0303 	sub.w	r3, r4, r3
60007ece:	bf94      	ite	ls
60007ed0:	4a29      	ldrls	r2, [pc, #164]	; (60007f78 <z_fatal_error+0xdc>)
60007ed2:	4a2a      	ldrhi	r2, [pc, #168]	; (60007f7c <z_fatal_error+0xe0>)
60007ed4:	ea4f 0393 	mov.w	r3, r3, lsr #2
60007ed8:	bf98      	it	ls
60007eda:	f852 2026 	ldrls.w	r2, [r2, r6, lsl #2]
60007ede:	019b      	lsls	r3, r3, #6
60007ee0:	f043 0301 	orr.w	r3, r3, #1
60007ee4:	f8ad 3000 	strh.w	r3, [sp]
60007ee8:	2300      	movs	r3, #0
60007eea:	f002 f8cb 	bl	6000a084 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
60007eee:	b17f      	cbz	r7, 60007f10 <z_fatal_error+0x74>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
60007ef0:	69fb      	ldr	r3, [r7, #28]
60007ef2:	f3c3 0308 	ubfx	r3, r3, #0, #9
60007ef6:	b15b      	cbz	r3, 60007f10 <z_fatal_error+0x74>
		LOG_ERR("Fault during interrupt handling\n");
60007ef8:	6823      	ldr	r3, [r4, #0]
60007efa:	075a      	lsls	r2, r3, #29
60007efc:	d01b      	beq.n	60007f36 <z_fatal_error+0x9a>
60007efe:	491c      	ldr	r1, [pc, #112]	; (60007f70 <z_fatal_error+0xd4>)
60007f00:	481f      	ldr	r0, [pc, #124]	; (60007f80 <z_fatal_error+0xe4>)
60007f02:	1a61      	subs	r1, r4, r1
60007f04:	0889      	lsrs	r1, r1, #2
60007f06:	0189      	lsls	r1, r1, #6
60007f08:	f041 0101 	orr.w	r1, r1, #1
60007f0c:	f002 f880 	bl	6000a010 <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
60007f10:	6823      	ldr	r3, [r4, #0]
60007f12:	075b      	lsls	r3, r3, #29
60007f14:	d00f      	beq.n	60007f36 <z_fatal_error+0x9a>
60007f16:	4b16      	ldr	r3, [pc, #88]	; (60007f70 <z_fatal_error+0xd4>)
60007f18:	1ae4      	subs	r4, r4, r3
60007f1a:	08a4      	lsrs	r4, r4, #2
60007f1c:	01a4      	lsls	r4, r4, #6
60007f1e:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
60007f22:	b9b5      	cbnz	r5, 60007f52 <z_fatal_error+0xb6>
		thread_name = "unknown";
60007f24:	4817      	ldr	r0, [pc, #92]	; (60007f84 <z_fatal_error+0xe8>)
{
	if (IS_ENABLED(CONFIG_LOG_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
60007f26:	f7fb faa3 	bl	60003470 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
60007f2a:	4623      	mov	r3, r4
60007f2c:	4602      	mov	r2, r0
60007f2e:	4629      	mov	r1, r5
60007f30:	4815      	ldr	r0, [pc, #84]	; (60007f88 <z_fatal_error+0xec>)
60007f32:	f002 f88e 	bl	6000a052 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
60007f36:	4639      	mov	r1, r7
60007f38:	4630      	mov	r0, r6
60007f3a:	f7ff ff95 	bl	60007e68 <k_sys_fatal_error_handler>
	__asm__ volatile(
60007f3e:	f388 8811 	msr	BASEPRI, r8
60007f42:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
60007f46:	4628      	mov	r0, r5
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
60007f48:	b002      	add	sp, #8
60007f4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
60007f4e:	f7fe bcbf 	b.w	600068d0 <z_impl_k_thread_abort>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
60007f52:	4628      	mov	r0, r5
60007f54:	f004 f945 	bl	6000c1e2 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
60007f58:	2800      	cmp	r0, #0
60007f5a:	d0e3      	beq.n	60007f24 <z_fatal_error+0x88>
60007f5c:	7803      	ldrb	r3, [r0, #0]
60007f5e:	2b00      	cmp	r3, #0
60007f60:	d0e0      	beq.n	60007f24 <z_fatal_error+0x88>
60007f62:	e7e0      	b.n	60007f26 <z_fatal_error+0x8a>
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
60007f64:	2f00      	cmp	r7, #0
60007f66:	d1c3      	bne.n	60007ef0 <z_fatal_error+0x54>
60007f68:	e7e5      	b.n	60007f36 <z_fatal_error+0x9a>
60007f6a:	bf00      	nop
60007f6c:	80000240 	.word	0x80000240
60007f70:	80000234 	.word	0x80000234
60007f74:	6000eb35 	.word	0x6000eb35
60007f78:	6000d6f0 	.word	0x6000d6f0
60007f7c:	6000eb1f 	.word	0x6000eb1f
60007f80:	6000eb5d 	.word	0x6000eb5d
60007f84:	6000eb2d 	.word	0x6000eb2d
60007f88:	6000eb7e 	.word	0x6000eb7e

60007f8c <z_bss_zero>:
 * @return N/A
 */
__boot_func
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
60007f8c:	4807      	ldr	r0, [pc, #28]	; (60007fac <z_bss_zero+0x20>)
60007f8e:	2100      	movs	r1, #0
60007f90:	4a07      	ldr	r2, [pc, #28]	; (60007fb0 <z_bss_zero+0x24>)
{
60007f92:	b508      	push	{r3, lr}
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
60007f94:	1a12      	subs	r2, r2, r0
60007f96:	f003 fd07 	bl	6000b9a8 <memset>
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_ccm), okay)
	(void)memset(&__ccm_bss_start, 0,
		     ((uint32_t) &__ccm_bss_end - (uint32_t) &__ccm_bss_start));
#endif
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_dtcm), okay)
	(void)memset(&__dtcm_bss_start, 0,
60007f9a:	4806      	ldr	r0, [pc, #24]	; (60007fb4 <z_bss_zero+0x28>)
60007f9c:	4a06      	ldr	r2, [pc, #24]	; (60007fb8 <z_bss_zero+0x2c>)
60007f9e:	2100      	movs	r1, #0
60007fa0:	1a12      	subs	r2, r2, r0
#endif	/* CONFIG_CODE_DATA_RELOCATION */
#ifdef CONFIG_COVERAGE_GCOV
	(void)memset(&__gcov_bss_start, 0,
		 ((uintptr_t) &__gcov_bss_end - (uintptr_t) &__gcov_bss_start));
#endif
}
60007fa2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memset(&__dtcm_bss_start, 0,
60007fa6:	f003 bcff 	b.w	6000b9a8 <memset>
60007faa:	bf00      	nop
60007fac:	800002a8 	.word	0x800002a8
60007fb0:	800010a0 	.word	0x800010a0
60007fb4:	20000000 	.word	0x20000000
60007fb8:	20000000 	.word	0x20000000

60007fbc <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
60007fbc:	2201      	movs	r2, #1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
60007fbe:	2002      	movs	r0, #2
{
60007fc0:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
60007fc2:	4b09      	ldr	r3, [pc, #36]	; (60007fe8 <bg_thread_main+0x2c>)
60007fc4:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
60007fc6:	f7ff febb 	bl	60007d40 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
60007fca:	f001 fb0d 	bl	600095e8 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
60007fce:	2003      	movs	r0, #3
60007fd0:	f7ff feb6 	bl	60007d40 <z_sys_init_run_level>

	z_init_static_threads();
60007fd4:	f000 fa30 	bl	60008438 <z_init_static_threads>
	z_sys_init_run_level(_SYS_INIT_LEVEL_SMP);
#endif

	extern void main(void);

	main();
60007fd8:	f7fa fb4e 	bl	60002678 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
60007fdc:	4a03      	ldr	r2, [pc, #12]	; (60007fec <bg_thread_main+0x30>)
60007fde:	7b13      	ldrb	r3, [r2, #12]
60007fe0:	f023 0301 	bic.w	r3, r3, #1
60007fe4:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
60007fe6:	bd08      	pop	{r3, pc}
60007fe8:	8000109c 	.word	0x8000109c
60007fec:	80000820 	.word	0x80000820

60007ff0 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
60007ff0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
60007ff4:	b0b9      	sub	sp, #228	; 0xe4
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
60007ff6:	f7fb f8cd 	bl	60003194 <log_core_init>
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
60007ffa:	4b3a      	ldr	r3, [pc, #232]	; (600080e4 <z_cstart+0xf4>)
60007ffc:	f383 8808 	msr	MSP, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
60008000:	2400      	movs	r4, #0
60008002:	4d39      	ldr	r5, [pc, #228]	; (600080e8 <z_cstart+0xf8>)
60008004:	23f0      	movs	r3, #240	; 0xf0
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
60008006:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
6000800a:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 600080ec <z_cstart+0xfc>
6000800e:	f04f 0a01 	mov.w	sl, #1
60008012:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	snprintk(tname, 8, "idle %02d", i);
60008016:	f10d 0b18 	add.w	fp, sp, #24
6000801a:	77ec      	strb	r4, [r5, #31]
6000801c:	762c      	strb	r4, [r5, #24]
6000801e:	766c      	strb	r4, [r5, #25]
60008020:	76ac      	strb	r4, [r5, #26]
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
60008022:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	z_setup_new_thread(thread, stack,
60008024:	4f32      	ldr	r7, [pc, #200]	; (600080f0 <z_cstart+0x100>)
60008026:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
6000802a:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
6000802c:	f7fe fc2e 	bl	6000688c <z_arm_fault_init>
	z_arm_cpu_idle_init();
60008030:	f7fe f8a2 	bl	60006178 <z_arm_cpu_idle_init>
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
60008034:	62ae      	str	r6, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
60008036:	62ee      	str	r6, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
60008038:	f7fe fd1a 	bl	60006a70 <z_arm_mpu_init>
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
6000803c:	4d2d      	ldr	r5, [pc, #180]	; (600080f4 <z_cstart+0x104>)
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
6000803e:	f7fe fc59 	bl	600068f4 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
60008042:	f240 1301 	movw	r3, #257	; 0x101
	dummy_thread->base.cpu_mask = -1;
60008046:	f88d 6034 	strb.w	r6, [sp, #52]	; 0x34
	dummy_thread->base.user_options = K_ESSENTIAL;
6000804a:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
	_current_cpu->current = dummy_thread;
6000804e:	ab08      	add	r3, sp, #32
	_kernel.ready_q.cache = &z_main_thread;
60008050:	4e29      	ldr	r6, [pc, #164]	; (600080f8 <z_cstart+0x108>)
60008052:	60ab      	str	r3, [r5, #8]
	dummy_thread->stack_info.size = 0U;
60008054:	e9cd 4431 	strd	r4, r4, [sp, #196]	; 0xc4
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
60008058:	f004 f84d 	bl	6000c0f6 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
6000805c:	4620      	mov	r0, r4
6000805e:	f7ff fe6f 	bl	60007d40 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
60008062:	2001      	movs	r0, #1
60008064:	f7ff fe6c 	bl	60007d40 <z_sys_init_run_level>
	z_sched_init();
60008068:	f000 fe84 	bl	60008d74 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
6000806c:	4b23      	ldr	r3, [pc, #140]	; (600080fc <z_cstart+0x10c>)
	_kernel.ready_q.cache = &z_main_thread;
6000806e:	622e      	str	r6, [r5, #32]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
60008070:	f44f 6280 	mov.w	r2, #1024	; 0x400
60008074:	4922      	ldr	r1, [pc, #136]	; (60008100 <z_cstart+0x110>)
60008076:	4630      	mov	r0, r6
60008078:	9305      	str	r3, [sp, #20]
6000807a:	464b      	mov	r3, r9
6000807c:	9400      	str	r4, [sp, #0]
6000807e:	e9cd 4a03 	strd	r4, sl, [sp, #12]
60008082:	e9cd 4401 	strd	r4, r4, [sp, #4]
60008086:	f000 f939 	bl	600082fc <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
6000808a:	7b73      	ldrb	r3, [r6, #13]
6000808c:	4680      	mov	r8, r0
	z_ready_thread(&z_main_thread);
6000808e:	4630      	mov	r0, r6
60008090:	f023 0304 	bic.w	r3, r3, #4
60008094:	7373      	strb	r3, [r6, #13]
60008096:	f004 f986 	bl	6000c3a6 <z_ready_thread>
	snprintk(tname, 8, "idle %02d", i);
6000809a:	4623      	mov	r3, r4
6000809c:	4a19      	ldr	r2, [pc, #100]	; (60008104 <z_cstart+0x114>)
6000809e:	2108      	movs	r1, #8
600080a0:	4658      	mov	r0, fp
600080a2:	f001 fc25 	bl	600098f0 <snprintk>
	z_setup_new_thread(thread, stack,
600080a6:	230f      	movs	r3, #15
600080a8:	f44f 72a0 	mov.w	r2, #320	; 0x140
600080ac:	4916      	ldr	r1, [pc, #88]	; (60008108 <z_cstart+0x118>)
600080ae:	4638      	mov	r0, r7
600080b0:	e9cd 4302 	strd	r4, r3, [sp, #8]
600080b4:	e9cd ab04 	strd	sl, fp, [sp, #16]
600080b8:	4b14      	ldr	r3, [pc, #80]	; (6000810c <z_cstart+0x11c>)
600080ba:	e9cd 5400 	strd	r5, r4, [sp]
600080be:	f000 f91d 	bl	600082fc <z_setup_new_thread>
600080c2:	7b7b      	ldrb	r3, [r7, #13]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
600080c4:	464a      	mov	r2, r9
600080c6:	4641      	mov	r1, r8
600080c8:	f023 0304 	bic.w	r3, r3, #4
600080cc:	4630      	mov	r0, r6
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
600080ce:	60ef      	str	r7, [r5, #12]
600080d0:	737b      	strb	r3, [r7, #13]
		_kernel.cpus[i].irq_stack =
600080d2:	4b04      	ldr	r3, [pc, #16]	; (600080e4 <z_cstart+0xf4>)
		_kernel.cpus[i].id = i;
600080d4:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
600080d6:	606b      	str	r3, [r5, #4]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
600080d8:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
600080dc:	e9c5 3306 	strd	r3, r3, [r5, #24]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
600080e0:	f7fe f830 	bl	60006144 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
600080e4:	80003a00 	.word	0x80003a00
600080e8:	e000ed00 	.word	0xe000ed00
600080ec:	60007fbd 	.word	0x60007fbd
600080f0:	80000760 	.word	0x80000760
600080f4:	80000ef4 	.word	0x80000ef4
600080f8:	80000820 	.word	0x80000820
600080fc:	6000ebe0 	.word	0x6000ebe0
60008100:	80002c60 	.word	0x80002c60
60008104:	6000ebe5 	.word	0x6000ebe5
60008108:	80003080 	.word	0x80003080
6000810c:	6000c221 	.word	0x6000c221

60008110 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
60008110:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
60008112:	4b0e      	ldr	r3, [pc, #56]	; (6000814c <init_mem_slab_module+0x3c>)
60008114:	4c0e      	ldr	r4, [pc, #56]	; (60008150 <init_mem_slab_module+0x40>)
60008116:	42a3      	cmp	r3, r4
60008118:	d301      	bcc.n	6000811e <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
6000811a:	2000      	movs	r0, #0
	return rc;
}
6000811c:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
6000811e:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
60008122:	ea41 0200 	orr.w	r2, r1, r0
60008126:	f012 0203 	ands.w	r2, r2, #3
6000812a:	d10b      	bne.n	60008144 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
6000812c:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
6000812e:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
60008130:	42aa      	cmp	r2, r5
60008132:	d101      	bne.n	60008138 <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
60008134:	331c      	adds	r3, #28
60008136:	e7ee      	b.n	60008116 <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
60008138:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
6000813a:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
6000813c:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
6000813e:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
60008140:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
60008142:	e7f5      	b.n	60008130 <init_mem_slab_module+0x20>
	return rc;
60008144:	f06f 0015 	mvn.w	r0, #21
60008148:	e7e8      	b.n	6000811c <init_mem_slab_module+0xc>
6000814a:	bf00      	nop
6000814c:	8000024c 	.word	0x8000024c
60008150:	8000024c 	.word	0x8000024c

60008154 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
60008154:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
60008158:	4604      	mov	r4, r0
6000815a:	460d      	mov	r5, r1
6000815c:	4617      	mov	r7, r2
6000815e:	461e      	mov	r6, r3
	__asm__ volatile(
60008160:	f04f 0310 	mov.w	r3, #16
60008164:	f3ef 8811 	mrs	r8, BASEPRI
60008168:	f383 8811 	msr	BASEPRI, r3
6000816c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);
60008170:	4601      	mov	r1, r0
60008172:	2055      	movs	r0, #85	; 0x55
60008174:	f7ff fb06 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>

	if (slab->free_list != NULL) {
60008178:	6963      	ldr	r3, [r4, #20]
6000817a:	b17b      	cbz	r3, 6000819c <k_mem_slab_alloc+0x48>
		/* take a free block */
		*mem = slab->free_list;
6000817c:	602b      	str	r3, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
6000817e:	681b      	ldr	r3, [r3, #0]
60008180:	6163      	str	r3, [r4, #20]
		slab->num_used++;
60008182:	69a3      	ldr	r3, [r4, #24]
60008184:	3301      	adds	r3, #1
60008186:	61a3      	str	r3, [r4, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
60008188:	2400      	movs	r4, #0
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

		return result;
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);
6000818a:	4621      	mov	r1, r4
6000818c:	2055      	movs	r0, #85	; 0x55
6000818e:	f7ff fc8b 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	__asm__ volatile(
60008192:	f388 8811 	msr	BASEPRI, r8
60008196:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&slab->lock, key);

	return result;
6000819a:	e018      	b.n	600081ce <k_mem_slab_alloc+0x7a>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
6000819c:	ea57 0206 	orrs.w	r2, r7, r6
600081a0:	d103      	bne.n	600081aa <k_mem_slab_alloc+0x56>
		result = -ENOMEM;
600081a2:	f06f 040b 	mvn.w	r4, #11
		*mem = NULL;
600081a6:	602b      	str	r3, [r5, #0]
		result = -ENOMEM;
600081a8:	e7ef      	b.n	6000818a <k_mem_slab_alloc+0x36>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
600081aa:	4622      	mov	r2, r4
600081ac:	f104 0008 	add.w	r0, r4, #8
600081b0:	4641      	mov	r1, r8
600081b2:	e9cd 7600 	strd	r7, r6, [sp]
600081b6:	f000 fcd9 	bl	60008b6c <z_pend_curr>
		if (result == 0) {
600081ba:	4604      	mov	r4, r0
600081bc:	b918      	cbnz	r0, 600081c6 <k_mem_slab_alloc+0x72>
			*mem = _current->base.swap_data;
600081be:	4b06      	ldr	r3, [pc, #24]	; (600081d8 <k_mem_slab_alloc+0x84>)
600081c0:	689b      	ldr	r3, [r3, #8]
600081c2:	699b      	ldr	r3, [r3, #24]
600081c4:	602b      	str	r3, [r5, #0]
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);
600081c6:	4621      	mov	r1, r4
600081c8:	2055      	movs	r0, #85	; 0x55
600081ca:	f7ff fc6d 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
}
600081ce:	4620      	mov	r0, r4
600081d0:	b002      	add	sp, #8
600081d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
600081d6:	bf00      	nop
600081d8:	80000ef4 	.word	0x80000ef4

600081dc <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	Z_STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
600081dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
600081de:	4605      	mov	r5, r0
600081e0:	460e      	mov	r6, r1
	__asm__ volatile(
600081e2:	f04f 0310 	mov.w	r3, #16
600081e6:	f3ef 8711 	mrs	r7, BASEPRI
600081ea:	f383 8811 	msr	BASEPRI, r3
600081ee:	f3bf 8f6f 	isb	sy
	 * The indirect ways are through calling k_thread_create and
	 * k_thread_abort from user_cb.
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);
600081f2:	206b      	movs	r0, #107	; 0x6b
600081f4:	f7ff fa8c 	bl	60007710 <SEGGER_SYSVIEW_RecordVoid>

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
600081f8:	4b07      	ldr	r3, [pc, #28]	; (60008218 <k_thread_foreach+0x3c>)
600081fa:	6adc      	ldr	r4, [r3, #44]	; 0x2c
600081fc:	b93c      	cbnz	r4, 6000820e <k_thread_foreach+0x32>
		user_cb(thread, user_data);
	}

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);
600081fe:	206b      	movs	r0, #107	; 0x6b
60008200:	f7ff fc30 	bl	60007a64 <SEGGER_SYSVIEW_RecordEndCall>
	__asm__ volatile(
60008204:	f387 8811 	msr	BASEPRI, r7
60008208:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
6000820c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		user_cb(thread, user_data);
6000820e:	4620      	mov	r0, r4
60008210:	4631      	mov	r1, r6
60008212:	47a8      	blx	r5
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
60008214:	6fe4      	ldr	r4, [r4, #124]	; 0x7c
60008216:	e7f1      	b.n	600081fc <k_thread_foreach+0x20>
60008218:	80000ef4 	.word	0x80000ef4

6000821c <z_thread_monitor_exit>:
	__asm__ volatile(
6000821c:	f04f 0310 	mov.w	r3, #16
60008220:	f3ef 8111 	mrs	r1, BASEPRI
60008224:	f383 8811 	msr	BASEPRI, r3
60008228:	f3bf 8f6f 	isb	sy
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
6000822c:	4a09      	ldr	r2, [pc, #36]	; (60008254 <z_thread_monitor_exit+0x38>)
6000822e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
60008230:	4283      	cmp	r3, r0
60008232:	d107      	bne.n	60008244 <z_thread_monitor_exit+0x28>
		_kernel.threads = _kernel.threads->next_thread;
60008234:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
60008236:	62d3      	str	r3, [r2, #44]	; 0x2c
	__asm__ volatile(
60008238:	f381 8811 	msr	BASEPRI, r1
6000823c:	f3bf 8f6f 	isb	sy
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
60008240:	4770      	bx	lr
60008242:	4613      	mov	r3, r2
		while ((prev_thread != NULL) &&
60008244:	2b00      	cmp	r3, #0
60008246:	d0f7      	beq.n	60008238 <z_thread_monitor_exit+0x1c>
			(thread != prev_thread->next_thread)) {
60008248:	6fda      	ldr	r2, [r3, #124]	; 0x7c
		while ((prev_thread != NULL) &&
6000824a:	4282      	cmp	r2, r0
6000824c:	d1f9      	bne.n	60008242 <z_thread_monitor_exit+0x26>
			prev_thread->next_thread = thread->next_thread;
6000824e:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
60008250:	67da      	str	r2, [r3, #124]	; 0x7c
60008252:	e7f1      	b.n	60008238 <z_thread_monitor_exit+0x1c>
60008254:	80000ef4 	.word	0x80000ef4

60008258 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
60008258:	b538      	push	{r3, r4, r5, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
6000825a:	4604      	mov	r4, r0
6000825c:	b908      	cbnz	r0, 60008262 <z_impl_k_thread_name_set+0xa>
		thread = _current;
6000825e:	4b09      	ldr	r3, [pc, #36]	; (60008284 <z_impl_k_thread_name_set+0x2c>)
60008260:	689c      	ldr	r4, [r3, #8]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
60008262:	2500      	movs	r5, #0
	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
60008264:	2220      	movs	r2, #32
60008266:	f104 0080 	add.w	r0, r4, #128	; 0x80
6000826a:	f003 fafd 	bl	6000b868 <strncpy>

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, 0);
6000826e:	4621      	mov	r1, r4
60008270:	209b      	movs	r0, #155	; 0x9b
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
60008272:	f884 509f 	strb.w	r5, [r4, #159]	; 0x9f
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, 0);
60008276:	f7ff fa61 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
6000827a:	4620      	mov	r0, r4
6000827c:	f003 fa8e 	bl	6000b79c <sys_trace_thread_info>

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
60008280:	4628      	mov	r0, r5
60008282:	bd38      	pop	{r3, r4, r5, pc}
60008284:	80000ef4 	.word	0x80000ef4

60008288 <k_thread_state_str>:
#endif /* CONFIG_THREAD_NAME */
}

const char *k_thread_state_str(k_tid_t thread_id)
{
	switch (thread_id->base.thread_state) {
60008288:	7b43      	ldrb	r3, [r0, #13]
6000828a:	2b10      	cmp	r3, #16
6000828c:	d80e      	bhi.n	600082ac <k_thread_state_str+0x24>
6000828e:	2b10      	cmp	r3, #16
60008290:	d81c      	bhi.n	600082cc <k_thread_state_str+0x44>
60008292:	e8df f003 	tbb	[pc, r3]
60008296:	091d      	.short	0x091d
60008298:	1b151b13 	.word	0x1b151b13
6000829c:	1b171b1b 	.word	0x1b171b1b
600082a0:	1b1b1b1b 	.word	0x1b1b1b1b
600082a4:	1b1b      	.short	0x1b1b
600082a6:	19          	.byte	0x19
600082a7:	00          	.byte	0x00
600082a8:	480b      	ldr	r0, [pc, #44]	; (600082d8 <k_thread_state_str+0x50>)
600082aa:	4770      	bx	lr
600082ac:	2b20      	cmp	r3, #32
600082ae:	d011      	beq.n	600082d4 <k_thread_state_str+0x4c>
		break;
	case _THREAD_ABORTING:
		return "aborting";
		break;
	case _THREAD_QUEUED:
		return "queued";
600082b0:	4a0a      	ldr	r2, [pc, #40]	; (600082dc <k_thread_state_str+0x54>)
600082b2:	480b      	ldr	r0, [pc, #44]	; (600082e0 <k_thread_state_str+0x58>)
600082b4:	2b80      	cmp	r3, #128	; 0x80
600082b6:	bf08      	it	eq
600082b8:	4610      	moveq	r0, r2
600082ba:	4770      	bx	lr
		return "pending";
600082bc:	4809      	ldr	r0, [pc, #36]	; (600082e4 <k_thread_state_str+0x5c>)
600082be:	4770      	bx	lr
		return "prestart";
600082c0:	4809      	ldr	r0, [pc, #36]	; (600082e8 <k_thread_state_str+0x60>)
600082c2:	4770      	bx	lr
		return "dead";
600082c4:	4809      	ldr	r0, [pc, #36]	; (600082ec <k_thread_state_str+0x64>)
600082c6:	4770      	bx	lr
		return "suspended";
600082c8:	4809      	ldr	r0, [pc, #36]	; (600082f0 <k_thread_state_str+0x68>)
600082ca:	4770      	bx	lr
		break;
	}
	return "unknown";
600082cc:	4804      	ldr	r0, [pc, #16]	; (600082e0 <k_thread_state_str+0x58>)
600082ce:	4770      	bx	lr
		return "";
600082d0:	4808      	ldr	r0, [pc, #32]	; (600082f4 <k_thread_state_str+0x6c>)
600082d2:	4770      	bx	lr
		return "aborting";
600082d4:	4808      	ldr	r0, [pc, #32]	; (600082f8 <k_thread_state_str+0x70>)
}
600082d6:	4770      	bx	lr
600082d8:	6000ec12 	.word	0x6000ec12
600082dc:	6000ec21 	.word	0x6000ec21
600082e0:	6000eb2d 	.word	0x6000eb2d
600082e4:	6000ebf2 	.word	0x6000ebf2
600082e8:	6000ebfa 	.word	0x6000ebfa
600082ec:	6000ec03 	.word	0x6000ec03
600082f0:	6000ec08 	.word	0x6000ec08
600082f4:	6000dc95 	.word	0x6000dc95
600082f8:	6000ec18 	.word	0x6000ec18

600082fc <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
600082fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60008300:	4698      	mov	r8, r3
60008302:	b085      	sub	sp, #20
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
60008304:	f100 0360 	add.w	r3, r0, #96	; 0x60
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
60008308:	3207      	adds	r2, #7

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
6000830a:	2500      	movs	r5, #0

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
6000830c:	f101 0b20 	add.w	fp, r1, #32
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
60008310:	f022 0a07 	bic.w	sl, r2, #7
{
60008314:	4604      	mov	r4, r0
60008316:	460e      	mov	r6, r1
	thread_base->pended_on = NULL;
60008318:	6085      	str	r5, [r0, #8]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
6000831a:	f10a 0720 	add.w	r7, sl, #32
	memset(stack_buf_start, 0xaa, stack_buf_size);
6000831e:	4652      	mov	r2, sl
	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
60008320:	73c5      	strb	r5, [r0, #15]
	stack_ptr = (char *)stack + stack_obj_size;
60008322:	440f      	add	r7, r1
	memset(stack_buf_start, 0xaa, stack_buf_size);
60008324:	21aa      	movs	r1, #170	; 0xaa
{
60008326:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
6000832a:	e9c0 3318 	strd	r3, r3, [r0, #96]	; 0x60
	thread_base->user_options = (uint8_t)options;
6000832e:	9b12      	ldr	r3, [sp, #72]	; 0x48
60008330:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
60008332:	2304      	movs	r3, #4
60008334:	7343      	strb	r3, [r0, #13]
	thread_base->prio = priority;
60008336:	9b11      	ldr	r3, [sp, #68]	; 0x44
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
60008338:	e9c0 5508 	strd	r5, r5, [r0, #32]
6000833c:	7383      	strb	r3, [r0, #14]
	memset(stack_buf_start, 0xaa, stack_buf_size);
6000833e:	4658      	mov	r0, fp
60008340:	f003 fb32 	bl	6000b9a8 <memset>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
60008344:	9b10      	ldr	r3, [sp, #64]	; 0x40
60008346:	463a      	mov	r2, r7
60008348:	4631      	mov	r1, r6
6000834a:	9302      	str	r3, [sp, #8]
6000834c:	4620      	mov	r0, r4
6000834e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	new_thread->stack_info.delta = delta;
60008350:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
60008354:	9301      	str	r3, [sp, #4]
60008356:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	new_thread->stack_info.size = stack_buf_size;
60008358:	e9c4 ba29 	strd	fp, sl, [r4, #164]	; 0xa4
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
6000835c:	9300      	str	r3, [sp, #0]
6000835e:	4643      	mov	r3, r8
60008360:	f7fd fec0 	bl	600060e4 <arch_new_thread>
	new_thread->entry.parameter1 = p1;
60008364:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	new_thread->init_data = NULL;
60008366:	65e5      	str	r5, [r4, #92]	; 0x5c
	new_thread->entry.parameter1 = p1;
60008368:	6723      	str	r3, [r4, #112]	; 0x70
	new_thread->entry.parameter2 = p2;
6000836a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	new_thread->entry.pEntry = entry;
6000836c:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
	new_thread->entry.parameter2 = p2;
60008370:	6763      	str	r3, [r4, #116]	; 0x74
	new_thread->entry.parameter3 = p3;
60008372:	9b10      	ldr	r3, [sp, #64]	; 0x40
60008374:	67a3      	str	r3, [r4, #120]	; 0x78
	__asm__ volatile(
60008376:	f04f 0210 	mov.w	r2, #16
6000837a:	f3ef 8311 	mrs	r3, BASEPRI
6000837e:	f382 8811 	msr	BASEPRI, r2
60008382:	f3bf 8f6f 	isb	sy
	new_thread->next_thread = _kernel.threads;
60008386:	4e15      	ldr	r6, [pc, #84]	; (600083dc <z_setup_new_thread+0xe0>)
60008388:	6af2      	ldr	r2, [r6, #44]	; 0x2c
	_kernel.threads = new_thread;
6000838a:	62f4      	str	r4, [r6, #44]	; 0x2c
	new_thread->next_thread = _kernel.threads;
6000838c:	67e2      	str	r2, [r4, #124]	; 0x7c
	__asm__ volatile(
6000838e:	f383 8811 	msr	BASEPRI, r3
60008392:	f3bf 8f6f 	isb	sy
	if (name != NULL) {
60008396:	f1b9 0f00 	cmp.w	r9, #0
6000839a:	d011      	beq.n	600083c0 <z_setup_new_thread+0xc4>
		strncpy(new_thread->name, name,
6000839c:	221f      	movs	r2, #31
6000839e:	4649      	mov	r1, r9
600083a0:	f104 0080 	add.w	r0, r4, #128	; 0x80
600083a4:	f003 fa60 	bl	6000b868 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
600083a8:	f884 509f 	strb.w	r5, [r4, #159]	; 0x9f
	new_thread->base.cpu_mask = -1;
600083ac:	23ff      	movs	r3, #255	; 0xff
600083ae:	7523      	strb	r3, [r4, #20]
	if (!_current) {
600083b0:	68b3      	ldr	r3, [r6, #8]
600083b2:	b943      	cbnz	r3, 600083c6 <z_setup_new_thread+0xca>
		new_thread->resource_pool = NULL;
600083b4:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
}
600083b8:	4638      	mov	r0, r7
600083ba:	b005      	add	sp, #20
600083bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		new_thread->name[0] = '\0';
600083c0:	f884 9080 	strb.w	r9, [r4, #128]	; 0x80
600083c4:	e7f2      	b.n	600083ac <z_setup_new_thread+0xb0>
	new_thread->resource_pool = _current->resource_pool;
600083c6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);
600083ca:	4620      	mov	r0, r4
	new_thread->resource_pool = _current->resource_pool;
600083cc:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);
600083d0:	f7ff fbb0 	bl	60007b34 <SEGGER_SYSVIEW_OnTaskCreate>
600083d4:	4620      	mov	r0, r4
600083d6:	f003 f9e1 	bl	6000b79c <sys_trace_thread_info>
	return stack_ptr;
600083da:	e7ed      	b.n	600083b8 <z_setup_new_thread+0xbc>
600083dc:	80000ef4 	.word	0x80000ef4

600083e0 <z_impl_k_thread_create>:
{
600083e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
600083e2:	2700      	movs	r7, #0
{
600083e4:	b087      	sub	sp, #28
600083e6:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
600083e8:	9705      	str	r7, [sp, #20]
600083ea:	9f10      	ldr	r7, [sp, #64]	; 0x40
600083ec:	9704      	str	r7, [sp, #16]
600083ee:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
600083f0:	9703      	str	r7, [sp, #12]
600083f2:	9f0e      	ldr	r7, [sp, #56]	; 0x38
600083f4:	9702      	str	r7, [sp, #8]
600083f6:	9f0d      	ldr	r7, [sp, #52]	; 0x34
600083f8:	9701      	str	r7, [sp, #4]
600083fa:	9f0c      	ldr	r7, [sp, #48]	; 0x30
{
600083fc:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
60008400:	9700      	str	r7, [sp, #0]
60008402:	f7ff ff7b 	bl	600082fc <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
60008406:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
6000840a:	bf08      	it	eq
6000840c:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
60008410:	d005      	beq.n	6000841e <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
60008412:	ea55 0306 	orrs.w	r3, r5, r6
60008416:	d105      	bne.n	60008424 <z_impl_k_thread_create+0x44>
	z_impl_k_thread_start(thread);
60008418:	4620      	mov	r0, r4
6000841a:	f003 fee4 	bl	6000c1e6 <z_impl_k_thread_start>
}
6000841e:	4620      	mov	r0, r4
60008420:	b007      	add	sp, #28
60008422:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
60008424:	4632      	mov	r2, r6
60008426:	462b      	mov	r3, r5
60008428:	4902      	ldr	r1, [pc, #8]	; (60008434 <z_impl_k_thread_create+0x54>)
6000842a:	f104 0020 	add.w	r0, r4, #32
6000842e:	f000 fec1 	bl	600091b4 <z_add_timeout>
60008432:	e7f4      	b.n	6000841e <z_impl_k_thread_create+0x3e>
60008434:	6000c363 	.word	0x6000c363

60008438 <z_init_static_threads>:
{
60008438:	b5f0      	push	{r4, r5, r6, r7, lr}
6000843a:	4c21      	ldr	r4, [pc, #132]	; (600084c0 <z_init_static_threads+0x88>)
6000843c:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
6000843e:	4d21      	ldr	r5, [pc, #132]	; (600084c4 <z_init_static_threads+0x8c>)
60008440:	4626      	mov	r6, r4
60008442:	3430      	adds	r4, #48	; 0x30
60008444:	42ae      	cmp	r6, r5
60008446:	d30b      	bcc.n	60008460 <z_init_static_threads+0x28>
	_FOREACH_STATIC_THREAD(thread_data) {
60008448:	4c1d      	ldr	r4, [pc, #116]	; (600084c0 <z_init_static_threads+0x88>)
			return t * (to_hz / from_hz);
6000844a:	260a      	movs	r6, #10
6000844c:	4f1e      	ldr	r7, [pc, #120]	; (600084c8 <z_init_static_threads+0x90>)
	k_sched_lock();
6000844e:	f000 fc61 	bl	60008d14 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
60008452:	42ac      	cmp	r4, r5
60008454:	d320      	bcc.n	60008498 <z_init_static_threads+0x60>
}
60008456:	b007      	add	sp, #28
60008458:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
6000845c:	f000 bc6e 	b.w	60008d3c <k_sched_unlock>
		z_setup_new_thread(
60008460:	f854 3c04 	ldr.w	r3, [r4, #-4]
60008464:	9305      	str	r3, [sp, #20]
60008466:	f854 3c10 	ldr.w	r3, [r4, #-16]
6000846a:	9304      	str	r3, [sp, #16]
6000846c:	f854 3c14 	ldr.w	r3, [r4, #-20]
60008470:	9303      	str	r3, [sp, #12]
60008472:	f854 3c18 	ldr.w	r3, [r4, #-24]
60008476:	9302      	str	r3, [sp, #8]
60008478:	f854 3c1c 	ldr.w	r3, [r4, #-28]
6000847c:	9301      	str	r3, [sp, #4]
6000847e:	f854 3c20 	ldr.w	r3, [r4, #-32]
60008482:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
60008486:	9300      	str	r3, [sp, #0]
60008488:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
6000848c:	f7ff ff36 	bl	600082fc <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
60008490:	f854 3c30 	ldr.w	r3, [r4, #-48]
60008494:	65de      	str	r6, [r3, #92]	; 0x5c
	_FOREACH_STATIC_THREAD(thread_data) {
60008496:	e7d3      	b.n	60008440 <z_init_static_threads+0x8>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
60008498:	6a62      	ldr	r2, [r4, #36]	; 0x24
6000849a:	1c53      	adds	r3, r2, #1
6000849c:	d009      	beq.n	600084b2 <z_init_static_threads+0x7a>
					    K_MSEC(thread_data->init_delay));
6000849e:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
			schedule_new_thread(thread_data->init_thread,
600084a2:	6820      	ldr	r0, [r4, #0]
600084a4:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
600084a8:	ea52 0103 	orrs.w	r1, r2, r3
600084ac:	d103      	bne.n	600084b6 <z_init_static_threads+0x7e>
600084ae:	f003 fe9a 	bl	6000c1e6 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
600084b2:	3430      	adds	r4, #48	; 0x30
600084b4:	e7cd      	b.n	60008452 <z_init_static_threads+0x1a>
600084b6:	4639      	mov	r1, r7
600084b8:	3020      	adds	r0, #32
600084ba:	f000 fe7b 	bl	600091b4 <z_add_timeout>
600084be:	e7f8      	b.n	600084b2 <z_init_static_threads+0x7a>
600084c0:	8000024c 	.word	0x8000024c
600084c4:	8000024c 	.word	0x8000024c
600084c8:	6000c363 	.word	0x6000c363

600084cc <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
600084cc:	4800      	ldr	r0, [pc, #0]	; (600084d0 <sys_kernel_version_get+0x4>)
600084ce:	4770      	bx	lr
600084d0:	02060000 	.word	0x02060000

600084d4 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
600084d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
600084d8:	4604      	mov	r4, r0
600084da:	460e      	mov	r6, r1

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
600084dc:	f100 0808 	add.w	r8, r0, #8
	__asm__ volatile(
600084e0:	f04f 0110 	mov.w	r1, #16
600084e4:	f3ef 8711 	mrs	r7, BASEPRI
600084e8:	f381 8811 	msr	BASEPRI, r1
600084ec:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
600084f0:	6a05      	ldr	r5, [r0, #32]
600084f2:	68c1      	ldr	r1, [r0, #12]
600084f4:	428d      	cmp	r5, r1
600084f6:	d230      	bcs.n	6000855a <z_impl_k_msgq_put+0x86>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
600084f8:	f003 ffba 	bl	6000c470 <z_unpend_first_thread>
		if (pending_thread != NULL) {
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
600084fc:	68a2      	ldr	r2, [r4, #8]
		if (pending_thread != NULL) {
600084fe:	4605      	mov	r5, r0
			(void)memcpy(pending_thread->base.swap_data, data,
60008500:	4631      	mov	r1, r6
		if (pending_thread != NULL) {
60008502:	b180      	cbz	r0, 60008526 <z_impl_k_msgq_put+0x52>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
60008504:	2400      	movs	r4, #0
			(void)memcpy(pending_thread->base.swap_data, data,
60008506:	6980      	ldr	r0, [r0, #24]
60008508:	f003 fa23 	bl	6000b952 <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
6000850c:	4628      	mov	r0, r5
6000850e:	f8c5 40b8 	str.w	r4, [r5, #184]	; 0xb8
60008512:	f003 ff48 	bl	6000c3a6 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
60008516:	4640      	mov	r0, r8
60008518:	4639      	mov	r1, r7
6000851a:	f000 fb8f 	bl	60008c3c <z_reschedule>
			return 0;
6000851e:	4620      	mov	r0, r4
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
60008520:	b002      	add	sp, #8
60008522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
60008526:	69e0      	ldr	r0, [r4, #28]
60008528:	f003 fa13 	bl	6000b952 <memcpy>
			msgq->write_ptr += msgq->msg_size;
6000852c:	69e3      	ldr	r3, [r4, #28]
6000852e:	68a2      	ldr	r2, [r4, #8]
	z_handle_obj_poll_events(&msgq->poll_events, state);
60008530:	f104 0024 	add.w	r0, r4, #36	; 0x24
60008534:	2110      	movs	r1, #16
			msgq->write_ptr += msgq->msg_size;
60008536:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
60008538:	6962      	ldr	r2, [r4, #20]
6000853a:	4293      	cmp	r3, r2
			msgq->write_ptr += msgq->msg_size;
6000853c:	61e3      	str	r3, [r4, #28]
				msgq->write_ptr = msgq->buffer_start;
6000853e:	bf04      	itt	eq
60008540:	6923      	ldreq	r3, [r4, #16]
60008542:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
60008544:	6a23      	ldr	r3, [r4, #32]
60008546:	3301      	adds	r3, #1
60008548:	6223      	str	r3, [r4, #32]
	z_handle_obj_poll_events(&msgq->poll_events, state);
6000854a:	f004 f983 	bl	6000c854 <z_handle_obj_poll_events>
		result = 0;
6000854e:	2000      	movs	r0, #0
	__asm__ volatile(
60008550:	f387 8811 	msr	BASEPRI, r7
60008554:	f3bf 8f6f 	isb	sy
	return result;
60008558:	e7e2      	b.n	60008520 <z_impl_k_msgq_put+0x4c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
6000855a:	ea52 0103 	orrs.w	r1, r2, r3
6000855e:	d00a      	beq.n	60008576 <z_impl_k_msgq_put+0xa2>
		_current->base.swap_data = (void *) data;
60008560:	4906      	ldr	r1, [pc, #24]	; (6000857c <z_impl_k_msgq_put+0xa8>)
60008562:	6889      	ldr	r1, [r1, #8]
60008564:	618e      	str	r6, [r1, #24]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
60008566:	4639      	mov	r1, r7
60008568:	e9cd 2300 	strd	r2, r3, [sp]
6000856c:	4602      	mov	r2, r0
6000856e:	4640      	mov	r0, r8
60008570:	f000 fafc 	bl	60008b6c <z_pend_curr>
		return result;
60008574:	e7d4      	b.n	60008520 <z_impl_k_msgq_put+0x4c>
		result = -ENOMSG;
60008576:	f06f 0022 	mvn.w	r0, #34	; 0x22
6000857a:	e7e9      	b.n	60008550 <z_impl_k_msgq_put+0x7c>
6000857c:	80000ef4 	.word	0x80000ef4

60008580 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
60008580:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
60008582:	4604      	mov	r4, r0
60008584:	4608      	mov	r0, r1

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
60008586:	f104 0708 	add.w	r7, r4, #8
	__asm__ volatile(
6000858a:	f04f 0110 	mov.w	r1, #16
6000858e:	f3ef 8611 	mrs	r6, BASEPRI
60008592:	f381 8811 	msr	BASEPRI, r1
60008596:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
6000859a:	6a21      	ldr	r1, [r4, #32]
6000859c:	2900      	cmp	r1, #0
6000859e:	d032      	beq.n	60008606 <z_impl_k_msgq_get+0x86>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
600085a0:	68a2      	ldr	r2, [r4, #8]
600085a2:	69a1      	ldr	r1, [r4, #24]
600085a4:	f003 f9d5 	bl	6000b952 <memcpy>
		msgq->read_ptr += msgq->msg_size;
600085a8:	69a3      	ldr	r3, [r4, #24]
600085aa:	68a2      	ldr	r2, [r4, #8]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
600085ac:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
600085ae:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
600085b0:	6962      	ldr	r2, [r4, #20]
600085b2:	4293      	cmp	r3, r2
		msgq->read_ptr += msgq->msg_size;
600085b4:	61a3      	str	r3, [r4, #24]
			msgq->read_ptr = msgq->buffer_start;
600085b6:	bf04      	itt	eq
600085b8:	6923      	ldreq	r3, [r4, #16]
600085ba:	61a3      	streq	r3, [r4, #24]
		msgq->used_msgs--;
600085bc:	6a23      	ldr	r3, [r4, #32]
600085be:	3b01      	subs	r3, #1
600085c0:	6223      	str	r3, [r4, #32]
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
600085c2:	f003 ff55 	bl	6000c470 <z_unpend_first_thread>
		if (pending_thread != NULL) {
600085c6:	4605      	mov	r5, r0
600085c8:	b368      	cbz	r0, 60008626 <z_impl_k_msgq_get+0xa6>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
600085ca:	6981      	ldr	r1, [r0, #24]
600085cc:	68a2      	ldr	r2, [r4, #8]
600085ce:	69e0      	ldr	r0, [r4, #28]
600085d0:	f003 f9bf 	bl	6000b952 <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
600085d4:	69e3      	ldr	r3, [r4, #28]
600085d6:	68a2      	ldr	r2, [r4, #8]
			}
			msgq->used_msgs++;

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
600085d8:	4628      	mov	r0, r5
			msgq->write_ptr += msgq->msg_size;
600085da:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
600085dc:	6962      	ldr	r2, [r4, #20]
600085de:	4293      	cmp	r3, r2
			msgq->write_ptr += msgq->msg_size;
600085e0:	61e3      	str	r3, [r4, #28]
				msgq->write_ptr = msgq->buffer_start;
600085e2:	bf04      	itt	eq
600085e4:	6923      	ldreq	r3, [r4, #16]
600085e6:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
600085e8:	6a23      	ldr	r3, [r4, #32]
600085ea:	3301      	adds	r3, #1
600085ec:	6223      	str	r3, [r4, #32]
600085ee:	2400      	movs	r4, #0
600085f0:	f8c5 40b8 	str.w	r4, [r5, #184]	; 0xb8
			z_ready_thread(pending_thread);
600085f4:	f003 fed7 	bl	6000c3a6 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
600085f8:	4638      	mov	r0, r7
600085fa:	4631      	mov	r1, r6
600085fc:	f000 fb1e 	bl	60008c3c <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
60008600:	4620      	mov	r0, r4
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
60008602:	b003      	add	sp, #12
60008604:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
60008606:	ea52 0103 	orrs.w	r1, r2, r3
6000860a:	d00a      	beq.n	60008622 <z_impl_k_msgq_get+0xa2>
		_current->base.swap_data = data;
6000860c:	4908      	ldr	r1, [pc, #32]	; (60008630 <z_impl_k_msgq_get+0xb0>)
6000860e:	6889      	ldr	r1, [r1, #8]
60008610:	6188      	str	r0, [r1, #24]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
60008612:	4631      	mov	r1, r6
60008614:	4638      	mov	r0, r7
60008616:	e9cd 2300 	strd	r2, r3, [sp]
6000861a:	4622      	mov	r2, r4
6000861c:	f000 faa6 	bl	60008b6c <z_pend_curr>
		return result;
60008620:	e7ef      	b.n	60008602 <z_impl_k_msgq_get+0x82>
		result = -ENOMSG;
60008622:	f06f 0022 	mvn.w	r0, #34	; 0x22
	__asm__ volatile(
60008626:	f386 8811 	msr	BASEPRI, r6
6000862a:	f3bf 8f6f 	isb	sy
	return result;
6000862e:	e7e8      	b.n	60008602 <z_impl_k_msgq_get+0x82>
60008630:	80000ef4 	.word	0x80000ef4

60008634 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
60008634:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);
60008638:	4601      	mov	r1, r0
{
6000863a:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);
6000863c:	2027      	movs	r0, #39	; 0x27
{
6000863e:	4617      	mov	r7, r2
60008640:	461d      	mov	r5, r3
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);
60008642:	f7ff f89f 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>
	__asm__ volatile(
60008646:	f04f 0310 	mov.w	r3, #16
6000864a:	f3ef 8811 	mrs	r8, BASEPRI
6000864e:	f383 8811 	msr	BASEPRI, r3
60008652:	f3bf 8f6f 	isb	sy

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
60008656:	68e3      	ldr	r3, [r4, #12]
60008658:	4a39      	ldr	r2, [pc, #228]	; (60008740 <z_impl_k_mutex_lock+0x10c>)
6000865a:	b193      	cbz	r3, 60008682 <z_impl_k_mutex_lock+0x4e>
6000865c:	68a0      	ldr	r0, [r4, #8]
6000865e:	6891      	ldr	r1, [r2, #8]
60008660:	4288      	cmp	r0, r1
60008662:	d023      	beq.n	600086ac <z_impl_k_mutex_lock+0x78>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
60008664:	ea57 0305 	orrs.w	r3, r7, r5
60008668:	d122      	bne.n	600086b0 <z_impl_k_mutex_lock+0x7c>
	__asm__ volatile(
6000866a:	f388 8811 	msr	BASEPRI, r8
6000866e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);
60008672:	f06f 010f 	mvn.w	r1, #15
60008676:	2027      	movs	r0, #39	; 0x27

		return -EBUSY;
60008678:	f06f 050f 	mvn.w	r5, #15
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);
6000867c:	f7ff fa14 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
		return -EBUSY;
60008680:	e010      	b.n	600086a4 <z_impl_k_mutex_lock+0x70>
					_current->base.prio :
60008682:	6891      	ldr	r1, [r2, #8]
60008684:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
60008688:	3301      	adds	r3, #1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
6000868a:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
6000868c:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
6000868e:	6893      	ldr	r3, [r2, #8]
60008690:	60a3      	str	r3, [r4, #8]
60008692:	f388 8811 	msr	BASEPRI, r8
60008696:	f3bf 8f6f 	isb	sy
		return 0;
6000869a:	2500      	movs	r5, #0
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);
6000869c:	2100      	movs	r1, #0
6000869e:	2027      	movs	r0, #39	; 0x27
600086a0:	f7ff fa02 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
600086a4:	4628      	mov	r0, r5
600086a6:	b002      	add	sp, #8
600086a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
600086ac:	6921      	ldr	r1, [r4, #16]
600086ae:	e7eb      	b.n	60008688 <z_impl_k_mutex_lock+0x54>
	new_prio = new_prio_for_inheritance(_current->base.prio,
600086b0:	f990 300e 	ldrsb.w	r3, [r0, #14]
600086b4:	f991 100e 	ldrsb.w	r1, [r1, #14]
600086b8:	4299      	cmp	r1, r3
600086ba:	bfa8      	it	ge
600086bc:	4619      	movge	r1, r3
600086be:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
600086c2:	428b      	cmp	r3, r1
600086c4:	dd10      	ble.n	600086e8 <z_impl_k_mutex_lock+0xb4>
		resched = adjust_owner_prio(mutex, new_prio);
600086c6:	f003 fdd1 	bl	6000c26c <adjust_owner_prio.isra.0>
600086ca:	4606      	mov	r6, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
600086cc:	4622      	mov	r2, r4
600086ce:	4641      	mov	r1, r8
600086d0:	481c      	ldr	r0, [pc, #112]	; (60008744 <z_impl_k_mutex_lock+0x110>)
600086d2:	e9cd 7500 	strd	r7, r5, [sp]
600086d6:	f000 fa49 	bl	60008b6c <z_pend_curr>
	if (got_mutex == 0) {
600086da:	4605      	mov	r5, r0
600086dc:	b930      	cbnz	r0, 600086ec <z_impl_k_mutex_lock+0xb8>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);
600086de:	4601      	mov	r1, r0
600086e0:	2027      	movs	r0, #39	; 0x27
600086e2:	f7ff f9e1 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
		return 0;
600086e6:	e7dd      	b.n	600086a4 <z_impl_k_mutex_lock+0x70>
	bool resched = false;
600086e8:	2600      	movs	r6, #0
600086ea:	e7ef      	b.n	600086cc <z_impl_k_mutex_lock+0x98>
	__asm__ volatile(
600086ec:	f04f 0310 	mov.w	r3, #16
600086f0:	f3ef 8511 	mrs	r5, BASEPRI
600086f4:	f383 8811 	msr	BASEPRI, r3
600086f8:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
600086fc:	6823      	ldr	r3, [r4, #0]
600086fe:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
60008700:	429c      	cmp	r4, r3
60008702:	d007      	beq.n	60008714 <z_impl_k_mutex_lock+0xe0>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
60008704:	b133      	cbz	r3, 60008714 <z_impl_k_mutex_lock+0xe0>
60008706:	f993 300e 	ldrsb.w	r3, [r3, #14]
6000870a:	4299      	cmp	r1, r3
6000870c:	bfa8      	it	ge
6000870e:	4619      	movge	r1, r3
60008710:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
60008714:	68a0      	ldr	r0, [r4, #8]
60008716:	f003 fda9 	bl	6000c26c <adjust_owner_prio.isra.0>
6000871a:	b900      	cbnz	r0, 6000871e <z_impl_k_mutex_lock+0xea>
	if (resched) {
6000871c:	b15e      	cbz	r6, 60008736 <z_impl_k_mutex_lock+0x102>
		z_reschedule(&lock, key);
6000871e:	4629      	mov	r1, r5
60008720:	4808      	ldr	r0, [pc, #32]	; (60008744 <z_impl_k_mutex_lock+0x110>)
60008722:	f000 fa8b 	bl	60008c3c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);
60008726:	f06f 010a 	mvn.w	r1, #10
6000872a:	2027      	movs	r0, #39	; 0x27
	return -EAGAIN;
6000872c:	f06f 050a 	mvn.w	r5, #10
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);
60008730:	f7ff f9ba 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	return -EAGAIN;
60008734:	e7b6      	b.n	600086a4 <z_impl_k_mutex_lock+0x70>
	__asm__ volatile(
60008736:	f385 8811 	msr	BASEPRI, r5
6000873a:	f3bf 8f6f 	isb	sy
6000873e:	e7f2      	b.n	60008726 <z_impl_k_mutex_lock+0xf2>
60008740:	80000ef4 	.word	0x80000ef4
60008744:	8000109d 	.word	0x8000109d

60008748 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
60008748:	b538      	push	{r3, r4, r5, lr}
6000874a:	4604      	mov	r4, r0
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);
6000874c:	4601      	mov	r1, r0
6000874e:	2026      	movs	r0, #38	; 0x26
60008750:	f7fe fff4 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>

	CHECKIF(mutex->owner == NULL) {
60008754:	68a3      	ldr	r3, [r4, #8]
60008756:	b93b      	cbnz	r3, 60008768 <z_impl_k_mutex_unlock+0x20>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);
60008758:	2026      	movs	r0, #38	; 0x26
6000875a:	f06f 0115 	mvn.w	r1, #21
6000875e:	f7ff f9a3 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>

		return -EINVAL;
60008762:	f06f 0015 	mvn.w	r0, #21
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();

	return 0;
}
60008766:	bd38      	pop	{r3, r4, r5, pc}
	CHECKIF(mutex->owner != _current) {
60008768:	4a1f      	ldr	r2, [pc, #124]	; (600087e8 <z_impl_k_mutex_unlock+0xa0>)
6000876a:	6892      	ldr	r2, [r2, #8]
6000876c:	4293      	cmp	r3, r2
6000876e:	d007      	beq.n	60008780 <z_impl_k_mutex_unlock+0x38>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);
60008770:	2026      	movs	r0, #38	; 0x26
60008772:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
60008776:	f7ff f997 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
		return -EPERM;
6000877a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
6000877e:	e7f2      	b.n	60008766 <z_impl_k_mutex_unlock+0x1e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
60008780:	7bda      	ldrb	r2, [r3, #15]
60008782:	3a01      	subs	r2, #1
60008784:	73da      	strb	r2, [r3, #15]
	if (mutex->lock_count - 1U != 0U) {
60008786:	68e3      	ldr	r3, [r4, #12]
60008788:	2b01      	cmp	r3, #1
6000878a:	d009      	beq.n	600087a0 <z_impl_k_mutex_unlock+0x58>
		mutex->lock_count--;
6000878c:	3b01      	subs	r3, #1
6000878e:	60e3      	str	r3, [r4, #12]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);
60008790:	2026      	movs	r0, #38	; 0x26
60008792:	2100      	movs	r1, #0
60008794:	f7ff f988 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	k_sched_unlock();
60008798:	f000 fad0 	bl	60008d3c <k_sched_unlock>
	return 0;
6000879c:	2000      	movs	r0, #0
6000879e:	e7e2      	b.n	60008766 <z_impl_k_mutex_unlock+0x1e>
	__asm__ volatile(
600087a0:	f04f 0310 	mov.w	r3, #16
600087a4:	f3ef 8511 	mrs	r5, BASEPRI
600087a8:	f383 8811 	msr	BASEPRI, r3
600087ac:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
600087b0:	6921      	ldr	r1, [r4, #16]
600087b2:	68a0      	ldr	r0, [r4, #8]
600087b4:	f003 fd5a 	bl	6000c26c <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
600087b8:	4620      	mov	r0, r4
600087ba:	f003 fe59 	bl	6000c470 <z_unpend_first_thread>
	mutex->owner = new_owner;
600087be:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
600087c0:	b160      	cbz	r0, 600087dc <z_impl_k_mutex_unlock+0x94>
		mutex->owner_orig_prio = new_owner->base.prio;
600087c2:	f990 200e 	ldrsb.w	r2, [r0, #14]
600087c6:	6122      	str	r2, [r4, #16]
600087c8:	2200      	movs	r2, #0
600087ca:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
		z_ready_thread(new_owner);
600087ce:	f003 fdea 	bl	6000c3a6 <z_ready_thread>
		z_reschedule(&lock, key);
600087d2:	4629      	mov	r1, r5
600087d4:	4805      	ldr	r0, [pc, #20]	; (600087ec <z_impl_k_mutex_unlock+0xa4>)
600087d6:	f000 fa31 	bl	60008c3c <z_reschedule>
600087da:	e7d9      	b.n	60008790 <z_impl_k_mutex_unlock+0x48>
		mutex->lock_count = 0U;
600087dc:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
600087de:	f385 8811 	msr	BASEPRI, r5
600087e2:	f3bf 8f6f 	isb	sy
600087e6:	e7d3      	b.n	60008790 <z_impl_k_mutex_unlock+0x48>
600087e8:	80000ef4 	.word	0x80000ef4
600087ec:	8000109d 	.word	0x8000109d

600087f0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
600087f0:	b538      	push	{r3, r4, r5, lr}
600087f2:	4604      	mov	r4, r0
	__asm__ volatile(
600087f4:	f04f 0310 	mov.w	r3, #16
600087f8:	f3ef 8511 	mrs	r5, BASEPRI
600087fc:	f383 8811 	msr	BASEPRI, r3
60008800:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);
60008804:	4601      	mov	r1, r0
60008806:	2029      	movs	r0, #41	; 0x29
60008808:	f7fe ff98 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>

	thread = z_unpend_first_thread(&sem->wait_q);
6000880c:	4620      	mov	r0, r4
6000880e:	f003 fe2f 	bl	6000c470 <z_unpend_first_thread>

	if (thread != NULL) {
60008812:	b168      	cbz	r0, 60008830 <z_impl_k_sem_give+0x40>
60008814:	2200      	movs	r2, #0
60008816:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
6000881a:	f003 fdc4 	bl	6000c3a6 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
6000881e:	4629      	mov	r1, r5
60008820:	4809      	ldr	r0, [pc, #36]	; (60008848 <z_impl_k_sem_give+0x58>)
60008822:	f000 fa0b 	bl	60008c3c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
60008826:	2029      	movs	r0, #41	; 0x29
}
60008828:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
6000882c:	f7ff b91a 	b.w	60007a64 <SEGGER_SYSVIEW_RecordEndCall>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
60008830:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
60008834:	2102      	movs	r1, #2
60008836:	f104 0010 	add.w	r0, r4, #16
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
6000883a:	429a      	cmp	r2, r3
6000883c:	bf18      	it	ne
6000883e:	3301      	addne	r3, #1
60008840:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
60008842:	f004 f807 	bl	6000c854 <z_handle_obj_poll_events>
}
60008846:	e7ea      	b.n	6000881e <z_impl_k_sem_give+0x2e>
60008848:	8000109d 	.word	0x8000109d

6000884c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
6000884c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
6000884e:	4604      	mov	r4, r0
60008850:	4616      	mov	r6, r2
60008852:	461d      	mov	r5, r3
60008854:	f04f 0310 	mov.w	r3, #16
60008858:	f3ef 8711 	mrs	r7, BASEPRI
6000885c:	f383 8811 	msr	BASEPRI, r3
60008860:	f3bf 8f6f 	isb	sy
	__ASSERT(((arch_is_in_isr() == false) ||
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);
60008864:	4601      	mov	r1, r0
60008866:	202a      	movs	r0, #42	; 0x2a
60008868:	f7fe ff8c 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>

	if (likely(sem->count > 0U)) {
6000886c:	68a3      	ldr	r3, [r4, #8]
6000886e:	b16b      	cbz	r3, 6000888c <z_impl_k_sem_take+0x40>
		sem->count--;
60008870:	3b01      	subs	r3, #1
60008872:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
60008874:	f387 8811 	msr	BASEPRI, r7
60008878:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
6000887c:	2400      	movs	r4, #0
	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_sem, take, sem, timeout);

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);
6000887e:	4621      	mov	r1, r4
60008880:	202a      	movs	r0, #42	; 0x2a
60008882:	f7ff f911 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>

	return ret;
}
60008886:	4620      	mov	r0, r4
60008888:	b003      	add	sp, #12
6000888a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
6000888c:	ea56 0305 	orrs.w	r3, r6, r5
60008890:	d106      	bne.n	600088a0 <z_impl_k_sem_take+0x54>
60008892:	f387 8811 	msr	BASEPRI, r7
60008896:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
6000889a:	f06f 040f 	mvn.w	r4, #15
6000889e:	e7ee      	b.n	6000887e <z_impl_k_sem_take+0x32>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
600088a0:	4622      	mov	r2, r4
600088a2:	4639      	mov	r1, r7
600088a4:	4803      	ldr	r0, [pc, #12]	; (600088b4 <z_impl_k_sem_take+0x68>)
600088a6:	e9cd 6500 	strd	r6, r5, [sp]
600088aa:	f000 f95f 	bl	60008b6c <z_pend_curr>
600088ae:	4604      	mov	r4, r0
600088b0:	e7e5      	b.n	6000887e <z_impl_k_sem_take+0x32>
600088b2:	bf00      	nop
600088b4:	8000109d 	.word	0x8000109d

600088b8 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
600088b8:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
600088ba:	4c08      	ldr	r4, [pc, #32]	; (600088dc <z_reset_time_slice+0x24>)
600088bc:	6823      	ldr	r3, [r4, #0]
600088be:	b15b      	cbz	r3, 600088d8 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
600088c0:	f7fd fb54 	bl	60005f6c <sys_clock_elapsed>
600088c4:	4603      	mov	r3, r0
600088c6:	6820      	ldr	r0, [r4, #0]
		z_set_timeout_expiry(slice_time, false);
600088c8:	2100      	movs	r1, #0
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
600088ca:	4a05      	ldr	r2, [pc, #20]	; (600088e0 <z_reset_time_slice+0x28>)
600088cc:	4403      	add	r3, r0
	}
}
600088ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
600088d2:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
600088d4:	f003 be18 	b.w	6000c508 <z_set_timeout_expiry>
}
600088d8:	bd10      	pop	{r4, pc}
600088da:	bf00      	nop
600088dc:	80000f2c 	.word	0x80000f2c
600088e0:	80000ef4 	.word	0x80000ef4

600088e4 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
600088e4:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
600088e6:	4d13      	ldr	r5, [pc, #76]	; (60008934 <update_cache+0x50>)
600088e8:	462b      	mov	r3, r5
600088ea:	f853 4f24 	ldr.w	r4, [r3, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
600088ee:	429c      	cmp	r4, r3
600088f0:	d00c      	beq.n	6000890c <update_cache+0x28>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, thread, base.qnode_dlist) {
600088f2:	b15c      	cbz	r4, 6000890c <update_cache+0x28>
		if ((thread->base.cpu_mask & BIT(_current_cpu->id)) != 0) {
600088f4:	7d2a      	ldrb	r2, [r5, #20]
600088f6:	2301      	movs	r3, #1
600088f8:	4093      	lsls	r3, r2
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
600088fa:	6aaa      	ldr	r2, [r5, #40]	; 0x28
600088fc:	7d21      	ldrb	r1, [r4, #20]
600088fe:	4219      	tst	r1, r3
60008900:	d105      	bne.n	6000890e <update_cache+0x2a>
60008902:	4294      	cmp	r4, r2
60008904:	d002      	beq.n	6000890c <update_cache+0x28>
60008906:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, thread, base.qnode_dlist) {
60008908:	2c00      	cmp	r4, #0
6000890a:	d1f7      	bne.n	600088fc <update_cache+0x18>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
6000890c:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
6000890e:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
60008910:	b948      	cbnz	r0, 60008926 <update_cache+0x42>
	if (z_is_thread_prevented_from_running(_current)) {
60008912:	7b5a      	ldrb	r2, [r3, #13]
60008914:	06d2      	lsls	r2, r2, #27
60008916:	d106      	bne.n	60008926 <update_cache+0x42>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
60008918:	6a22      	ldr	r2, [r4, #32]
6000891a:	b922      	cbnz	r2, 60008926 <update_cache+0x42>
	if (is_preempt(_current) || is_metairq(thread)) {
6000891c:	89da      	ldrh	r2, [r3, #14]
6000891e:	2a7f      	cmp	r2, #127	; 0x7f
60008920:	d901      	bls.n	60008926 <update_cache+0x42>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
	} else {
		_kernel.ready_q.cache = _current;
60008922:	622b      	str	r3, [r5, #32]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
60008924:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
60008926:	42a3      	cmp	r3, r4
60008928:	d001      	beq.n	6000892e <update_cache+0x4a>
			z_reset_time_slice();
6000892a:	f7ff ffc5 	bl	600088b8 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
6000892e:	622c      	str	r4, [r5, #32]
}
60008930:	e7f8      	b.n	60008924 <update_cache+0x40>
60008932:	bf00      	nop
60008934:	80000ef4 	.word	0x80000ef4

60008938 <unready_thread>:

	return thread->base.pended_on;
}

static void unready_thread(struct k_thread *thread)
{
60008938:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
6000893a:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
6000893e:	4601      	mov	r1, r0
	return (thread->base.thread_state & state) != 0U;
60008940:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
60008942:	2a00      	cmp	r2, #0
60008944:	da04      	bge.n	60008950 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
60008946:	f003 037f 	and.w	r3, r3, #127	; 0x7f
6000894a:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
6000894c:	f003 fcc0 	bl	6000c2d0 <sys_dlist_remove>
	update_cache(thread == _current);
60008950:	4b04      	ldr	r3, [pc, #16]	; (60008964 <unready_thread+0x2c>)
60008952:	6898      	ldr	r0, [r3, #8]
60008954:	1a43      	subs	r3, r0, r1
60008956:	4258      	negs	r0, r3
60008958:	4158      	adcs	r0, r3
}
6000895a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
6000895e:	f7ff bfc1 	b.w	600088e4 <update_cache>
60008962:	bf00      	nop
60008964:	80000ef4 	.word	0x80000ef4

60008968 <pend>:
{
60008968:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000896c:	4606      	mov	r6, r0
6000896e:	4615      	mov	r5, r2
60008970:	461c      	mov	r4, r3
	__asm__ volatile(
60008972:	f04f 0310 	mov.w	r3, #16
60008976:	f3ef 8711 	mrs	r7, BASEPRI
6000897a:	f383 8811 	msr	BASEPRI, r3
6000897e:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
60008982:	f003 fcc0 	bl	6000c306 <add_to_waitq_locked>
	__asm__ volatile(
60008986:	f387 8811 	msr	BASEPRI, r7
6000898a:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
6000898e:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
60008992:	bf08      	it	eq
60008994:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
60008998:	d008      	beq.n	600089ac <pend+0x44>
6000899a:	462a      	mov	r2, r5
6000899c:	4623      	mov	r3, r4
6000899e:	f106 0020 	add.w	r0, r6, #32
600089a2:	4903      	ldr	r1, [pc, #12]	; (600089b0 <pend+0x48>)
}
600089a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
600089a8:	f000 bc04 	b.w	600091b4 <z_add_timeout>
600089ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
600089b0:	6000c363 	.word	0x6000c363

600089b4 <move_thread_to_end_of_prio_q>:
{
600089b4:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
600089b6:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
600089ba:	4601      	mov	r1, r0
600089bc:	7b43      	ldrb	r3, [r0, #13]
	if (z_is_thread_queued(thread)) {
600089be:	2a00      	cmp	r2, #0
600089c0:	da04      	bge.n	600089cc <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
600089c2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
600089c6:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
600089c8:	f003 fc82 	bl	6000c2d0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
600089cc:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
600089ce:	4a15      	ldr	r2, [pc, #84]	; (60008a24 <move_thread_to_end_of_prio_q+0x70>)
600089d0:	f063 037f 	orn	r3, r3, #127	; 0x7f
	return sys_dlist_is_empty(list) ? NULL : list->head;
600089d4:	f102 0524 	add.w	r5, r2, #36	; 0x24
600089d8:	734b      	strb	r3, [r1, #13]
	return (node == list->tail) ? NULL : node->next;
600089da:	e9d2 3409 	ldrd	r3, r4, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
600089de:	42ab      	cmp	r3, r5
600089e0:	d01b      	beq.n	60008a1a <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
600089e2:	b1d3      	cbz	r3, 60008a1a <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
600089e4:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
600089e8:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
600089ec:	4286      	cmp	r6, r0
600089ee:	d00f      	beq.n	60008a10 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
600089f0:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
600089f2:	2800      	cmp	r0, #0
600089f4:	dd0c      	ble.n	60008a10 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
600089f6:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
600089f8:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
600089fc:	6001      	str	r1, [r0, #0]
	successor->prev = node;
600089fe:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
60008a00:	6890      	ldr	r0, [r2, #8]
60008a02:	1a43      	subs	r3, r0, r1
60008a04:	4258      	negs	r0, r3
}
60008a06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
60008a0a:	4158      	adcs	r0, r3
60008a0c:	f7ff bf6a 	b.w	600088e4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
60008a10:	42a3      	cmp	r3, r4
60008a12:	d002      	beq.n	60008a1a <move_thread_to_end_of_prio_q+0x66>
60008a14:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008a16:	2b00      	cmp	r3, #0
60008a18:	d1e6      	bne.n	600089e8 <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
60008a1a:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
60008a1e:	6021      	str	r1, [r4, #0]
	list->tail = node;
60008a20:	6291      	str	r1, [r2, #40]	; 0x28
}
60008a22:	e7ed      	b.n	60008a00 <move_thread_to_end_of_prio_q+0x4c>
60008a24:	80000ef4 	.word	0x80000ef4

60008a28 <ready_thread>:
{
60008a28:	b570      	push	{r4, r5, r6, lr}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
60008a2a:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
60008a2e:	4604      	mov	r4, r0
60008a30:	7b43      	ldrb	r3, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
60008a32:	2a00      	cmp	r2, #0
60008a34:	db2f      	blt.n	60008a96 <ready_thread+0x6e>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
60008a36:	06db      	lsls	r3, r3, #27
60008a38:	d12d      	bne.n	60008a96 <ready_thread+0x6e>
60008a3a:	6a03      	ldr	r3, [r0, #32]
60008a3c:	bb5b      	cbnz	r3, 60008a96 <ready_thread+0x6e>
		SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);
60008a3e:	f7ff f8df 	bl	60007c00 <SEGGER_SYSVIEW_OnTaskStartReady>
	thread->base.thread_state |= _THREAD_QUEUED;
60008a42:	7b63      	ldrb	r3, [r4, #13]
	return list->head == list;
60008a44:	4a14      	ldr	r2, [pc, #80]	; (60008a98 <ready_thread+0x70>)
60008a46:	f063 037f 	orn	r3, r3, #127	; 0x7f
60008a4a:	4611      	mov	r1, r2
60008a4c:	7363      	strb	r3, [r4, #13]
60008a4e:	f851 3f24 	ldr.w	r3, [r1, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
60008a52:	428b      	cmp	r3, r1
60008a54:	d019      	beq.n	60008a8a <ready_thread+0x62>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008a56:	b1c3      	cbz	r3, 60008a8a <ready_thread+0x62>
	return (node == list->tail) ? NULL : node->next;
60008a58:	6a96      	ldr	r6, [r2, #40]	; 0x28
	int32_t b1 = thread_1->base.prio;
60008a5a:	f994 500e 	ldrsb.w	r5, [r4, #14]
	int32_t b2 = thread_2->base.prio;
60008a5e:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
60008a62:	4285      	cmp	r5, r0
60008a64:	d00c      	beq.n	60008a80 <ready_thread+0x58>
		return b2 - b1;
60008a66:	1b40      	subs	r0, r0, r5
		if (z_sched_prio_cmp(thread, t) > 0) {
60008a68:	2800      	cmp	r0, #0
60008a6a:	dd09      	ble.n	60008a80 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
60008a6c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
60008a6e:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
60008a72:	6014      	str	r4, [r2, #0]
	successor->prev = node;
60008a74:	605c      	str	r4, [r3, #4]
		update_cache(0);
60008a76:	2000      	movs	r0, #0
}
60008a78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_cache(0);
60008a7c:	f7ff bf32 	b.w	600088e4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
60008a80:	429e      	cmp	r6, r3
60008a82:	d002      	beq.n	60008a8a <ready_thread+0x62>
60008a84:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008a86:	2b00      	cmp	r3, #0
60008a88:	d1e9      	bne.n	60008a5e <ready_thread+0x36>
	sys_dnode_t *const tail = list->tail;
60008a8a:	6a93      	ldr	r3, [r2, #40]	; 0x28
	node->prev = tail;
60008a8c:	e9c4 1300 	strd	r1, r3, [r4]
	tail->next = node;
60008a90:	601c      	str	r4, [r3, #0]
	list->tail = node;
60008a92:	6294      	str	r4, [r2, #40]	; 0x28
}
60008a94:	e7ef      	b.n	60008a76 <ready_thread+0x4e>
}
60008a96:	bd70      	pop	{r4, r5, r6, pc}
60008a98:	80000ef4 	.word	0x80000ef4

60008a9c <k_sched_time_slice_set>:
{
60008a9c:	b510      	push	{r4, lr}
	__asm__ volatile(
60008a9e:	f04f 0310 	mov.w	r3, #16
60008aa2:	f3ef 8411 	mrs	r4, BASEPRI
60008aa6:	f383 8811 	msr	BASEPRI, r3
60008aaa:	f3bf 8f6f 	isb	sy
		_current_cpu->slice_ticks = 0;
60008aae:	2200      	movs	r2, #0
60008ab0:	4b0b      	ldr	r3, [pc, #44]	; (60008ae0 <k_sched_time_slice_set+0x44>)
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
60008ab2:	4290      	cmp	r0, r2
		_current_cpu->slice_ticks = 0;
60008ab4:	611a      	str	r2, [r3, #16]
			return ((uint32_t)t) * (to_hz / from_hz);
60008ab6:	f04f 030a 	mov.w	r3, #10
60008aba:	4a0a      	ldr	r2, [pc, #40]	; (60008ae4 <k_sched_time_slice_set+0x48>)
60008abc:	fb00 f303 	mul.w	r3, r0, r3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
60008ac0:	dc09      	bgt.n	60008ad6 <k_sched_time_slice_set+0x3a>
			slice_time = MAX(2, slice_time);
60008ac2:	6013      	str	r3, [r2, #0]
		slice_max_prio = prio;
60008ac4:	4b08      	ldr	r3, [pc, #32]	; (60008ae8 <k_sched_time_slice_set+0x4c>)
60008ac6:	6019      	str	r1, [r3, #0]
		z_reset_time_slice();
60008ac8:	f7ff fef6 	bl	600088b8 <z_reset_time_slice>
	__asm__ volatile(
60008acc:	f384 8811 	msr	BASEPRI, r4
60008ad0:	f3bf 8f6f 	isb	sy
}
60008ad4:	bd10      	pop	{r4, pc}
			slice_time = MAX(2, slice_time);
60008ad6:	2b02      	cmp	r3, #2
60008ad8:	bfb8      	it	lt
60008ada:	2302      	movlt	r3, #2
60008adc:	e7f1      	b.n	60008ac2 <k_sched_time_slice_set+0x26>
60008ade:	bf00      	nop
60008ae0:	80000ef4 	.word	0x80000ef4
60008ae4:	80000f2c 	.word	0x80000f2c
60008ae8:	80000f28 	.word	0x80000f28

60008aec <z_time_slice>:
{
60008aec:	4601      	mov	r1, r0
60008aee:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
60008af0:	f04f 0310 	mov.w	r3, #16
60008af4:	f3ef 8411 	mrs	r4, BASEPRI
60008af8:	f383 8811 	msr	BASEPRI, r3
60008afc:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
60008b00:	4b15      	ldr	r3, [pc, #84]	; (60008b58 <z_time_slice+0x6c>)
60008b02:	4a16      	ldr	r2, [pc, #88]	; (60008b5c <z_time_slice+0x70>)
60008b04:	6898      	ldr	r0, [r3, #8]
60008b06:	6815      	ldr	r5, [r2, #0]
60008b08:	42a8      	cmp	r0, r5
60008b0a:	d106      	bne.n	60008b1a <z_time_slice+0x2e>
			z_reset_time_slice();
60008b0c:	f7ff fed4 	bl	600088b8 <z_reset_time_slice>
	__asm__ volatile(
60008b10:	f384 8811 	msr	BASEPRI, r4
60008b14:	f3bf 8f6f 	isb	sy
}
60008b18:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
60008b1a:	2500      	movs	r5, #0
60008b1c:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
60008b1e:	4a10      	ldr	r2, [pc, #64]	; (60008b60 <z_time_slice+0x74>)
60008b20:	6812      	ldr	r2, [r2, #0]
60008b22:	b1ba      	cbz	r2, 60008b54 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
60008b24:	89c2      	ldrh	r2, [r0, #14]
60008b26:	2a7f      	cmp	r2, #127	; 0x7f
60008b28:	d814      	bhi.n	60008b54 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
60008b2a:	7b42      	ldrb	r2, [r0, #13]
60008b2c:	06d2      	lsls	r2, r2, #27
60008b2e:	d111      	bne.n	60008b54 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
60008b30:	4a0c      	ldr	r2, [pc, #48]	; (60008b64 <z_time_slice+0x78>)
60008b32:	f990 500e 	ldrsb.w	r5, [r0, #14]
60008b36:	6812      	ldr	r2, [r2, #0]
60008b38:	4295      	cmp	r5, r2
60008b3a:	db0b      	blt.n	60008b54 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
60008b3c:	4a0a      	ldr	r2, [pc, #40]	; (60008b68 <z_time_slice+0x7c>)
60008b3e:	4290      	cmp	r0, r2
60008b40:	d008      	beq.n	60008b54 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
60008b42:	691a      	ldr	r2, [r3, #16]
60008b44:	428a      	cmp	r2, r1
60008b46:	dc02      	bgt.n	60008b4e <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
60008b48:	f7ff ff34 	bl	600089b4 <move_thread_to_end_of_prio_q>
60008b4c:	e7de      	b.n	60008b0c <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
60008b4e:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
60008b50:	611a      	str	r2, [r3, #16]
60008b52:	e7dd      	b.n	60008b10 <z_time_slice+0x24>
60008b54:	2200      	movs	r2, #0
60008b56:	e7fb      	b.n	60008b50 <z_time_slice+0x64>
60008b58:	80000ef4 	.word	0x80000ef4
60008b5c:	80000f24 	.word	0x80000f24
60008b60:	80000f2c 	.word	0x80000f2c
60008b64:	80000f28 	.word	0x80000f28
60008b68:	80000760 	.word	0x80000760

60008b6c <z_pend_curr>:
	pending_current = _current;
60008b6c:	4b07      	ldr	r3, [pc, #28]	; (60008b8c <z_pend_curr+0x20>)
60008b6e:	6898      	ldr	r0, [r3, #8]
60008b70:	4b07      	ldr	r3, [pc, #28]	; (60008b90 <z_pend_curr+0x24>)
{
60008b72:	b510      	push	{r4, lr}
60008b74:	460c      	mov	r4, r1
	pending_current = _current;
60008b76:	6018      	str	r0, [r3, #0]
{
60008b78:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
60008b7a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
60008b7e:	f7ff fef3 	bl	60008968 <pend>
	ret = arch_swap(key);
60008b82:	4620      	mov	r0, r4
}
60008b84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
60008b88:	f7fd ba24 	b.w	60005fd4 <arch_swap>
60008b8c:	80000ef4 	.word	0x80000ef4
60008b90:	80000f24 	.word	0x80000f24

60008b94 <z_set_prio>:
{
60008b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60008b96:	4604      	mov	r4, r0
60008b98:	460d      	mov	r5, r1
	__asm__ volatile(
60008b9a:	f04f 0310 	mov.w	r3, #16
60008b9e:	f3ef 8711 	mrs	r7, BASEPRI
60008ba2:	f383 8811 	msr	BASEPRI, r3
60008ba6:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
60008baa:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
60008bac:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
60008bae:	06da      	lsls	r2, r3, #27
60008bb0:	d13e      	bne.n	60008c30 <z_set_prio+0x9c>
		if (need_sched) {
60008bb2:	6a02      	ldr	r2, [r0, #32]
60008bb4:	2a00      	cmp	r2, #0
60008bb6:	d13b      	bne.n	60008c30 <z_set_prio+0x9c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
60008bb8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
60008bbc:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
60008bbe:	f003 fb87 	bl	6000c2d0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
60008bc2:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
60008bc4:	4a1c      	ldr	r2, [pc, #112]	; (60008c38 <z_set_prio+0xa4>)
60008bc6:	f063 037f 	orn	r3, r3, #127	; 0x7f
				thread->base.prio = prio;
60008bca:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
60008bcc:	7343      	strb	r3, [r0, #13]
60008bce:	4610      	mov	r0, r2
60008bd0:	f850 3f24 	ldr.w	r3, [r0, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
60008bd4:	4283      	cmp	r3, r0
60008bd6:	d025      	beq.n	60008c24 <z_set_prio+0x90>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008bd8:	b323      	cbz	r3, 60008c24 <z_set_prio+0x90>
	return (node == list->tail) ? NULL : node->next;
60008bda:	f8d2 c028 	ldr.w	ip, [r2, #40]	; 0x28
	int32_t b2 = thread_2->base.prio;
60008bde:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
60008be2:	42b1      	cmp	r1, r6
60008be4:	d019      	beq.n	60008c1a <z_set_prio+0x86>
		return b2 - b1;
60008be6:	1a76      	subs	r6, r6, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
60008be8:	2e00      	cmp	r6, #0
60008bea:	dd16      	ble.n	60008c1a <z_set_prio+0x86>
	sys_dnode_t *const prev = successor->prev;
60008bec:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
60008bee:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
60008bf2:	6014      	str	r4, [r2, #0]
	successor->prev = node;
60008bf4:	605c      	str	r4, [r3, #4]
60008bf6:	2601      	movs	r6, #1
			update_cache(1);
60008bf8:	2001      	movs	r0, #1
60008bfa:	f7ff fe73 	bl	600088e4 <update_cache>
	__asm__ volatile(
60008bfe:	f387 8811 	msr	BASEPRI, r7
60008c02:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_priority_set, thread, prio);
60008c06:	4620      	mov	r0, r4
60008c08:	f7fe fbf0 	bl	600073ec <SEGGER_SYSVIEW_ShrinkId>
60008c0c:	462a      	mov	r2, r5
60008c0e:	4601      	mov	r1, r0
60008c10:	2062      	movs	r0, #98	; 0x62
60008c12:	f7fe fdb7 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>
}
60008c16:	4630      	mov	r0, r6
60008c18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
60008c1a:	4563      	cmp	r3, ip
60008c1c:	d002      	beq.n	60008c24 <z_set_prio+0x90>
60008c1e:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008c20:	2b00      	cmp	r3, #0
60008c22:	d1dc      	bne.n	60008bde <z_set_prio+0x4a>
	sys_dnode_t *const tail = list->tail;
60008c24:	6a93      	ldr	r3, [r2, #40]	; 0x28
	node->prev = tail;
60008c26:	e9c4 0300 	strd	r0, r3, [r4]
	tail->next = node;
60008c2a:	601c      	str	r4, [r3, #0]
	list->tail = node;
60008c2c:	6294      	str	r4, [r2, #40]	; 0x28
}
60008c2e:	e7e2      	b.n	60008bf6 <z_set_prio+0x62>
			thread->base.prio = prio;
60008c30:	2600      	movs	r6, #0
60008c32:	73a1      	strb	r1, [r4, #14]
60008c34:	e7e3      	b.n	60008bfe <z_set_prio+0x6a>
60008c36:	bf00      	nop
60008c38:	80000ef4 	.word	0x80000ef4

60008c3c <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
60008c3c:	b949      	cbnz	r1, 60008c52 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
60008c3e:	f3ef 8005 	mrs	r0, IPSR
	if (resched(key.key) && need_swap()) {
60008c42:	b930      	cbnz	r0, 60008c52 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
60008c44:	4b05      	ldr	r3, [pc, #20]	; (60008c5c <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
60008c46:	6a1a      	ldr	r2, [r3, #32]
60008c48:	689b      	ldr	r3, [r3, #8]
60008c4a:	429a      	cmp	r2, r3
60008c4c:	d001      	beq.n	60008c52 <z_reschedule+0x16>
60008c4e:	f7fd b9c1 	b.w	60005fd4 <arch_swap>
60008c52:	f381 8811 	msr	BASEPRI, r1
60008c56:	f3bf 8f6f 	isb	sy
}
60008c5a:	4770      	bx	lr
60008c5c:	80000ef4 	.word	0x80000ef4

60008c60 <z_sched_start>:
{
60008c60:	b510      	push	{r4, lr}
	__asm__ volatile(
60008c62:	f04f 0210 	mov.w	r2, #16
60008c66:	f3ef 8411 	mrs	r4, BASEPRI
60008c6a:	f382 8811 	msr	BASEPRI, r2
60008c6e:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
60008c72:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
60008c74:	0751      	lsls	r1, r2, #29
60008c76:	d404      	bmi.n	60008c82 <z_sched_start+0x22>
	__asm__ volatile(
60008c78:	f384 8811 	msr	BASEPRI, r4
60008c7c:	f3bf 8f6f 	isb	sy
}
60008c80:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
60008c82:	f022 0204 	bic.w	r2, r2, #4
60008c86:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
60008c88:	f7ff fece 	bl	60008a28 <ready_thread>
	z_reschedule(&sched_spinlock, key);
60008c8c:	4621      	mov	r1, r4
60008c8e:	4802      	ldr	r0, [pc, #8]	; (60008c98 <z_sched_start+0x38>)
}
60008c90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
60008c94:	f7ff bfd2 	b.w	60008c3c <z_reschedule>
60008c98:	8000109d 	.word	0x8000109d

60008c9c <z_impl_k_thread_suspend>:
{
60008c9c:	b570      	push	{r4, r5, r6, lr}
60008c9e:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, suspend, thread);
60008ca0:	4601      	mov	r1, r0
60008ca2:	2066      	movs	r0, #102	; 0x66
60008ca4:	f7fe fd4a 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
60008ca8:	f104 0020 	add.w	r0, r4, #32
60008cac:	f003 fc16 	bl	6000c4dc <z_abort_timeout>
	__asm__ volatile(
60008cb0:	f04f 0310 	mov.w	r3, #16
60008cb4:	f3ef 8611 	mrs	r6, BASEPRI
60008cb8:	f383 8811 	msr	BASEPRI, r3
60008cbc:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
60008cc0:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
60008cc4:	7b63      	ldrb	r3, [r4, #13]
60008cc6:	2a00      	cmp	r2, #0
60008cc8:	da05      	bge.n	60008cd6 <z_impl_k_thread_suspend+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
60008cca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
60008cce:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
60008cd0:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
60008cd2:	f003 fafd 	bl	6000c2d0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
60008cd6:	7b63      	ldrb	r3, [r4, #13]
	SYS_PORT_TRACING_FUNC(k_thread, sched_suspend, thread);
60008cd8:	2118      	movs	r1, #24
		update_cache(thread == _current);
60008cda:	4d0d      	ldr	r5, [pc, #52]	; (60008d10 <z_impl_k_thread_suspend+0x74>)
60008cdc:	4620      	mov	r0, r4
	thread->base.thread_state |= _THREAD_SUSPENDED;
60008cde:	f043 0310 	orr.w	r3, r3, #16
60008ce2:	7363      	strb	r3, [r4, #13]
	SYS_PORT_TRACING_FUNC(k_thread, sched_suspend, thread);
60008ce4:	f7fe ffb4 	bl	60007c50 <SEGGER_SYSVIEW_OnTaskStopReady>
60008ce8:	68a8      	ldr	r0, [r5, #8]
60008cea:	1b03      	subs	r3, r0, r4
60008cec:	4258      	negs	r0, r3
60008cee:	4158      	adcs	r0, r3
60008cf0:	f7ff fdf8 	bl	600088e4 <update_cache>
	__asm__ volatile(
60008cf4:	f386 8811 	msr	BASEPRI, r6
60008cf8:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
60008cfc:	68ab      	ldr	r3, [r5, #8]
60008cfe:	42a3      	cmp	r3, r4
60008d00:	d101      	bne.n	60008d06 <z_impl_k_thread_suspend+0x6a>
		z_reschedule_unlocked();
60008d02:	f003 fb90 	bl	6000c426 <z_reschedule_unlocked>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, suspend, thread);
60008d06:	2066      	movs	r0, #102	; 0x66
}
60008d08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, suspend, thread);
60008d0c:	f7fe beaa 	b.w	60007a64 <SEGGER_SYSVIEW_RecordEndCall>
60008d10:	80000ef4 	.word	0x80000ef4

60008d14 <k_sched_lock>:
	__asm__ volatile(
60008d14:	f04f 0310 	mov.w	r3, #16
60008d18:	f3ef 8111 	mrs	r1, BASEPRI
60008d1c:	f383 8811 	msr	BASEPRI, r3
60008d20:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
60008d24:	4b04      	ldr	r3, [pc, #16]	; (60008d38 <k_sched_lock+0x24>)
60008d26:	689a      	ldr	r2, [r3, #8]
60008d28:	7bd3      	ldrb	r3, [r2, #15]
60008d2a:	3b01      	subs	r3, #1
60008d2c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
60008d2e:	f381 8811 	msr	BASEPRI, r1
60008d32:	f3bf 8f6f 	isb	sy
}
60008d36:	4770      	bx	lr
60008d38:	80000ef4 	.word	0x80000ef4

60008d3c <k_sched_unlock>:
{
60008d3c:	b510      	push	{r4, lr}
	__asm__ volatile(
60008d3e:	f04f 0310 	mov.w	r3, #16
60008d42:	f3ef 8411 	mrs	r4, BASEPRI
60008d46:	f383 8811 	msr	BASEPRI, r3
60008d4a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
60008d4e:	4b08      	ldr	r3, [pc, #32]	; (60008d70 <k_sched_unlock+0x34>)
		update_cache(0);
60008d50:	2000      	movs	r0, #0
		++_current->base.sched_locked;
60008d52:	689a      	ldr	r2, [r3, #8]
60008d54:	7bd3      	ldrb	r3, [r2, #15]
60008d56:	3301      	adds	r3, #1
60008d58:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
60008d5a:	f7ff fdc3 	bl	600088e4 <update_cache>
	__asm__ volatile(
60008d5e:	f384 8811 	msr	BASEPRI, r4
60008d62:	f3bf 8f6f 	isb	sy
}
60008d66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
60008d6a:	f003 bb5c 	b.w	6000c426 <z_reschedule_unlocked>
60008d6e:	bf00      	nop
60008d70:	80000ef4 	.word	0x80000ef4

60008d74 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
60008d74:	4b04      	ldr	r3, [pc, #16]	; (60008d88 <z_sched_init+0x14>)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
60008d76:	2100      	movs	r1, #0
60008d78:	f103 0224 	add.w	r2, r3, #36	; 0x24
60008d7c:	4608      	mov	r0, r1
	list->tail = (sys_dnode_t *)list;
60008d7e:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
60008d82:	f7ff be8b 	b.w	60008a9c <k_sched_time_slice_set>
60008d86:	bf00      	nop
60008d88:	80000ef4 	.word	0x80000ef4

60008d8c <z_impl_k_yield>:

void z_impl_k_yield(void)
{
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC(k_thread, yield);
60008d8c:	2069      	movs	r0, #105	; 0x69
{
60008d8e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SYS_PORT_TRACING_FUNC(k_thread, yield);
60008d90:	f7fe fcbe 	bl	60007710 <SEGGER_SYSVIEW_RecordVoid>
	__asm__ volatile(
60008d94:	f04f 0310 	mov.w	r3, #16
60008d98:	f3ef 8511 	mrs	r5, BASEPRI
60008d9c:	f383 8811 	msr	BASEPRI, r3
60008da0:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(&_kernel.ready_q.runq,
60008da4:	491a      	ldr	r1, [pc, #104]	; (60008e10 <z_impl_k_yield+0x84>)
60008da6:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
60008da8:	7b43      	ldrb	r3, [r0, #13]
60008daa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
60008dae:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
60008db0:	f003 fa8e 	bl	6000c2d0 <sys_dlist_remove>
			       _current);
	}
	queue_thread(&_kernel.ready_q.runq, _current);
60008db4:	688b      	ldr	r3, [r1, #8]
	return list->head == list;
60008db6:	4608      	mov	r0, r1
	thread->base.thread_state |= _THREAD_QUEUED;
60008db8:	7b5a      	ldrb	r2, [r3, #13]
60008dba:	f062 027f 	orn	r2, r2, #127	; 0x7f
60008dbe:	735a      	strb	r2, [r3, #13]
60008dc0:	f850 2f24 	ldr.w	r2, [r0, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
60008dc4:	4282      	cmp	r2, r0
60008dc6:	d01c      	beq.n	60008e02 <z_impl_k_yield+0x76>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008dc8:	b1da      	cbz	r2, 60008e02 <z_impl_k_yield+0x76>
	return (node == list->tail) ? NULL : node->next;
60008dca:	6a8f      	ldr	r7, [r1, #40]	; 0x28
	int32_t b1 = thread_1->base.prio;
60008dcc:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
60008dd0:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
60008dd4:	42a6      	cmp	r6, r4
60008dd6:	d00f      	beq.n	60008df8 <z_impl_k_yield+0x6c>
		return b2 - b1;
60008dd8:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
60008dda:	2c00      	cmp	r4, #0
60008ddc:	dd0c      	ble.n	60008df8 <z_impl_k_yield+0x6c>
	sys_dnode_t *const prev = successor->prev;
60008dde:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
60008de0:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
60008de4:	600b      	str	r3, [r1, #0]
	successor->prev = node;
60008de6:	6053      	str	r3, [r2, #4]
	update_cache(1);
60008de8:	2001      	movs	r0, #1
60008dea:	f7ff fd7b 	bl	600088e4 <update_cache>
60008dee:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
60008df0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
60008df4:	f7fd b8ee 	b.w	60005fd4 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
60008df8:	42ba      	cmp	r2, r7
60008dfa:	d002      	beq.n	60008e02 <z_impl_k_yield+0x76>
60008dfc:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
60008dfe:	2a00      	cmp	r2, #0
60008e00:	d1e6      	bne.n	60008dd0 <z_impl_k_yield+0x44>
	sys_dnode_t *const tail = list->tail;
60008e02:	6a8a      	ldr	r2, [r1, #40]	; 0x28
	node->prev = tail;
60008e04:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
60008e08:	6013      	str	r3, [r2, #0]
	list->tail = node;
60008e0a:	628b      	str	r3, [r1, #40]	; 0x28
}
60008e0c:	e7ec      	b.n	60008de8 <z_impl_k_yield+0x5c>
60008e0e:	bf00      	nop
60008e10:	80000ef4 	.word	0x80000ef4

60008e14 <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
60008e14:	ea50 0301 	orrs.w	r3, r0, r1
{
60008e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60008e1c:	4605      	mov	r5, r0
60008e1e:	460e      	mov	r6, r1
	if (ticks == 0) {
60008e20:	d103      	bne.n	60008e2a <z_tick_sleep+0x16>
	z_impl_k_yield();
60008e22:	f7ff ffb3 	bl	60008d8c <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
60008e26:	2000      	movs	r0, #0
60008e28:	e03a      	b.n	60008ea0 <z_tick_sleep+0x8c>
	if (Z_TICK_ABS(ticks) <= 0) {
60008e2a:	f06f 0401 	mvn.w	r4, #1
60008e2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60008e32:	1a24      	subs	r4, r4, r0
60008e34:	eb63 0301 	sbc.w	r3, r3, r1
60008e38:	2c01      	cmp	r4, #1
60008e3a:	f173 0300 	sbcs.w	r3, r3, #0
60008e3e:	da02      	bge.n	60008e46 <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
60008e40:	f003 fb7c 	bl	6000c53c <sys_clock_tick_get_32>
60008e44:	1944      	adds	r4, r0, r5
60008e46:	f04f 0310 	mov.w	r3, #16
60008e4a:	f3ef 8711 	mrs	r7, BASEPRI
60008e4e:	f383 8811 	msr	BASEPRI, r3
60008e52:	f3bf 8f6f 	isb	sy
	pending_current = _current;
60008e56:	f8df 804c 	ldr.w	r8, [pc, #76]	; 60008ea4 <z_tick_sleep+0x90>
60008e5a:	4b13      	ldr	r3, [pc, #76]	; (60008ea8 <z_tick_sleep+0x94>)
60008e5c:	f8d8 0008 	ldr.w	r0, [r8, #8]
60008e60:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
60008e62:	f7ff fd69 	bl	60008938 <unready_thread>
	z_add_thread_timeout(_current, timeout);
60008e66:	f8d8 0008 	ldr.w	r0, [r8, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
60008e6a:	462a      	mov	r2, r5
60008e6c:	4633      	mov	r3, r6
60008e6e:	490f      	ldr	r1, [pc, #60]	; (60008eac <z_tick_sleep+0x98>)
60008e70:	3020      	adds	r0, #32
60008e72:	f000 f99f 	bl	600091b4 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
60008e76:	f8d8 0008 	ldr.w	r0, [r8, #8]
	SYS_PORT_TRACING_FUNC(k_thread, sched_suspend, thread);
60008e7a:	2118      	movs	r1, #24
	thread->base.thread_state |= _THREAD_SUSPENDED;
60008e7c:	7b43      	ldrb	r3, [r0, #13]
60008e7e:	f043 0310 	orr.w	r3, r3, #16
60008e82:	7343      	strb	r3, [r0, #13]
	SYS_PORT_TRACING_FUNC(k_thread, sched_suspend, thread);
60008e84:	f7fe fee4 	bl	60007c50 <SEGGER_SYSVIEW_OnTaskStopReady>
60008e88:	4638      	mov	r0, r7
60008e8a:	f7fd f8a3 	bl	60005fd4 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
60008e8e:	f003 fb55 	bl	6000c53c <sys_clock_tick_get_32>
60008e92:	1a20      	subs	r0, r4, r0
60008e94:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
60008e98:	2801      	cmp	r0, #1
60008e9a:	f173 0300 	sbcs.w	r3, r3, #0
60008e9e:	dbc2      	blt.n	60008e26 <z_tick_sleep+0x12>
}
60008ea0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
60008ea4:	80000ef4 	.word	0x80000ef4
60008ea8:	80000f24 	.word	0x80000f24
60008eac:	6000c363 	.word	0x6000c363

60008eb0 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
60008eb0:	b538      	push	{r3, r4, r5, lr}
60008eb2:	460d      	mov	r5, r1
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);
60008eb4:	210a      	movs	r1, #10
{
60008eb6:	4604      	mov	r4, r0
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);
60008eb8:	fbb0 f1f1 	udiv	r1, r0, r1
60008ebc:	205f      	movs	r0, #95	; 0x5f
60008ebe:	f7fe fc3d 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
60008ec2:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
60008ec6:	bf08      	it	eq
60008ec8:	f1b4 3fff 	cmpeq.w	r4, #4294967295	; 0xffffffff
60008ecc:	d10c      	bne.n	60008ee8 <z_impl_k_sleep+0x38>
		k_thread_suspend(_current);
60008ece:	4b0e      	ldr	r3, [pc, #56]	; (60008f08 <z_impl_k_sleep+0x58>)
60008ed0:	6898      	ldr	r0, [r3, #8]

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
60008ed2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	z_impl_k_thread_suspend(thread);
60008ed6:	f7ff fee1 	bl	60008c9c <z_impl_k_thread_suspend>
		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);
60008eda:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
60008ede:	205f      	movs	r0, #95	; 0x5f
60008ee0:	f7fe fde2 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
60008ee4:	4620      	mov	r0, r4
60008ee6:	bd38      	pop	{r3, r4, r5, pc}
	ticks = z_tick_sleep(ticks);
60008ee8:	4629      	mov	r1, r5
60008eea:	4620      	mov	r0, r4
60008eec:	f7ff ff92 	bl	60008e14 <z_tick_sleep>
			return t / (from_hz / to_hz);
60008ef0:	220a      	movs	r2, #10
60008ef2:	2300      	movs	r3, #0
60008ef4:	17c1      	asrs	r1, r0, #31
60008ef6:	f7f9 f9e3 	bl	600022c0 <__aeabi_uldivmod>
60008efa:	4601      	mov	r1, r0
	int32_t ret = k_ticks_to_ms_floor64(ticks);
60008efc:	4604      	mov	r4, r0
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);
60008efe:	205f      	movs	r0, #95	; 0x5f
60008f00:	f7fe fdd2 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	return ret;
60008f04:	e7ee      	b.n	60008ee4 <z_impl_k_sleep+0x34>
60008f06:	bf00      	nop
60008f08:	80000ef4 	.word	0x80000ef4

60008f0c <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
60008f0c:	4b01      	ldr	r3, [pc, #4]	; (60008f14 <z_impl_k_current_get+0x8>)
60008f0e:	6898      	ldr	r0, [r3, #8]
60008f10:	4770      	bx	lr
60008f12:	bf00      	nop
60008f14:	80000ef4 	.word	0x80000ef4

60008f18 <z_impl_k_is_preempt_thread>:
60008f18:	f3ef 8305 	mrs	r3, IPSR
#include <syscalls/k_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
60008f1c:	b93b      	cbnz	r3, 60008f2e <z_impl_k_is_preempt_thread+0x16>
60008f1e:	4b05      	ldr	r3, [pc, #20]	; (60008f34 <z_impl_k_is_preempt_thread+0x1c>)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
60008f20:	689b      	ldr	r3, [r3, #8]
	return !arch_is_in_isr() && is_preempt(_current);
60008f22:	89d8      	ldrh	r0, [r3, #14]
60008f24:	287f      	cmp	r0, #127	; 0x7f
60008f26:	bf8c      	ite	hi
60008f28:	2000      	movhi	r0, #0
60008f2a:	2001      	movls	r0, #1
60008f2c:	4770      	bx	lr
60008f2e:	2000      	movs	r0, #0
}
60008f30:	4770      	bx	lr
60008f32:	bf00      	nop
60008f34:	80000ef4 	.word	0x80000ef4

60008f38 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
60008f38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60008f3c:	4604      	mov	r4, r0
60008f3e:	f04f 0310 	mov.w	r3, #16
60008f42:	f3ef 8611 	mrs	r6, BASEPRI
60008f46:	f383 8811 	msr	BASEPRI, r3
60008f4a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
60008f4e:	7b43      	ldrb	r3, [r0, #13]
60008f50:	071a      	lsls	r2, r3, #28
60008f52:	d505      	bpl.n	60008f60 <z_thread_abort+0x28>
	__asm__ volatile(
60008f54:	f386 8811 	msr	BASEPRI, r6
60008f58:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
60008f5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
60008f60:	f023 0220 	bic.w	r2, r3, #32
60008f64:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
60008f68:	09d2      	lsrs	r2, r2, #7
60008f6a:	d127      	bne.n	60008fbc <z_thread_abort+0x84>
		thread->base.thread_state &= ~_THREAD_ABORTING;
60008f6c:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
60008f6e:	68a3      	ldr	r3, [r4, #8]
60008f70:	b113      	cbz	r3, 60008f78 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
60008f72:	4620      	mov	r0, r4
60008f74:	f003 f9b4 	bl	6000c2e0 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
60008f78:	f104 0760 	add.w	r7, r4, #96	; 0x60
60008f7c:	f04f 0800 	mov.w	r8, #0
	return z_abort_timeout(&thread->base.timeout);
60008f80:	f104 0020 	add.w	r0, r4, #32
60008f84:	f003 faaa 	bl	6000c4dc <z_abort_timeout>
	return list->head == list;
60008f88:	6e25      	ldr	r5, [r4, #96]	; 0x60
	return sys_dlist_is_empty(list) ? NULL : list->head;
60008f8a:	42bd      	cmp	r5, r7
60008f8c:	d000      	beq.n	60008f90 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
60008f8e:	b9ed      	cbnz	r5, 60008fcc <z_thread_abort+0x94>
		update_cache(1);
60008f90:	2001      	movs	r0, #1
60008f92:	f7ff fca7 	bl	600088e4 <update_cache>
		SYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);
60008f96:	4621      	mov	r1, r4
60008f98:	2064      	movs	r0, #100	; 0x64
60008f9a:	f7fe fbcf 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
		z_thread_monitor_exit(thread);
60008f9e:	4620      	mov	r0, r4
60008fa0:	f7ff f93c 	bl	6000821c <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
60008fa4:	4b10      	ldr	r3, [pc, #64]	; (60008fe8 <z_thread_abort+0xb0>)
60008fa6:	689b      	ldr	r3, [r3, #8]
60008fa8:	42a3      	cmp	r3, r4
60008faa:	d1d3      	bne.n	60008f54 <z_thread_abort+0x1c>
60008fac:	f3ef 8305 	mrs	r3, IPSR
60008fb0:	2b00      	cmp	r3, #0
60008fb2:	d1cf      	bne.n	60008f54 <z_thread_abort+0x1c>
60008fb4:	4630      	mov	r0, r6
60008fb6:	f7fd f80d 	bl	60005fd4 <arch_swap>
	return ret;
60008fba:	e7cb      	b.n	60008f54 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
60008fbc:	f003 035f 	and.w	r3, r3, #95	; 0x5f
60008fc0:	f043 0308 	orr.w	r3, r3, #8
60008fc4:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
60008fc6:	f003 f983 	bl	6000c2d0 <sys_dlist_remove>
}
60008fca:	e7d0      	b.n	60008f6e <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
60008fcc:	4628      	mov	r0, r5
60008fce:	f003 f987 	bl	6000c2e0 <unpend_thread_no_timeout>
60008fd2:	f105 0020 	add.w	r0, r5, #32
60008fd6:	f003 fa81 	bl	6000c4dc <z_abort_timeout>
		ready_thread(thread);
60008fda:	4628      	mov	r0, r5
60008fdc:	f8c5 80b8 	str.w	r8, [r5, #184]	; 0xb8
60008fe0:	f7ff fd22 	bl	60008a28 <ready_thread>
60008fe4:	e7d0      	b.n	60008f88 <z_thread_abort+0x50>
60008fe6:	bf00      	nop
60008fe8:	80000ef4 	.word	0x80000ef4

60008fec <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
60008fec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60008ff0:	4604      	mov	r4, r0
60008ff2:	4615      	mov	r5, r2
60008ff4:	461e      	mov	r6, r3
	__asm__ volatile(
60008ff6:	f04f 0310 	mov.w	r3, #16
60008ffa:	f3ef 8711 	mrs	r7, BASEPRI
60008ffe:	f383 8811 	msr	BASEPRI, r3
60009002:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);
	int ret = 0;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, join, thread, timeout);
60009006:	4601      	mov	r1, r0
60009008:	2068      	movs	r0, #104	; 0x68
6000900a:	f7fe fbbb 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
6000900e:	7b63      	ldrb	r3, [r4, #13]
60009010:	071b      	lsls	r3, r3, #28
60009012:	d42a      	bmi.n	6000906a <z_impl_k_thread_join+0x7e>
		ret = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
60009014:	ea56 0305 	orrs.w	r3, r6, r5
60009018:	d031      	beq.n	6000907e <z_impl_k_thread_join+0x92>
		ret = -EBUSY;
	} else if ((thread == _current) ||
6000901a:	f8df 8070 	ldr.w	r8, [pc, #112]	; 6000908c <z_impl_k_thread_join+0xa0>
6000901e:	f8d8 0008 	ldr.w	r0, [r8, #8]
60009022:	42a0      	cmp	r0, r4
60009024:	d02e      	beq.n	60009084 <z_impl_k_thread_join+0x98>
		   (thread->base.pended_on == &_current->join_queue)) {
60009026:	f100 0360 	add.w	r3, r0, #96	; 0x60
	} else if ((thread == _current) ||
6000902a:	68a2      	ldr	r2, [r4, #8]
6000902c:	429a      	cmp	r2, r3
6000902e:	d029      	beq.n	60009084 <z_impl_k_thread_join+0x98>
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
		add_to_waitq_locked(_current, &thread->join_queue);
60009030:	f104 0160 	add.w	r1, r4, #96	; 0x60
60009034:	f003 f967 	bl	6000c306 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
60009038:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
6000903c:	bf08      	it	eq
6000903e:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
60009042:	d007      	beq.n	60009054 <z_impl_k_thread_join+0x68>
		add_thread_timeout(_current, timeout);
60009044:	f8d8 0008 	ldr.w	r0, [r8, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
60009048:	462a      	mov	r2, r5
6000904a:	4633      	mov	r3, r6
6000904c:	4910      	ldr	r1, [pc, #64]	; (60009090 <z_impl_k_thread_join+0xa4>)
6000904e:	3020      	adds	r0, #32
60009050:	f000 f8b0 	bl	600091b4 <z_add_timeout>
	ret = arch_swap(key);
60009054:	4638      	mov	r0, r7
60009056:	f7fc ffbd 	bl	60005fd4 <arch_swap>
6000905a:	4604      	mov	r4, r0

		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_thread, join, thread, timeout);
		ret = z_swap(&sched_spinlock, key);
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);
6000905c:	4601      	mov	r1, r0
6000905e:	2068      	movs	r0, #104	; 0x68
60009060:	f7fe fd22 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
60009064:	4620      	mov	r0, r4
60009066:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = 0;
6000906a:	2400      	movs	r4, #0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);
6000906c:	4621      	mov	r1, r4
6000906e:	2068      	movs	r0, #104	; 0x68
60009070:	f7fe fd1a 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
	__asm__ volatile(
60009074:	f387 8811 	msr	BASEPRI, r7
60009078:	f3bf 8f6f 	isb	sy
	return ret;
6000907c:	e7f2      	b.n	60009064 <z_impl_k_thread_join+0x78>
		ret = -EBUSY;
6000907e:	f06f 040f 	mvn.w	r4, #15
60009082:	e7f3      	b.n	6000906c <z_impl_k_thread_join+0x80>
		ret = -EDEADLK;
60009084:	f06f 042c 	mvn.w	r4, #44	; 0x2c
60009088:	e7f0      	b.n	6000906c <z_impl_k_thread_join+0x80>
6000908a:	bf00      	nop
6000908c:	80000ef4 	.word	0x80000ef4
60009090:	6000c363 	.word	0x6000c363

60009094 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
60009094:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
60009096:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
6000909a:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
6000909c:	e9cd 6700 	strd	r6, r7, [sp]
600090a0:	f7ff fd64 	bl	60008b6c <z_pend_curr>

	if (data != NULL) {
600090a4:	b11c      	cbz	r4, 600090ae <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
600090a6:	4b03      	ldr	r3, [pc, #12]	; (600090b4 <z_sched_wait+0x20>)
600090a8:	689b      	ldr	r3, [r3, #8]
600090aa:	699b      	ldr	r3, [r3, #24]
600090ac:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
600090ae:	b002      	add	sp, #8
600090b0:	bdd0      	pop	{r4, r6, r7, pc}
600090b2:	bf00      	nop
600090b4:	80000ef4 	.word	0x80000ef4

600090b8 <z_data_copy>:
 * @return N/A
 */
void z_data_copy(void)
{
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
600090b8:	480c      	ldr	r0, [pc, #48]	; (600090ec <z_data_copy+0x34>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
600090ba:	4a0d      	ldr	r2, [pc, #52]	; (600090f0 <z_data_copy+0x38>)
600090bc:	490d      	ldr	r1, [pc, #52]	; (600090f4 <z_data_copy+0x3c>)
600090be:	1a12      	subs	r2, r2, r0
{
600090c0:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
600090c2:	f002 fc46 	bl	6000b952 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
600090c6:	4a0c      	ldr	r2, [pc, #48]	; (600090f8 <z_data_copy+0x40>)
600090c8:	490c      	ldr	r1, [pc, #48]	; (600090fc <z_data_copy+0x44>)
600090ca:	480d      	ldr	r0, [pc, #52]	; (60009100 <z_data_copy+0x48>)
600090cc:	f002 fc41 	bl	6000b952 <memcpy>
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_ccm), okay)
	(void)memcpy(&__ccm_data_start, &__ccm_data_rom_start,
		 __ccm_data_end - __ccm_data_start);
#endif
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_itcm), okay)
	(void)memcpy(&__itcm_start, &__itcm_rom_start,
600090d0:	4a0c      	ldr	r2, [pc, #48]	; (60009104 <z_data_copy+0x4c>)
600090d2:	490d      	ldr	r1, [pc, #52]	; (60009108 <z_data_copy+0x50>)
600090d4:	480d      	ldr	r0, [pc, #52]	; (6000910c <z_data_copy+0x54>)
600090d6:	f002 fc3c 	bl	6000b952 <memcpy>
		 (uintptr_t) &__itcm_size);
#endif
#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_dtcm), okay)
	(void)memcpy(&__dtcm_data_start, &__dtcm_data_rom_start,
		 __dtcm_data_end - __dtcm_data_start);
600090da:	480d      	ldr	r0, [pc, #52]	; (60009110 <z_data_copy+0x58>)
	(void)memcpy(&__dtcm_data_start, &__dtcm_data_rom_start,
600090dc:	4a0d      	ldr	r2, [pc, #52]	; (60009114 <z_data_copy+0x5c>)
600090de:	490e      	ldr	r1, [pc, #56]	; (60009118 <z_data_copy+0x60>)
600090e0:	1a12      	subs	r2, r2, r0
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
600090e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__dtcm_data_start, &__dtcm_data_rom_start,
600090e6:	f002 bc34 	b.w	6000b952 <memcpy>
600090ea:	bf00      	nop
600090ec:	80000000 	.word	0x80000000
600090f0:	800002a8 	.word	0x800002a8
600090f4:	6000ec68 	.word	0x6000ec68
600090f8:	00000000 	.word	0x00000000
600090fc:	6000ec68 	.word	0x6000ec68
60009100:	80000000 	.word	0x80000000
60009104:	00000000 	.word	0x00000000
60009108:	6000ef10 	.word	0x6000ef10
6000910c:	00000000 	.word	0x00000000
60009110:	20000000 	.word	0x20000000
60009114:	200014c0 	.word	0x200014c0
60009118:	6000ef10 	.word	0x6000ef10

6000911c <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
6000911c:	4b03      	ldr	r3, [pc, #12]	; (6000912c <elapsed+0x10>)
6000911e:	681b      	ldr	r3, [r3, #0]
60009120:	b90b      	cbnz	r3, 60009126 <elapsed+0xa>
60009122:	f7fc bf23 	b.w	60005f6c <sys_clock_elapsed>
}
60009126:	2000      	movs	r0, #0
60009128:	4770      	bx	lr
6000912a:	bf00      	nop
6000912c:	80000f30 	.word	0x80000f30

60009130 <next_timeout>:
	return list->head == list;
60009130:	4b11      	ldr	r3, [pc, #68]	; (60009178 <next_timeout+0x48>)

static int32_t next_timeout(void)
{
60009132:	b510      	push	{r4, lr}
60009134:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009136:	429c      	cmp	r4, r3
60009138:	bf08      	it	eq
6000913a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
6000913c:	f7ff ffee 	bl	6000911c <elapsed>
60009140:	4603      	mov	r3, r0
	int32_t ret = to == NULL ? MAX_WAIT
60009142:	b16c      	cbz	r4, 60009160 <next_timeout+0x30>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
60009144:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
60009148:	1ac0      	subs	r0, r0, r3
6000914a:	eb62 73e3 	sbc.w	r3, r2, r3, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
6000914e:	2801      	cmp	r0, #1
60009150:	f173 0200 	sbcs.w	r2, r3, #0
60009154:	db0d      	blt.n	60009172 <next_timeout+0x42>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
60009156:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
6000915a:	f173 0300 	sbcs.w	r3, r3, #0
6000915e:	db01      	blt.n	60009164 <next_timeout+0x34>
	int32_t ret = to == NULL ? MAX_WAIT
60009160:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
60009164:	4b05      	ldr	r3, [pc, #20]	; (6000917c <next_timeout+0x4c>)
60009166:	691b      	ldr	r3, [r3, #16]
60009168:	b113      	cbz	r3, 60009170 <next_timeout+0x40>
6000916a:	4298      	cmp	r0, r3
6000916c:	bfa8      	it	ge
6000916e:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
60009170:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
60009172:	2000      	movs	r0, #0
60009174:	e7f6      	b.n	60009164 <next_timeout+0x34>
60009176:	bf00      	nop
60009178:	80000160 	.word	0x80000160
6000917c:	80000ef4 	.word	0x80000ef4

60009180 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
60009180:	6803      	ldr	r3, [r0, #0]
{
60009182:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
60009184:	b168      	cbz	r0, 600091a2 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
60009186:	4a0a      	ldr	r2, [pc, #40]	; (600091b0 <remove_timeout+0x30>)
60009188:	6852      	ldr	r2, [r2, #4]
6000918a:	4290      	cmp	r0, r2
6000918c:	d009      	beq.n	600091a2 <remove_timeout+0x22>
	if (next(t) != NULL) {
6000918e:	b143      	cbz	r3, 600091a2 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
60009190:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
60009194:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
60009198:	1912      	adds	r2, r2, r4
6000919a:	eb41 0105 	adc.w	r1, r1, r5
6000919e:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
600091a2:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
600091a4:	6013      	str	r3, [r2, #0]
	next->prev = prev;
600091a6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
600091a8:	2300      	movs	r3, #0
	node->prev = NULL;
600091aa:	e9c0 3300 	strd	r3, r3, [r0]
}
600091ae:	bd30      	pop	{r4, r5, pc}
600091b0:	80000160 	.word	0x80000160

600091b4 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
600091b4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
600091b8:	bf08      	it	eq
600091ba:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
600091be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
600091c0:	4604      	mov	r4, r0
600091c2:	461f      	mov	r7, r3
600091c4:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
600091c6:	d067      	beq.n	60009298 <z_add_timeout+0xe4>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
600091c8:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
600091ca:	f04f 0310 	mov.w	r3, #16
600091ce:	f3ef 8611 	mrs	r6, BASEPRI
600091d2:	f383 8811 	msr	BASEPRI, r3
600091d6:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
600091da:	f06f 0201 	mvn.w	r2, #1
600091de:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
600091e2:	1b53      	subs	r3, r2, r5
600091e4:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
600091e8:	2b00      	cmp	r3, #0
600091ea:	db1b      	blt.n	60009224 <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
600091ec:	4b2b      	ldr	r3, [pc, #172]	; (6000929c <z_add_timeout+0xe8>)
600091ee:	e9d3 1300 	ldrd	r1, r3, [r3]
600091f2:	1a52      	subs	r2, r2, r1
600091f4:	eb6c 0303 	sbc.w	r3, ip, r3
600091f8:	1b55      	subs	r5, r2, r5

			to->dticks = MAX(1, ticks);
600091fa:	eb63 0307 	sbc.w	r3, r3, r7
600091fe:	2d01      	cmp	r5, #1
60009200:	f173 0200 	sbcs.w	r2, r3, #0
60009204:	bfbc      	itt	lt
60009206:	2501      	movlt	r5, #1
60009208:	2300      	movlt	r3, #0
6000920a:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
6000920e:	4824      	ldr	r0, [pc, #144]	; (600092a0 <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
60009210:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009214:	4283      	cmp	r3, r0
60009216:	d118      	bne.n	6000924a <z_add_timeout+0x96>
	node->prev = tail;
60009218:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
6000921c:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
60009220:	6044      	str	r4, [r0, #4]
}
60009222:	e026      	b.n	60009272 <z_add_timeout+0xbe>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
60009224:	f7ff ff7a 	bl	6000911c <elapsed>
60009228:	3501      	adds	r5, #1
6000922a:	f147 0700 	adc.w	r7, r7, #0
6000922e:	182d      	adds	r5, r5, r0
60009230:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
60009234:	e9c4 5704 	strd	r5, r7, [r4, #16]
60009238:	e7e9      	b.n	6000920e <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
6000923a:	1a52      	subs	r2, r2, r1
6000923c:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
60009240:	459c      	cmp	ip, r3
60009242:	e9c4 2504 	strd	r2, r5, [r4, #16]
60009246:	d0e7      	beq.n	60009218 <z_add_timeout+0x64>
60009248:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
6000924a:	2b00      	cmp	r3, #0
6000924c:	d0e4      	beq.n	60009218 <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
6000924e:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
60009252:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
60009256:	428a      	cmp	r2, r1
60009258:	eb75 0e07 	sbcs.w	lr, r5, r7
6000925c:	daed      	bge.n	6000923a <z_add_timeout+0x86>
				t->dticks -= to->dticks;
6000925e:	1a8a      	subs	r2, r1, r2
60009260:	eb67 0505 	sbc.w	r5, r7, r5
60009264:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
60009268:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
6000926a:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
6000926e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
60009270:	605c      	str	r4, [r3, #4]
	return list->head == list;
60009272:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009274:	4283      	cmp	r3, r0
60009276:	d00b      	beq.n	60009290 <z_add_timeout+0xdc>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
60009278:	429c      	cmp	r4, r3
6000927a:	d109      	bne.n	60009290 <z_add_timeout+0xdc>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
6000927c:	f7ff ff58 	bl	60009130 <next_timeout>

			if (next_time == 0 ||
60009280:	b118      	cbz	r0, 6000928a <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
60009282:	4b08      	ldr	r3, [pc, #32]	; (600092a4 <z_add_timeout+0xf0>)
			if (next_time == 0 ||
60009284:	691b      	ldr	r3, [r3, #16]
60009286:	4283      	cmp	r3, r0
60009288:	d002      	beq.n	60009290 <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
6000928a:	2100      	movs	r1, #0
6000928c:	f7fc fdfe 	bl	60005e8c <sys_clock_set_timeout>
	__asm__ volatile(
60009290:	f386 8811 	msr	BASEPRI, r6
60009294:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
60009298:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
6000929a:	bf00      	nop
6000929c:	800008e0 	.word	0x800008e0
600092a0:	80000160 	.word	0x80000160
600092a4:	80000ef4 	.word	0x80000ef4

600092a8 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
600092a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
600092ac:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
600092ae:	f7ff fc1d 	bl	60008aec <z_time_slice>
	__asm__ volatile(
600092b2:	f04f 0310 	mov.w	r3, #16
600092b6:	f3ef 8411 	mrs	r4, BASEPRI
600092ba:	f383 8811 	msr	BASEPRI, r3
600092be:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
600092c2:	4e24      	ldr	r6, [pc, #144]	; (60009354 <sys_clock_announce+0xac>)
	return list->head == list;
600092c4:	f8df 8090 	ldr.w	r8, [pc, #144]	; 60009358 <sys_clock_announce+0xb0>
600092c8:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
600092ca:	4d24      	ldr	r5, [pc, #144]	; (6000935c <sys_clock_announce+0xb4>)
600092cc:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
600092d0:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
600092d2:	4540      	cmp	r0, r8
600092d4:	ea4f 77e2 	mov.w	r7, r2, asr #31
		curr_tick += dt;
600092d8:	e9d5 1e00 	ldrd	r1, lr, [r5]
600092dc:	d00b      	beq.n	600092f6 <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
600092de:	b150      	cbz	r0, 600092f6 <sys_clock_announce+0x4e>
600092e0:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
600092e4:	429a      	cmp	r2, r3
600092e6:	eb77 090c 	sbcs.w	r9, r7, ip
600092ea:	da16      	bge.n	6000931a <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
600092ec:	1a9b      	subs	r3, r3, r2
600092ee:	eb6c 0c07 	sbc.w	ip, ip, r7
600092f2:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
600092f6:	1852      	adds	r2, r2, r1
600092f8:	eb4e 0707 	adc.w	r7, lr, r7
600092fc:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
60009300:	2500      	movs	r5, #0
60009302:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
60009304:	f7ff ff14 	bl	60009130 <next_timeout>
60009308:	4629      	mov	r1, r5
6000930a:	f7fc fdbf 	bl	60005e8c <sys_clock_set_timeout>
	__asm__ volatile(
6000930e:	f384 8811 	msr	BASEPRI, r4
60009312:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
60009316:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
6000931a:	1859      	adds	r1, r3, r1
6000931c:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
60009320:	1ad3      	subs	r3, r2, r3
		t->dticks = 0;
60009322:	2200      	movs	r2, #0
		announce_remaining -= dt;
60009324:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
60009326:	2300      	movs	r3, #0
60009328:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
6000932c:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
60009330:	f7ff ff26 	bl	60009180 <remove_timeout>
60009334:	f384 8811 	msr	BASEPRI, r4
60009338:	f3bf 8f6f 	isb	sy
		t->fn(t);
6000933c:	6883      	ldr	r3, [r0, #8]
6000933e:	4798      	blx	r3
	__asm__ volatile(
60009340:	f04f 0310 	mov.w	r3, #16
60009344:	f3ef 8411 	mrs	r4, BASEPRI
60009348:	f383 8811 	msr	BASEPRI, r3
6000934c:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
60009350:	e7bc      	b.n	600092cc <sys_clock_announce+0x24>
60009352:	bf00      	nop
60009354:	80000f30 	.word	0x80000f30
60009358:	80000160 	.word	0x80000160
6000935c:	800008e0 	.word	0x800008e0

60009360 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
60009360:	b510      	push	{r4, lr}
60009362:	f04f 0310 	mov.w	r3, #16
60009366:	f3ef 8411 	mrs	r4, BASEPRI
6000936a:	f383 8811 	msr	BASEPRI, r3
6000936e:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
60009372:	f7fc fdfb 	bl	60005f6c <sys_clock_elapsed>
60009376:	4a05      	ldr	r2, [pc, #20]	; (6000938c <sys_clock_tick_get+0x2c>)
60009378:	e9d2 3100 	ldrd	r3, r1, [r2]
6000937c:	18c0      	adds	r0, r0, r3
6000937e:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
60009382:	f384 8811 	msr	BASEPRI, r4
60009386:	f3bf 8f6f 	isb	sy
	}
	return t;
}
6000938a:	bd10      	pop	{r4, pc}
6000938c:	800008e0 	.word	0x800008e0

60009390 <z_impl_k_busy_wait>:
}
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
60009390:	b538      	push	{r3, r4, r5, lr}
60009392:	4604      	mov	r4, r0
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
60009394:	4601      	mov	r1, r0
60009396:	2022      	movs	r0, #34	; 0x22
60009398:	f7fe f9d0 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
	if (usec_to_wait == 0U) {
6000939c:	b924      	cbnz	r4, 600093a8 <z_impl_k_busy_wait+0x18>
		SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
6000939e:	2022      	movs	r0, #34	; 0x22
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
600093a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
600093a4:	f7fe bb5e 	b.w	60007a64 <SEGGER_SYSVIEW_RecordEndCall>
600093a8:	f7fc fdfe 	bl	60005fa8 <sys_clock_cycle_get_32>
		(uint64_t)usec_to_wait *
600093ac:	4907      	ldr	r1, [pc, #28]	; (600093cc <z_impl_k_busy_wait+0x3c>)
600093ae:	4605      	mov	r5, r0
		(uint64_t)sys_clock_hw_cycles_per_sec() /
600093b0:	4a07      	ldr	r2, [pc, #28]	; (600093d0 <z_impl_k_busy_wait+0x40>)
600093b2:	fba4 0101 	umull	r0, r1, r4, r1
600093b6:	2300      	movs	r3, #0
600093b8:	f7f8 ff82 	bl	600022c0 <__aeabi_uldivmod>
600093bc:	4604      	mov	r4, r0
600093be:	f7fc fdf3 	bl	60005fa8 <sys_clock_cycle_get_32>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
600093c2:	1b43      	subs	r3, r0, r5
600093c4:	42a3      	cmp	r3, r4
600093c6:	d3fa      	bcc.n	600093be <z_impl_k_busy_wait+0x2e>
600093c8:	e7e9      	b.n	6000939e <z_impl_k_busy_wait+0xe>
600093ca:	bf00      	nop
600093cc:	23c34600 	.word	0x23c34600
600093d0:	000f4240 	.word	0x000f4240

600093d4 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
600093d4:	b538      	push	{r3, r4, r5, lr}

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
600093d6:	e9d0 320a 	ldrd	r3, r2, [r0, #40]	; 0x28
{
600093da:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
600093dc:	3301      	adds	r3, #1
600093de:	f142 0200 	adc.w	r2, r2, #0
600093e2:	2b02      	cmp	r3, #2
600093e4:	f172 0300 	sbcs.w	r3, r2, #0
600093e8:	d304      	bcc.n	600093f4 <z_timer_expiration_handler+0x20>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
600093ea:	490e      	ldr	r1, [pc, #56]	; (60009424 <z_timer_expiration_handler+0x50>)
600093ec:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
600093f0:	f7ff fee0 	bl	600091b4 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
600093f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
600093f6:	3301      	adds	r3, #1
600093f8:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
600093fa:	6a23      	ldr	r3, [r4, #32]
600093fc:	b10b      	cbz	r3, 60009402 <z_timer_expiration_handler+0x2e>
		timer->expiry_fn(timer);
600093fe:	4620      	mov	r0, r4
60009400:	4798      	blx	r3
	return list->head == list;
60009402:	f854 5f18 	ldr.w	r5, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
60009406:	42a5      	cmp	r5, r4
60009408:	d00b      	beq.n	60009422 <z_timer_expiration_handler+0x4e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
6000940a:	b155      	cbz	r5, 60009422 <z_timer_expiration_handler+0x4e>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
6000940c:	4628      	mov	r0, r5
6000940e:	f002 ffda 	bl	6000c3c6 <z_unpend_thread_no_timeout>
60009412:	2300      	movs	r3, #0

	arch_thread_return_value_set(thread, 0);

	z_ready_thread(thread);
60009414:	4628      	mov	r0, r5
60009416:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
}
6000941a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_ready_thread(thread);
6000941e:	f002 bfc2 	b.w	6000c3a6 <z_ready_thread>
}
60009422:	bd38      	pop	{r3, r4, r5, pc}
60009424:	600093d5 	.word	0x600093d5

60009428 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
60009428:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
6000942c:	461f      	mov	r7, r3
6000942e:	4615      	mov	r5, r2
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);
60009430:	4601      	mov	r1, r0
{
60009432:	4606      	mov	r6, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);
60009434:	2058      	movs	r0, #88	; 0x58
60009436:	4692      	mov	sl, r2
60009438:	46b9      	mov	r9, r7
{
6000943a:	e9dd 3b0c 	ldrd	r3, fp, [sp, #48]	; 0x30
6000943e:	461c      	mov	r4, r3
60009440:	9301      	str	r3, [sp, #4]
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);
60009442:	f7fe f97b 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
60009446:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
6000944a:	bf08      	it	eq
6000944c:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
60009450:	46d8      	mov	r8, fp
60009452:	d03f      	beq.n	600094d4 <z_impl_k_timer_start+0xac>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
60009454:	9b01      	ldr	r3, [sp, #4]
60009456:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
6000945a:	bf08      	it	eq
6000945c:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
60009460:	d015      	beq.n	6000948e <z_impl_k_timer_start+0x66>
60009462:	ea5b 0303 	orrs.w	r3, fp, r3
60009466:	d012      	beq.n	6000948e <z_impl_k_timer_start+0x66>
	    Z_TICK_ABS(period.ticks) < 0) {
60009468:	f06f 0301 	mvn.w	r3, #1
6000946c:	1b1b      	subs	r3, r3, r4
6000946e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60009472:	eb63 030b 	sbc.w	r3, r3, fp
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
60009476:	2b00      	cmp	r3, #0
60009478:	da09      	bge.n	6000948e <z_impl_k_timer_start+0x66>
		period.ticks = MAX(period.ticks - 1, 1);
6000947a:	3c01      	subs	r4, #1
6000947c:	f16b 0800 	sbc.w	r8, fp, #0
60009480:	2c01      	cmp	r4, #1
60009482:	f178 0300 	sbcs.w	r3, r8, #0
60009486:	bfbc      	itt	lt
60009488:	2401      	movlt	r4, #1
6000948a:	f04f 0800 	movlt.w	r8, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
6000948e:	f06f 0301 	mvn.w	r3, #1
60009492:	1b5b      	subs	r3, r3, r5
60009494:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60009498:	eb63 0307 	sbc.w	r3, r3, r7
6000949c:	2b00      	cmp	r3, #0
6000949e:	da09      	bge.n	600094b4 <z_impl_k_timer_start+0x8c>
		duration.ticks = MAX(duration.ticks - 1, 0);
600094a0:	1e6a      	subs	r2, r5, #1
600094a2:	f167 0900 	sbc.w	r9, r7, #0
600094a6:	4692      	mov	sl, r2
600094a8:	f1b9 0f00 	cmp.w	r9, #0
600094ac:	bfbc      	itt	lt
600094ae:	f04f 0a00 	movlt.w	sl, #0
600094b2:	46d1      	movlt	r9, sl
	}

	(void)z_abort_timeout(&timer->timeout);
600094b4:	4630      	mov	r0, r6
600094b6:	f003 f811 	bl	6000c4dc <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
600094ba:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
600094bc:	4652      	mov	r2, sl
600094be:	4907      	ldr	r1, [pc, #28]	; (600094dc <z_impl_k_timer_start+0xb4>)
	timer->status = 0U;
600094c0:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
600094c2:	4630      	mov	r0, r6
600094c4:	464b      	mov	r3, r9
	timer->period = period;
600094c6:	e9c6 480a 	strd	r4, r8, [r6, #40]	; 0x28
		     duration);
}
600094ca:	b003      	add	sp, #12
600094cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
600094d0:	f7ff be70 	b.w	600091b4 <z_add_timeout>
}
600094d4:	b003      	add	sp, #12
600094d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
600094da:	bf00      	nop
600094dc:	600093d5 	.word	0x600093d5

600094e0 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
600094e0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
600094e4:	461d      	mov	r5, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
600094e6:	4b29      	ldr	r3, [pc, #164]	; (6000958c <z_impl_k_poll+0xac>)
{
600094e8:	4616      	mov	r6, r2
600094ea:	4680      	mov	r8, r0
	struct z_poller *poller = &_current->poller;
600094ec:	689f      	ldr	r7, [r3, #8]

	poller->is_polling = true;
600094ee:	2301      	movs	r3, #1
600094f0:	f887 3068 	strb.w	r3, [r7, #104]	; 0x68
	poller->mode = MODE_POLL;
600094f4:	f887 3069 	strb.w	r3, [r7, #105]	; 0x69
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
600094f8:	ea52 0305 	orrs.w	r3, r2, r5
600094fc:	f107 0268 	add.w	r2, r7, #104	; 0x68
60009500:	bf0c      	ite	eq
60009502:	2301      	moveq	r3, #1
60009504:	2300      	movne	r3, #0
60009506:	f003 f896 	bl	6000c636 <register_events>
6000950a:	4681      	mov	r9, r0
	__asm__ volatile(
6000950c:	f04f 0310 	mov.w	r3, #16
60009510:	f3ef 8a11 	mrs	sl, BASEPRI
60009514:	f383 8811 	msr	BASEPRI, r3
60009518:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
6000951c:	f897 4068 	ldrb.w	r4, [r7, #104]	; 0x68
60009520:	b964      	cbnz	r4, 6000953c <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
60009522:	4601      	mov	r1, r0
60009524:	4652      	mov	r2, sl
60009526:	4640      	mov	r0, r8
60009528:	f003 f956 	bl	6000c7d8 <clear_event_registrations>
	__asm__ volatile(
6000952c:	f38a 8811 	msr	BASEPRI, sl
60009530:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
60009534:	4620      	mov	r0, r4
60009536:	b002      	add	sp, #8
60009538:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
6000953c:	2300      	movs	r3, #0
6000953e:	f887 3068 	strb.w	r3, [r7, #104]	; 0x68
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
60009542:	ea56 0305 	orrs.w	r3, r6, r5
60009546:	d106      	bne.n	60009556 <z_impl_k_poll+0x76>
60009548:	f38a 8811 	msr	BASEPRI, sl
6000954c:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
60009550:	f06f 040a 	mvn.w	r4, #10
60009554:	e7ee      	b.n	60009534 <z_impl_k_poll+0x54>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
60009556:	4a0e      	ldr	r2, [pc, #56]	; (60009590 <z_impl_k_poll+0xb0>)
60009558:	4651      	mov	r1, sl
6000955a:	480e      	ldr	r0, [pc, #56]	; (60009594 <z_impl_k_poll+0xb4>)
6000955c:	e9cd 6500 	strd	r6, r5, [sp]
60009560:	f7ff fb04 	bl	60008b6c <z_pend_curr>
60009564:	4604      	mov	r4, r0
	__asm__ volatile(
60009566:	f04f 0310 	mov.w	r3, #16
6000956a:	f3ef 8511 	mrs	r5, BASEPRI
6000956e:	f383 8811 	msr	BASEPRI, r3
60009572:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
60009576:	462a      	mov	r2, r5
60009578:	4649      	mov	r1, r9
6000957a:	4640      	mov	r0, r8
6000957c:	f003 f92c 	bl	6000c7d8 <clear_event_registrations>
	__asm__ volatile(
60009580:	f385 8811 	msr	BASEPRI, r5
60009584:	f3bf 8f6f 	isb	sy
	return swap_rc;
60009588:	e7d4      	b.n	60009534 <z_impl_k_poll+0x54>
6000958a:	bf00      	nop
6000958c:	80000ef4 	.word	0x80000ef4
60009590:	80000168 	.word	0x80000168
60009594:	8000109d 	.word	0x8000109d

60009598 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
60009598:	b538      	push	{r3, r4, r5, lr}
6000959a:	4603      	mov	r3, r0
	__asm__ volatile(
6000959c:	f04f 0210 	mov.w	r2, #16
600095a0:	f3ef 8511 	mrs	r5, BASEPRI
600095a4:	f382 8811 	msr	BASEPRI, r2
600095a8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
600095ac:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
600095ae:	2101      	movs	r1, #1
600095b0:	6081      	str	r1, [r0, #8]
	return list->head == list;
600095b2:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
600095b4:	4283      	cmp	r3, r0
600095b6:	d106      	bne.n	600095c6 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
600095b8:	f385 8811 	msr	BASEPRI, r5
600095bc:	f3bf 8f6f 	isb	sy
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
600095c0:	2400      	movs	r4, #0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
	return rc;
}
600095c2:	4620      	mov	r0, r4
600095c4:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const next = node->next;
600095c6:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
600095ca:	6013      	str	r3, [r2, #0]
	next->prev = prev;
600095cc:	605a      	str	r2, [r3, #4]
	node->next = NULL;
600095ce:	2300      	movs	r3, #0
	node->prev = NULL;
600095d0:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
600095d4:	f003 f8a6 	bl	6000c724 <signal_poll_event>
	z_reschedule(&lock, key);
600095d8:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
600095da:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
600095dc:	4801      	ldr	r0, [pc, #4]	; (600095e4 <z_impl_k_poll_signal_raise+0x4c>)
600095de:	f7ff fb2d 	bl	60008c3c <z_reschedule>
	return rc;
600095e2:	e7ee      	b.n	600095c2 <z_impl_k_poll_signal_raise+0x2a>
600095e4:	8000109d 	.word	0x8000109d

600095e8 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
600095e8:	4a02      	ldr	r2, [pc, #8]	; (600095f4 <boot_banner+0xc>)
600095ea:	4903      	ldr	r1, [pc, #12]	; (600095f8 <boot_banner+0x10>)
600095ec:	4803      	ldr	r0, [pc, #12]	; (600095fc <boot_banner+0x14>)
600095ee:	f000 b972 	b.w	600098d6 <printk>
600095f2:	bf00      	nop
600095f4:	6000dc95 	.word	0x6000dc95
600095f8:	6000ec28 	.word	0x6000ec28
600095fc:	6000ec36 	.word	0x6000ec36

60009600 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
60009600:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
60009602:	4c06      	ldr	r4, [pc, #24]	; (6000961c <statics_init+0x1c>)
60009604:	4d06      	ldr	r5, [pc, #24]	; (60009620 <statics_init+0x20>)
60009606:	42ac      	cmp	r4, r5
60009608:	d301      	bcc.n	6000960e <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
6000960a:	2000      	movs	r0, #0
6000960c:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
6000960e:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
60009612:	4620      	mov	r0, r4
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
60009614:	3414      	adds	r4, #20
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
60009616:	f003 f938 	bl	6000c88a <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
6000961a:	e7f4      	b.n	60009606 <statics_init+0x6>
6000961c:	8000024c 	.word	0x8000024c
60009620:	8000024c 	.word	0x8000024c

60009624 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
60009624:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
60009626:	4b09      	ldr	r3, [pc, #36]	; (6000964c <k_sys_work_q_init+0x28>)
60009628:	2400      	movs	r4, #0
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
6000962a:	f44f 6280 	mov.w	r2, #1024	; 0x400
6000962e:	4908      	ldr	r1, [pc, #32]	; (60009650 <k_sys_work_q_init+0x2c>)
	struct k_work_queue_config cfg = {
60009630:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
60009632:	ab02      	add	r3, sp, #8
60009634:	4807      	ldr	r0, [pc, #28]	; (60009654 <k_sys_work_q_init+0x30>)
60009636:	9300      	str	r3, [sp, #0]
60009638:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	struct k_work_queue_config cfg = {
6000963c:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
60009640:	f000 f8ee 	bl	60009820 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
60009644:	4620      	mov	r0, r4
60009646:	b004      	add	sp, #16
60009648:	bd10      	pop	{r4, pc}
6000964a:	bf00      	nop
6000964c:	6000ec5d 	.word	0x6000ec5d
60009650:	80003a00 	.word	0x80003a00
60009654:	800008e8 	.word	0x800008e8

60009658 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
60009658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
6000965c:	4604      	mov	r4, r0
6000965e:	b085      	sub	sp, #20
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
60009660:	4e46      	ldr	r6, [pc, #280]	; (6000977c <work_queue_main+0x124>)
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
60009662:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
60009666:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	__asm__ volatile(
6000966a:	f04f 0310 	mov.w	r3, #16
6000966e:	f3ef 8711 	mrs	r7, BASEPRI
60009672:	f383 8811 	msr	BASEPRI, r3
60009676:	f3bf 8f6f 	isb	sy
6000967a:	f8d4 50c0 	ldr.w	r5, [r4, #192]	; 0xc0
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
6000967e:	b98d      	cbnz	r5, 600096a4 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
60009680:	2102      	movs	r1, #2
60009682:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
60009686:	f003 f90e 	bl	6000c8a6 <flag_test_and_clear>
6000968a:	2800      	cmp	r0, #0
6000968c:	d135      	bne.n	600096fa <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
6000968e:	2300      	movs	r3, #0
60009690:	f104 02c8 	add.w	r2, r4, #200	; 0xc8
60009694:	4639      	mov	r1, r7
60009696:	483a      	ldr	r0, [pc, #232]	; (60009780 <work_queue_main+0x128>)
60009698:	9302      	str	r3, [sp, #8]
6000969a:	e9cd 8900 	strd	r8, r9, [sp]
6000969e:	f7ff fcf9 	bl	60009094 <z_sched_wait>
			continue;
600096a2:	e7e2      	b.n	6000966a <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
600096a4:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
	return node->next;
600096a8:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
600096aa:	4295      	cmp	r5, r2
	list->head = node;
600096ac:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
600096b0:	d101      	bne.n	600096b6 <work_queue_main+0x5e>
	list->tail = node;
600096b2:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	*flagp |= BIT(bit);
600096b6:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
600096ba:	f043 0302 	orr.w	r3, r3, #2
600096be:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
	*flagp &= ~BIT(bit);
600096c2:	68eb      	ldr	r3, [r5, #12]
600096c4:	f023 0304 	bic.w	r3, r3, #4
600096c8:	f043 0301 	orr.w	r3, r3, #1
600096cc:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
600096ce:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
600096d0:	f387 8811 	msr	BASEPRI, r7
600096d4:	f3bf 8f6f 	isb	sy

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
			handler(work);
600096d8:	4628      	mov	r0, r5
600096da:	4798      	blx	r3
	__asm__ volatile(
600096dc:	f04f 0310 	mov.w	r3, #16
600096e0:	f3ef 8b11 	mrs	fp, BASEPRI
600096e4:	f383 8811 	msr	BASEPRI, r3
600096e8:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
600096ec:	68eb      	ldr	r3, [r5, #12]
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
600096ee:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
600096f0:	f023 0201 	bic.w	r2, r3, #1
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
600096f4:	d40b      	bmi.n	6000970e <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
600096f6:	60ea      	str	r2, [r5, #12]
600096f8:	e00e      	b.n	60009718 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
600096fa:	f104 05d0 	add.w	r5, r4, #208	; 0xd0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
600096fe:	2200      	movs	r2, #0
60009700:	2101      	movs	r1, #1
60009702:	4628      	mov	r0, r5
60009704:	f002 fecc 	bl	6000c4a0 <z_sched_wake>
60009708:	2800      	cmp	r0, #0
6000970a:	d1f8      	bne.n	600096fe <work_queue_main+0xa6>
6000970c:	e7bf      	b.n	6000968e <work_queue_main+0x36>
	*flagp &= ~BIT(bit);
6000970e:	f023 0303 	bic.w	r3, r3, #3
	return list->head;
60009712:	6830      	ldr	r0, [r6, #0]
60009714:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
60009716:	b970      	cbnz	r0, 60009736 <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
60009718:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
6000971c:	f023 0302 	bic.w	r3, r3, #2
60009720:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
	__asm__ volatile(
60009724:	f38b 8811 	msr	BASEPRI, fp
60009728:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
6000972c:	05d8      	lsls	r0, r3, #23
6000972e:	d49c      	bmi.n	6000966a <work_queue_main+0x12>
	z_impl_k_yield();
60009730:	f7ff fb2c 	bl	60008d8c <z_impl_k_yield>
}
60009734:	e799      	b.n	6000966a <work_queue_main+0x12>
	return node->next;
60009736:	2700      	movs	r7, #0
60009738:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
6000973c:	463b      	mov	r3, r7
		if (wc->work == work) {
6000973e:	6842      	ldr	r2, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
60009740:	4601      	mov	r1, r0
		if (wc->work == work) {
60009742:	4295      	cmp	r5, r2
60009744:	d10c      	bne.n	60009760 <work_queue_main+0x108>
	return node->next;
60009746:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
60009748:	b997      	cbnz	r7, 60009770 <work_queue_main+0x118>
6000974a:	6872      	ldr	r2, [r6, #4]
	list->head = node;
6000974c:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
6000974e:	4282      	cmp	r2, r0
60009750:	d100      	bne.n	60009754 <work_queue_main+0xfc>
	list->tail = node;
60009752:	6071      	str	r1, [r6, #4]
	parent->next = child;
60009754:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
60009758:	f7ff f84a 	bl	600087f0 <z_impl_k_sem_give>
}
6000975c:	4639      	mov	r1, r7
6000975e:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
60009760:	f1ba 0f00 	cmp.w	sl, #0
60009764:	d0d8      	beq.n	60009718 <work_queue_main+0xc0>
	return node->next;
60009766:	4650      	mov	r0, sl
60009768:	460f      	mov	r7, r1
6000976a:	f8da a000 	ldr.w	sl, [sl]
6000976e:	e7e6      	b.n	6000973e <work_queue_main+0xe6>
	return list->tail;
60009770:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
60009772:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
60009774:	4290      	cmp	r0, r2
	list->tail = node;
60009776:	bf08      	it	eq
60009778:	6077      	streq	r7, [r6, #4]
}
6000977a:	e7eb      	b.n	60009754 <work_queue_main+0xfc>
6000977c:	80000f34 	.word	0x80000f34
60009780:	8000109d 	.word	0x8000109d

60009784 <submit_to_queue_locked>:
{
60009784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
60009786:	68c3      	ldr	r3, [r0, #12]
{
60009788:	4604      	mov	r4, r0
6000978a:	460e      	mov	r6, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
6000978c:	079a      	lsls	r2, r3, #30
6000978e:	f3c3 0540 	ubfx	r5, r3, #1, #1
60009792:	d41e      	bmi.n	600097d2 <submit_to_queue_locked+0x4e>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
60009794:	075f      	lsls	r7, r3, #29
60009796:	d41e      	bmi.n	600097d6 <submit_to_queue_locked+0x52>
		if (*queuep == NULL) {
60009798:	680a      	ldr	r2, [r1, #0]
6000979a:	b90a      	cbnz	r2, 600097a0 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
6000979c:	6882      	ldr	r2, [r0, #8]
6000979e:	600a      	str	r2, [r1, #0]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
600097a0:	07d8      	lsls	r0, r3, #31
			*queuep = work->queue;
600097a2:	bf45      	ittet	mi
600097a4:	68a3      	ldrmi	r3, [r4, #8]
			ret = 2;
600097a6:	2502      	movmi	r5, #2
		ret = 1;
600097a8:	2501      	movpl	r5, #1
			*queuep = work->queue;
600097aa:	6033      	strmi	r3, [r6, #0]
		int rc = queue_submit_locked(*queuep, work);
600097ac:	6837      	ldr	r7, [r6, #0]
	if (queue == NULL) {
600097ae:	b37f      	cbz	r7, 60009810 <submit_to_queue_locked+0x8c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
600097b0:	4b1a      	ldr	r3, [pc, #104]	; (6000981c <submit_to_queue_locked+0x98>)
600097b2:	689b      	ldr	r3, [r3, #8]
600097b4:	42bb      	cmp	r3, r7
600097b6:	d111      	bne.n	600097dc <submit_to_queue_locked+0x58>
600097b8:	f002 fd0d 	bl	6000c1d6 <k_is_in_isr>
600097bc:	f080 0001 	eor.w	r0, r0, #1
600097c0:	b2c0      	uxtb	r0, r0
	return (*flagp & BIT(bit)) != 0U;
600097c2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
600097c6:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
600097c8:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
600097cc:	d523      	bpl.n	60009816 <submit_to_queue_locked+0x92>
	} else if (draining && !chained) {
600097ce:	b13a      	cbz	r2, 600097e0 <submit_to_queue_locked+0x5c>
600097d0:	b940      	cbnz	r0, 600097e4 <submit_to_queue_locked+0x60>
		ret = -EBUSY;
600097d2:	f06f 050f 	mvn.w	r5, #15
		*queuep = NULL;
600097d6:	2300      	movs	r3, #0
600097d8:	6033      	str	r3, [r6, #0]
	return ret;
600097da:	e013      	b.n	60009804 <submit_to_queue_locked+0x80>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
600097dc:	2000      	movs	r0, #0
600097de:	e7f0      	b.n	600097c2 <submit_to_queue_locked+0x3e>
	} else if (plugged && !draining) {
600097e0:	071b      	lsls	r3, r3, #28
600097e2:	d4f6      	bmi.n	600097d2 <submit_to_queue_locked+0x4e>
	parent->next = child;
600097e4:	2300      	movs	r3, #0
600097e6:	6023      	str	r3, [r4, #0]
	return list->tail;
600097e8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
Z_GENLIST_APPEND(slist, snode)
600097ec:	b963      	cbnz	r3, 60009808 <submit_to_queue_locked+0x84>
	list->head = node;
600097ee:	e9c7 4430 	strd	r4, r4, [r7, #192]	; 0xc0
		(void)notify_queue_locked(queue);
600097f2:	4638      	mov	r0, r7
600097f4:	f003 f862 	bl	6000c8bc <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
600097f8:	68e3      	ldr	r3, [r4, #12]
600097fa:	f043 0304 	orr.w	r3, r3, #4
600097fe:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
60009800:	6833      	ldr	r3, [r6, #0]
60009802:	60a3      	str	r3, [r4, #8]
}
60009804:	4628      	mov	r0, r5
60009806:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
60009808:	601c      	str	r4, [r3, #0]
	list->tail = node;
6000980a:	f8c7 40c4 	str.w	r4, [r7, #196]	; 0xc4
}
6000980e:	e7f0      	b.n	600097f2 <submit_to_queue_locked+0x6e>
		return -EINVAL;
60009810:	f06f 0515 	mvn.w	r5, #21
60009814:	e7df      	b.n	600097d6 <submit_to_queue_locked+0x52>
		ret = -ENODEV;
60009816:	f06f 0512 	mvn.w	r5, #18
6000981a:	e7dc      	b.n	600097d6 <submit_to_queue_locked+0x52>
6000981c:	80000ef4 	.word	0x80000ef4

60009820 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
60009820:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60009824:	b088      	sub	sp, #32
60009826:	4604      	mov	r4, r0
60009828:	460e      	mov	r6, r1
	__ASSERT_NO_MSG(queue);
	__ASSERT_NO_MSG(stack);
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
	uint32_t flags = K_WORK_QUEUE_STARTED;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_queue, start, queue);
6000982a:	4601      	mov	r1, r0
6000982c:	207e      	movs	r0, #126	; 0x7e
{
6000982e:	4698      	mov	r8, r3
60009830:	4617      	mov	r7, r2
60009832:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work_queue, start, queue);
60009834:	f7fd ff82 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
	list->head = NULL;
60009838:	2300      	movs	r3, #0
	list->tail = NULL;
6000983a:	e9c4 3330 	strd	r3, r3, [r4, #192]	; 0xc0
	sys_dlist_init(&w->waitq);
6000983e:	f104 03c8 	add.w	r3, r4, #200	; 0xc8
	list->tail = (sys_dnode_t *)list;
60009842:	e9c4 3332 	strd	r3, r3, [r4, #200]	; 0xc8
60009846:	f104 03d0 	add.w	r3, r4, #208	; 0xd0
6000984a:	e9c4 3334 	strd	r3, r3, [r4, #208]	; 0xd0

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
6000984e:	b345      	cbz	r5, 600098a2 <k_work_queue_start+0x82>
60009850:	792b      	ldrb	r3, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
60009852:	f240 1001 	movw	r0, #257	; 0x101
60009856:	2b00      	cmp	r3, #0
60009858:	bf08      	it	eq
6000985a:	2001      	moveq	r0, #1
	*flagp = flags;
6000985c:	f8c4 00d8 	str.w	r0, [r4, #216]	; 0xd8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
60009860:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
60009864:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
60009868:	4631      	mov	r1, r6
6000986a:	4620      	mov	r0, r4
6000986c:	9400      	str	r4, [sp, #0]
6000986e:	e9cd 2306 	strd	r2, r3, [sp, #24]
60009872:	2200      	movs	r2, #0
60009874:	4b0c      	ldr	r3, [pc, #48]	; (600098a8 <k_work_queue_start+0x88>)
60009876:	e9cd 8203 	strd	r8, r2, [sp, #12]
6000987a:	e9cd 2201 	strd	r2, r2, [sp, #4]
6000987e:	463a      	mov	r2, r7
60009880:	f7fe fdae 	bl	600083e0 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
60009884:	b125      	cbz	r5, 60009890 <k_work_queue_start+0x70>
60009886:	6829      	ldr	r1, [r5, #0]
60009888:	b111      	cbz	r1, 60009890 <k_work_queue_start+0x70>
	return z_impl_k_thread_name_set(thread, str);
6000988a:	4620      	mov	r0, r4
6000988c:	f7fe fce4 	bl	60008258 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
60009890:	4620      	mov	r0, r4
60009892:	f002 fca8 	bl	6000c1e6 <z_impl_k_thread_start>
		k_thread_name_set(&queue->thread, cfg->name);
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
60009896:	207e      	movs	r0, #126	; 0x7e
}
60009898:	b008      	add	sp, #32
6000989a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
6000989e:	f7fe b8e1 	b.w	60007a64 <SEGGER_SYSVIEW_RecordEndCall>
	uint32_t flags = K_WORK_QUEUE_STARTED;
600098a2:	2001      	movs	r0, #1
600098a4:	e7da      	b.n	6000985c <k_work_queue_start+0x3c>
600098a6:	bf00      	nop
600098a8:	60009659 	.word	0x60009659

600098ac <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
600098ac:	4770      	bx	lr

600098ae <arch_printk_char_out>:
}
600098ae:	2000      	movs	r0, #0
600098b0:	4770      	bx	lr

600098b2 <str_out>:
{
600098b2:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
600098b4:	688a      	ldr	r2, [r1, #8]
600098b6:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
600098b8:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
600098ba:	b114      	cbz	r4, 600098c2 <str_out+0x10>
600098bc:	684b      	ldr	r3, [r1, #4]
600098be:	4293      	cmp	r3, r2
600098c0:	dc01      	bgt.n	600098c6 <str_out+0x14>
		ctx->count++;
600098c2:	608d      	str	r5, [r1, #8]
}
600098c4:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
600098c6:	3b01      	subs	r3, #1
		ctx->str[ctx->count++] = '\0';
600098c8:	608d      	str	r5, [r1, #8]
	if (ctx->count == ctx->max - 1) {
600098ca:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
600098cc:	bf0a      	itet	eq
600098ce:	2200      	moveq	r2, #0
		ctx->str[ctx->count++] = c;
600098d0:	54a0      	strbne	r0, [r4, r2]
		ctx->str[ctx->count++] = '\0';
600098d2:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
600098d4:	e7f6      	b.n	600098c4 <str_out+0x12>

600098d6 <printk>:
{
600098d6:	b40f      	push	{r0, r1, r2, r3}
600098d8:	b507      	push	{r0, r1, r2, lr}
600098da:	a904      	add	r1, sp, #16
600098dc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
600098e0:	9101      	str	r1, [sp, #4]
	z_log_printk(fmt, ap);
600098e2:	f000 fbeb 	bl	6000a0bc <z_log_printk>
}
600098e6:	b003      	add	sp, #12
600098e8:	f85d eb04 	ldr.w	lr, [sp], #4
600098ec:	b004      	add	sp, #16
600098ee:	4770      	bx	lr

600098f0 <snprintk>:
{
600098f0:	b40c      	push	{r2, r3}
600098f2:	b507      	push	{r0, r1, r2, lr}
600098f4:	ab04      	add	r3, sp, #16
600098f6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
600098fa:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
600098fc:	f7f8 ff54 	bl	600027a8 <vsnprintk>
}
60009900:	b003      	add	sp, #12
60009902:	f85d eb04 	ldr.w	lr, [sp], #4
60009906:	b002      	add	sp, #8
60009908:	4770      	bx	lr

6000990a <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
6000990a:	4604      	mov	r4, r0
6000990c:	4608      	mov	r0, r1
6000990e:	4611      	mov	r1, r2
	entry(p1, p2, p3);
60009910:	461a      	mov	r2, r3
{
60009912:	b508      	push	{r3, lr}
	entry(p1, p2, p3);
60009914:	47a0      	blx	r4
	return z_impl_k_current_get();
60009916:	f7ff faf9 	bl	60008f0c <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
6000991a:	f7fc ffd9 	bl	600068d0 <z_impl_k_thread_abort>

6000991e <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
6000991e:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
60009920:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
60009924:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((uint32_t *)cmem)[f];
60009928:	bf2c      	ite	cs
6000992a:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((uint16_t *)cmem)[f];
6000992e:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
60009932:	4770      	bx	lr

60009934 <chunk_set>:
			     enum chunk_fields f, chunkid_t val)
{
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
60009934:	eb00 01c1 	add.w	r1, r0, r1, lsl #3

	if (big_heap(h)) {
60009938:	6880      	ldr	r0, [r0, #8]
6000993a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
6000993e:	bf2c      	ite	cs
60009940:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
60009944:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
60009948:	4770      	bx	lr

6000994a <chunk_size>:
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
6000994a:	2201      	movs	r2, #1
{
6000994c:	b508      	push	{r3, lr}
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
6000994e:	f7ff ffe6 	bl	6000991e <chunk_field>
}
60009952:	40d0      	lsrs	r0, r2
60009954:	bd08      	pop	{r3, pc}

60009956 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
60009956:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
60009958:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
6000995c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
60009960:	d308      	bcc.n	60009974 <set_chunk_used+0x1e>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
60009962:	684b      	ldr	r3, [r1, #4]
		if (used) {
60009964:	b11a      	cbz	r2, 6000996e <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
60009966:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
6000996a:	604b      	str	r3, [r1, #4]
6000996c:	4770      	bx	lr
6000996e:	f023 0301 	bic.w	r3, r3, #1
60009972:	e7fa      	b.n	6000996a <set_chunk_used+0x14>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
60009974:	884b      	ldrh	r3, [r1, #2]
		if (used) {
60009976:	b11a      	cbz	r2, 60009980 <set_chunk_used+0x2a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
60009978:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
6000997c:	804b      	strh	r3, [r1, #2]
		}
	}
}
6000997e:	4770      	bx	lr
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
60009980:	f023 0301 	bic.w	r3, r3, #1
60009984:	e7fa      	b.n	6000997c <set_chunk_used+0x26>

60009986 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
60009986:	0053      	lsls	r3, r2, #1
60009988:	2201      	movs	r2, #1
6000998a:	f7ff bfd3 	b.w	60009934 <chunk_set>

6000998e <bucket_idx.isra.0>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
6000998e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
60009992:	f101 0101 	add.w	r1, r1, #1
	return big_heap(h) ? 8 : 4;
60009996:	bf2c      	ite	cs
60009998:	2008      	movcs	r0, #8
6000999a:	2004      	movcc	r0, #4
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
6000999c:	3008      	adds	r0, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
6000999e:	eba1 00d0 	sub.w	r0, r1, r0, lsr #3
	return 31 - __builtin_clz(usable_sz);
600099a2:	fab0 f080 	clz	r0, r0
}
600099a6:	f1c0 001f 	rsb	r0, r0, #31
600099aa:	4770      	bx	lr

600099ac <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
600099ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return big_heap_chunks(h->end_chunk);
600099b0:	6886      	ldr	r6, [r0, #8]
600099b2:	460d      	mov	r5, r1
600099b4:	4604      	mov	r4, r0
	return big_heap(h) && chunk_size(h, c) == 1U;
600099b6:	f7ff ffc8 	bl	6000994a <chunk_size>
600099ba:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
600099be:	4601      	mov	r1, r0
600099c0:	d301      	bcc.n	600099c6 <free_list_add+0x1a>
	if (!solo_free_header(h, c)) {
600099c2:	2801      	cmp	r0, #1
600099c4:	d033      	beq.n	60009a2e <free_list_add+0x82>
		int bidx = bucket_idx(h, chunk_size(h, c));
600099c6:	4630      	mov	r0, r6
600099c8:	f7ff ffe1 	bl	6000998e <bucket_idx.isra.0>
	if (b->next == 0U) {
600099cc:	eb04 0280 	add.w	r2, r4, r0, lsl #2
600099d0:	6916      	ldr	r6, [r2, #16]
600099d2:	b99e      	cbnz	r6, 600099fc <free_list_add+0x50>
		h->avail_buckets |= (1 << bidx);
600099d4:	2301      	movs	r3, #1
	chunk_set(h, c, FREE_PREV, prev);
600099d6:	4629      	mov	r1, r5
600099d8:	fa03 f000 	lsl.w	r0, r3, r0
600099dc:	68e3      	ldr	r3, [r4, #12]
600099de:	4303      	orrs	r3, r0
600099e0:	4620      	mov	r0, r4
600099e2:	60e3      	str	r3, [r4, #12]
600099e4:	462b      	mov	r3, r5
		b->next = c;
600099e6:	6115      	str	r5, [r2, #16]
600099e8:	2202      	movs	r2, #2
600099ea:	f7ff ffa3 	bl	60009934 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
600099ee:	2203      	movs	r2, #3
600099f0:	4629      	mov	r1, r5
	chunk_set(h, c, FREE_PREV, prev);
600099f2:	4620      	mov	r0, r4
		free_list_add_bidx(h, c, bidx);
	}
}
600099f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
600099f8:	f7ff bf9c 	b.w	60009934 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
600099fc:	2202      	movs	r2, #2
600099fe:	4631      	mov	r1, r6
60009a00:	4620      	mov	r0, r4
60009a02:	f7ff ff8c 	bl	6000991e <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
60009a06:	4629      	mov	r1, r5
60009a08:	4603      	mov	r3, r0
	return chunk_field(h, c, FREE_PREV);
60009a0a:	4607      	mov	r7, r0
	chunk_set(h, c, FREE_PREV, prev);
60009a0c:	4620      	mov	r0, r4
60009a0e:	f7ff ff91 	bl	60009934 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
60009a12:	2203      	movs	r2, #3
60009a14:	4633      	mov	r3, r6
60009a16:	4629      	mov	r1, r5
60009a18:	4620      	mov	r0, r4
60009a1a:	f7ff ff8b 	bl	60009934 <chunk_set>
60009a1e:	4639      	mov	r1, r7
60009a20:	462b      	mov	r3, r5
60009a22:	4620      	mov	r0, r4
60009a24:	f7ff ff86 	bl	60009934 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
60009a28:	2202      	movs	r2, #2
60009a2a:	4631      	mov	r1, r6
60009a2c:	e7e1      	b.n	600099f2 <free_list_add+0x46>
60009a2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

60009a32 <sys_heap_init>:
	return big_heap_bytes(size) ? 8 : 4;
60009a32:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
60009a36:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60009a38:	bf2c      	ite	cs
60009a3a:	2408      	movcs	r4, #8
60009a3c:	2404      	movcc	r4, #4
	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
60009a3e:	1dce      	adds	r6, r1, #7
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
60009a40:	2300      	movs	r3, #0
	bytes -= heap_footer_bytes(bytes);
60009a42:	1b14      	subs	r4, r2, r4
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
60009a44:	f026 0607 	bic.w	r6, r6, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
60009a48:	440c      	add	r4, r1
	heap->heap = h;
60009a4a:	6006      	str	r6, [r0, #0]
60009a4c:	f106 0210 	add.w	r2, r6, #16
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
60009a50:	f024 0407 	bic.w	r4, r4, #7
	h->avail_buckets = 0;
60009a54:	60f3      	str	r3, [r6, #12]
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
60009a56:	1ba4      	subs	r4, r4, r6
60009a58:	08e4      	lsrs	r4, r4, #3

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
60009a5a:	4621      	mov	r1, r4
60009a5c:	4620      	mov	r0, r4
	h->end_chunk = heap_sz;
60009a5e:	60b4      	str	r4, [r6, #8]
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
60009a60:	f7ff ff95 	bl	6000998e <bucket_idx.isra.0>
60009a64:	1c41      	adds	r1, r0, #1
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
60009a66:	0085      	lsls	r5, r0, #2
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
60009a68:	4618      	mov	r0, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
60009a6a:	351b      	adds	r5, #27
60009a6c:	08ed      	lsrs	r5, r5, #3
	for (int i = 0; i < nb_buckets; i++) {
60009a6e:	428b      	cmp	r3, r1
60009a70:	db2e      	blt.n	60009ad0 <sys_heap_init+0x9e>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
60009a72:	462a      	mov	r2, r5
60009a74:	4630      	mov	r0, r6
60009a76:	2100      	movs	r1, #0
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
60009a78:	1b67      	subs	r7, r4, r5
	set_chunk_size(h, 0, chunk0_size);
60009a7a:	f7ff ff84 	bl	60009986 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
60009a7e:	2300      	movs	r3, #0
60009a80:	4630      	mov	r0, r6
60009a82:	461a      	mov	r2, r3
60009a84:	4619      	mov	r1, r3
60009a86:	f7ff ff55 	bl	60009934 <chunk_set>
	set_chunk_used(h, 0, true);
60009a8a:	4619      	mov	r1, r3
60009a8c:	4630      	mov	r0, r6
60009a8e:	2201      	movs	r2, #1
60009a90:	f7ff ff61 	bl	60009956 <set_chunk_used>
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
60009a94:	463a      	mov	r2, r7
60009a96:	4629      	mov	r1, r5
60009a98:	f7ff ff75 	bl	60009986 <set_chunk_size>
60009a9c:	462b      	mov	r3, r5
60009a9e:	2200      	movs	r2, #0
60009aa0:	4629      	mov	r1, r5
60009aa2:	4630      	mov	r0, r6
60009aa4:	f7ff ff46 	bl	60009934 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
60009aa8:	4621      	mov	r1, r4
60009aaa:	4630      	mov	r0, r6
60009aac:	f7ff ff6b 	bl	60009986 <set_chunk_size>
60009ab0:	463b      	mov	r3, r7
60009ab2:	4621      	mov	r1, r4
60009ab4:	4630      	mov	r0, r6
60009ab6:	2200      	movs	r2, #0
60009ab8:	f7ff ff3c 	bl	60009934 <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
60009abc:	4621      	mov	r1, r4
60009abe:	4630      	mov	r0, r6
60009ac0:	2201      	movs	r2, #1
60009ac2:	f7ff ff48 	bl	60009956 <set_chunk_used>

	free_list_add(h, chunk0_size);
60009ac6:	4629      	mov	r1, r5
}
60009ac8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, chunk0_size);
60009acc:	f7ff bf6e 	b.w	600099ac <free_list_add>
	for (int i = 0; i < nb_buckets; i++) {
60009ad0:	3301      	adds	r3, #1
		h->buckets[i].next = 0;
60009ad2:	f842 0b04 	str.w	r0, [r2], #4
	for (int i = 0; i < nb_buckets; i++) {
60009ad6:	e7ca      	b.n	60009a6e <sys_heap_init+0x3c>

60009ad8 <encode_uint>:
{
60009ad8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
60009adc:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
60009ade:	78d3      	ldrb	r3, [r2, #3]
{
60009ae0:	4680      	mov	r8, r0
60009ae2:	460f      	mov	r7, r1
	switch (specifier) {
60009ae4:	2b6f      	cmp	r3, #111	; 0x6f
{
60009ae6:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
60009ae8:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
60009aec:	d029      	beq.n	60009b42 <encode_uint+0x6a>
60009aee:	d824      	bhi.n	60009b3a <encode_uint+0x62>
		return 16;
60009af0:	2b58      	cmp	r3, #88	; 0x58
60009af2:	bf14      	ite	ne
60009af4:	260a      	movne	r6, #10
60009af6:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
60009af8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
60009afc:	4632      	mov	r2, r6
60009afe:	2300      	movs	r3, #0
60009b00:	4640      	mov	r0, r8
60009b02:	4639      	mov	r1, r7
60009b04:	f7f8 fbdc 	bl	600022c0 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
60009b08:	2a09      	cmp	r2, #9
60009b0a:	b2d4      	uxtb	r4, r2
60009b0c:	d81e      	bhi.n	60009b4c <encode_uint+0x74>
60009b0e:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
60009b10:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
60009b12:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
60009b14:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
60009b18:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
60009b1c:	d301      	bcc.n	60009b22 <encode_uint+0x4a>
60009b1e:	45d1      	cmp	r9, sl
60009b20:	d811      	bhi.n	60009b46 <encode_uint+0x6e>
	if (conv->flag_hash) {
60009b22:	782b      	ldrb	r3, [r5, #0]
60009b24:	069b      	lsls	r3, r3, #26
60009b26:	d505      	bpl.n	60009b34 <encode_uint+0x5c>
		if (radix == 8) {
60009b28:	2e08      	cmp	r6, #8
60009b2a:	d115      	bne.n	60009b58 <encode_uint+0x80>
			conv->altform_0 = true;
60009b2c:	78ab      	ldrb	r3, [r5, #2]
60009b2e:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
60009b32:	70ab      	strb	r3, [r5, #2]
}
60009b34:	4648      	mov	r0, r9
60009b36:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
60009b3a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
60009b3e:	2b70      	cmp	r3, #112	; 0x70
60009b40:	e7d7      	b.n	60009af2 <encode_uint+0x1a>
	switch (specifier) {
60009b42:	2608      	movs	r6, #8
60009b44:	e7d8      	b.n	60009af8 <encode_uint+0x20>
		value /= radix;
60009b46:	4680      	mov	r8, r0
60009b48:	460f      	mov	r7, r1
60009b4a:	e7d7      	b.n	60009afc <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
60009b4c:	f1bb 0f19 	cmp.w	fp, #25
60009b50:	bf94      	ite	ls
60009b52:	3437      	addls	r4, #55	; 0x37
60009b54:	3457      	addhi	r4, #87	; 0x57
60009b56:	e7db      	b.n	60009b10 <encode_uint+0x38>
		} else if (radix == 16) {
60009b58:	2e10      	cmp	r6, #16
60009b5a:	d1eb      	bne.n	60009b34 <encode_uint+0x5c>
			conv->altform_0c = true;
60009b5c:	78ab      	ldrb	r3, [r5, #2]
60009b5e:	f043 0310 	orr.w	r3, r3, #16
60009b62:	e7e6      	b.n	60009b32 <encode_uint+0x5a>

60009b64 <outs>:
{
60009b64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60009b68:	4607      	mov	r7, r0
60009b6a:	4688      	mov	r8, r1
60009b6c:	4615      	mov	r5, r2
60009b6e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
60009b70:	4614      	mov	r4, r2
60009b72:	42b4      	cmp	r4, r6
60009b74:	eba4 0005 	sub.w	r0, r4, r5
60009b78:	d302      	bcc.n	60009b80 <outs+0x1c>
60009b7a:	b93e      	cbnz	r6, 60009b8c <outs+0x28>
60009b7c:	7823      	ldrb	r3, [r4, #0]
60009b7e:	b12b      	cbz	r3, 60009b8c <outs+0x28>
		int rc = out((int)*sp++, ctx);
60009b80:	4641      	mov	r1, r8
60009b82:	f814 0b01 	ldrb.w	r0, [r4], #1
60009b86:	47b8      	blx	r7
		if (rc < 0) {
60009b88:	2800      	cmp	r0, #0
60009b8a:	daf2      	bge.n	60009b72 <outs+0xe>
}
60009b8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

60009b90 <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
60009b90:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
60009b94:	4770      	bx	lr

60009b96 <ring_buf_put_claim>:
{
	return val >= max ? (val - max) : val;
}

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
60009b96:	b5f0      	push	{r4, r5, r6, r7, lr}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
60009b98:	6985      	ldr	r5, [r0, #24]
{
60009b9a:	4604      	mov	r4, r0
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
60009b9c:	6886      	ldr	r6, [r0, #8]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
60009b9e:	6907      	ldr	r7, [r0, #16]
60009ba0:	b185      	cbz	r5, 60009bc4 <ring_buf_put_claim+0x2e>
60009ba2:	4035      	ands	r5, r6
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
60009ba4:	6823      	ldr	r3, [r4, #0]
60009ba6:	443b      	add	r3, r7
	trail_size = buf->size - tmp_trail_mod;
60009ba8:	1b7f      	subs	r7, r7, r5
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
60009baa:	1b98      	subs	r0, r3, r6

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
	*data = &buf->buf.buf8[tmp_trail_mod];
60009bac:	6963      	ldr	r3, [r4, #20]
	size = MIN(size, space);
60009bae:	4290      	cmp	r0, r2
	*data = &buf->buf.buf8[tmp_trail_mod];
60009bb0:	442b      	add	r3, r5
	size = MIN(size, space);
60009bb2:	bf28      	it	cs
60009bb4:	4610      	movcs	r0, r2
	*data = &buf->buf.buf8[tmp_trail_mod];
60009bb6:	600b      	str	r3, [r1, #0]
	allocated = MIN(trail_size, size);
60009bb8:	42b8      	cmp	r0, r7
60009bba:	bf28      	it	cs
60009bbc:	4638      	movcs	r0, r7

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
60009bbe:	4406      	add	r6, r0
	buf->misc.byte_mode.tmp_tail =
60009bc0:	60a6      	str	r6, [r4, #8]

	return allocated;
}
60009bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
60009bc4:	fbb6 f5f7 	udiv	r5, r6, r7
60009bc8:	fb07 6515 	mls	r5, r7, r5, r6
60009bcc:	e7ea      	b.n	60009ba4 <ring_buf_put_claim+0xe>

60009bce <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
	if ((buf->tail + size) > (buf->head + buf->size)) {
60009bce:	6843      	ldr	r3, [r0, #4]
60009bd0:	6902      	ldr	r2, [r0, #16]
60009bd2:	4419      	add	r1, r3
60009bd4:	6803      	ldr	r3, [r0, #0]
60009bd6:	4413      	add	r3, r2
60009bd8:	4299      	cmp	r1, r3
		return -EINVAL;
	}

	buf->tail += size;
	buf->misc.byte_mode.tmp_tail = buf->tail;
60009bda:	bf9a      	itte	ls
60009bdc:	e9c0 1101 	strdls	r1, r1, [r0, #4]

	return 0;
60009be0:	2000      	movls	r0, #0
		return -EINVAL;
60009be2:	f06f 0015 	mvnhi.w	r0, #21
}
60009be6:	4770      	bx	lr

60009be8 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
60009be8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
60009bec:	4680      	mov	r8, r0
60009bee:	460e      	mov	r6, r1
60009bf0:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
60009bf2:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
60009bf4:	462a      	mov	r2, r5
60009bf6:	a901      	add	r1, sp, #4
60009bf8:	4640      	mov	r0, r8
60009bfa:	f7ff ffcc 	bl	60009b96 <ring_buf_put_claim>
60009bfe:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
60009c00:	4602      	mov	r2, r0
60009c02:	4631      	mov	r1, r6
60009c04:	9801      	ldr	r0, [sp, #4]
		total_size += partial_size;
60009c06:	4427      	add	r7, r4
		memcpy(dst, data, partial_size);
60009c08:	f001 fea3 	bl	6000b952 <memcpy>
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
60009c0c:	1b2d      	subs	r5, r5, r4
		data += partial_size;
60009c0e:	4426      	add	r6, r4
	} while (size && partial_size);
60009c10:	d001      	beq.n	60009c16 <ring_buf_put+0x2e>
60009c12:	2c00      	cmp	r4, #0
60009c14:	d1ee      	bne.n	60009bf4 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
60009c16:	4639      	mov	r1, r7
60009c18:	4640      	mov	r0, r8
60009c1a:	f7ff ffd8 	bl	60009bce <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
60009c1e:	4638      	mov	r0, r7
60009c20:	b002      	add	sp, #8
60009c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

60009c26 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
60009c26:	b5f0      	push	{r4, r5, r6, r7, lr}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
60009c28:	6985      	ldr	r5, [r0, #24]
{
60009c2a:	4604      	mov	r4, r0
	uint32_t space, granted_size, trail_size, tmp_head_mod;

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
60009c2c:	68c6      	ldr	r6, [r0, #12]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
60009c2e:	6903      	ldr	r3, [r0, #16]
60009c30:	b185      	cbz	r5, 60009c54 <ring_buf_get_claim+0x2e>
60009c32:	4035      	ands	r5, r6
	space = buf->tail - buf->misc.byte_mode.tmp_head;
60009c34:	6867      	ldr	r7, [r4, #4]
60009c36:	1bb8      	subs	r0, r7, r6
	trail_size = buf->size - tmp_head_mod;

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);
60009c38:	4290      	cmp	r0, r2
60009c3a:	bf28      	it	cs
60009c3c:	4610      	movcs	r0, r2
60009c3e:	4607      	mov	r7, r0
	trail_size = buf->size - tmp_head_mod;
60009c40:	1b58      	subs	r0, r3, r5

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);

	*data = &buf->buf.buf8[tmp_head_mod];
60009c42:	6963      	ldr	r3, [r4, #20]
	granted_size = MIN(trail_size, granted_size);
60009c44:	42b8      	cmp	r0, r7
	*data = &buf->buf.buf8[tmp_head_mod];
60009c46:	442b      	add	r3, r5
	granted_size = MIN(trail_size, granted_size);
60009c48:	bf28      	it	cs
60009c4a:	4638      	movcs	r0, r7
	*data = &buf->buf.buf8[tmp_head_mod];
60009c4c:	600b      	str	r3, [r1, #0]
	buf->misc.byte_mode.tmp_head += granted_size;
60009c4e:	4406      	add	r6, r0
60009c50:	60e6      	str	r6, [r4, #12]

	return granted_size;
}
60009c52:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
60009c54:	fbb6 f5f3 	udiv	r5, r6, r3
60009c58:	fb03 6515 	mls	r5, r3, r5, r6
60009c5c:	e7ea      	b.n	60009c34 <ring_buf_get_claim+0xe>

60009c5e <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
	if ((buf->head + size) > buf->tail) {
60009c5e:	6803      	ldr	r3, [r0, #0]
60009c60:	4419      	add	r1, r3
60009c62:	6843      	ldr	r3, [r0, #4]
60009c64:	4299      	cmp	r1, r3
{
60009c66:	b510      	push	{r4, lr}
60009c68:	4604      	mov	r4, r0
	if ((buf->head + size) > buf->tail) {
60009c6a:	d824      	bhi.n	60009cb6 <ring_buf_get_finish+0x58>
		return -EINVAL;
	}

	buf->head += size;
60009c6c:	6001      	str	r1, [r0, #0]
	buf->misc.byte_mode.tmp_head = buf->head;
60009c6e:	60c1      	str	r1, [r0, #12]
	uint32_t threshold = ring_buf_get_rewind_threshold();
60009c70:	f7ff ff8e 	bl	60009b90 <ring_buf_get_rewind_threshold>
	if (buf->head < threshold) {
60009c74:	6823      	ldr	r3, [r4, #0]
60009c76:	4298      	cmp	r0, r3
60009c78:	d81b      	bhi.n	60009cb2 <ring_buf_get_finish+0x54>
	rew = buf->size * (threshold / buf->size);
60009c7a:	6923      	ldr	r3, [r4, #16]
60009c7c:	fbb0 f0f3 	udiv	r0, r0, r3
60009c80:	4358      	muls	r0, r3
	__asm__ volatile(
60009c82:	f04f 0310 	mov.w	r3, #16
60009c86:	f3ef 8211 	mrs	r2, BASEPRI
60009c8a:	f383 8811 	msr	BASEPRI, r3
60009c8e:	f3bf 8f6f 	isb	sy
	buf->tail -= rew;
60009c92:	6863      	ldr	r3, [r4, #4]
60009c94:	1a1b      	subs	r3, r3, r0
60009c96:	6063      	str	r3, [r4, #4]
	buf->head -= rew;
60009c98:	6823      	ldr	r3, [r4, #0]
60009c9a:	1a1b      	subs	r3, r3, r0
60009c9c:	6023      	str	r3, [r4, #0]
	buf->misc.byte_mode.tmp_head -= rew;
60009c9e:	68e3      	ldr	r3, [r4, #12]
60009ca0:	1a1b      	subs	r3, r3, r0
60009ca2:	60e3      	str	r3, [r4, #12]
	buf->misc.byte_mode.tmp_tail -= rew;
60009ca4:	68a3      	ldr	r3, [r4, #8]
60009ca6:	1a18      	subs	r0, r3, r0
60009ca8:	60a0      	str	r0, [r4, #8]
	__asm__ volatile(
60009caa:	f382 8811 	msr	BASEPRI, r2
60009cae:	f3bf 8f6f 	isb	sy

	byte_indexes_rewind(buf);

	return 0;
60009cb2:	2000      	movs	r0, #0
60009cb4:	e001      	b.n	60009cba <ring_buf_get_finish+0x5c>
		return -EINVAL;
60009cb6:	f06f 0015 	mvn.w	r0, #21
}
60009cba:	bd10      	pop	{r4, pc}

60009cbc <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
60009cbc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
60009cc0:	4680      	mov	r8, r0
60009cc2:	460d      	mov	r5, r1
60009cc4:	4616      	mov	r6, r2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
60009cc6:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
60009cc8:	4632      	mov	r2, r6
60009cca:	a901      	add	r1, sp, #4
60009ccc:	4640      	mov	r0, r8
60009cce:	f7ff ffaa 	bl	60009c26 <ring_buf_get_claim>
60009cd2:	4604      	mov	r4, r0
		if (data) {
60009cd4:	b12d      	cbz	r5, 60009ce2 <ring_buf_get+0x26>
			memcpy(data, src, partial_size);
60009cd6:	4602      	mov	r2, r0
60009cd8:	4628      	mov	r0, r5
			data += partial_size;
60009cda:	4425      	add	r5, r4
			memcpy(data, src, partial_size);
60009cdc:	9901      	ldr	r1, [sp, #4]
60009cde:	f001 fe38 	bl	6000b952 <memcpy>
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
60009ce2:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
60009ce4:	4427      	add	r7, r4
	} while (size && partial_size);
60009ce6:	d001      	beq.n	60009cec <ring_buf_get+0x30>
60009ce8:	2c00      	cmp	r4, #0
60009cea:	d1ed      	bne.n	60009cc8 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
60009cec:	4639      	mov	r1, r7
60009cee:	4640      	mov	r0, r8
60009cf0:	f7ff ffb5 	bl	60009c5e <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
60009cf4:	4638      	mov	r0, r7
60009cf6:	b002      	add	sp, #8
60009cf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

60009cfc <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
60009cfc:	070b      	lsls	r3, r1, #28
60009cfe:	d504      	bpl.n	60009d0a <foldcase+0xe>
60009d00:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
60009d04:	2b19      	cmp	r3, #25
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
60009d06:	bf98      	it	ls
60009d08:	3020      	addls	r0, #32
        return tolower(ch);
    return ch;
}
60009d0a:	4770      	bx	lr

60009d0c <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
60009d0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60009d10:	b087      	sub	sp, #28
60009d12:	468a      	mov	sl, r1
60009d14:	4614      	mov	r4, r2
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
60009d16:	4605      	mov	r5, r0
{
60009d18:	9302      	str	r3, [sp, #8]
    if ((pattern == NULL) || (string == NULL))
60009d1a:	b918      	cbnz	r0, 60009d24 <fnmatchx+0x18>
    {
        return FNM_NOMATCH;
60009d1c:	2001      	movs	r0, #1
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
60009d1e:	b007      	add	sp, #28
60009d20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((pattern == NULL) || (string == NULL))
60009d24:	2900      	cmp	r1, #0
60009d26:	d0f9      	beq.n	60009d1c <fnmatchx+0x10>
    if (recursion-- == 0)
60009d28:	9b02      	ldr	r3, [sp, #8]
60009d2a:	2b00      	cmp	r3, #0
60009d2c:	f000 8118 	beq.w	60009f60 <fnmatchx+0x254>
            if (*string == '.' && (flags & FNM_PERIOD) &&
60009d30:	f004 0304 	and.w	r3, r4, #4
60009d34:	460a      	mov	r2, r1
60009d36:	9304      	str	r3, [sp, #16]
        switch (c = FOLDCASE(*pattern++, flags)) {
60009d38:	46a8      	mov	r8, r5
60009d3a:	4621      	mov	r1, r4
60009d3c:	f818 0b01 	ldrb.w	r0, [r8], #1
60009d40:	f7ff ffdc 	bl	60009cfc <foldcase>
60009d44:	4603      	mov	r3, r0
60009d46:	b2c0      	uxtb	r0, r0
            if ((flags & FNM_LEADING_DIR) && *string == '/')
60009d48:	7817      	ldrb	r7, [r2, #0]
        switch (c = FOLDCASE(*pattern++, flags)) {
60009d4a:	283f      	cmp	r0, #63	; 0x3f
60009d4c:	4606      	mov	r6, r0
60009d4e:	d025      	beq.n	60009d9c <fnmatchx+0x90>
60009d50:	f013 0fc0 	tst.w	r3, #192	; 0xc0
60009d54:	d10b      	bne.n	60009d6e <fnmatchx+0x62>
60009d56:	b1c8      	cbz	r0, 60009d8c <fnmatchx+0x80>
60009d58:	282a      	cmp	r0, #42	; 0x2a
60009d5a:	d036      	beq.n	60009dca <fnmatchx+0xbe>
            if (c != FOLDCASE(*string++, flags))
60009d5c:	4621      	mov	r1, r4
60009d5e:	4638      	mov	r0, r7
60009d60:	f7ff ffcc 	bl	60009cfc <foldcase>
60009d64:	4286      	cmp	r6, r0
60009d66:	f102 0201 	add.w	r2, r2, #1
60009d6a:	d01e      	beq.n	60009daa <fnmatchx+0x9e>
60009d6c:	e7d6      	b.n	60009d1c <fnmatchx+0x10>
        switch (c = FOLDCASE(*pattern++, flags)) {
60009d6e:	285b      	cmp	r0, #91	; 0x5b
60009d70:	d07a      	beq.n	60009e68 <fnmatchx+0x15c>
60009d72:	285c      	cmp	r0, #92	; 0x5c
60009d74:	d1f2      	bne.n	60009d5c <fnmatchx+0x50>
            if (!(flags & FNM_NOESCAPE)) {
60009d76:	07e3      	lsls	r3, r4, #31
60009d78:	d4f0      	bmi.n	60009d5c <fnmatchx+0x50>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
60009d7a:	7868      	ldrb	r0, [r5, #1]
60009d7c:	f7ff ffbe 	bl	60009cfc <foldcase>
60009d80:	f010 06ff 	ands.w	r6, r0, #255	; 0xff
60009d84:	bf18      	it	ne
60009d86:	f105 0802 	addne.w	r8, r5, #2
60009d8a:	e7e7      	b.n	60009d5c <fnmatchx+0x50>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
60009d8c:	06e4      	lsls	r4, r4, #27
60009d8e:	d501      	bpl.n	60009d94 <fnmatchx+0x88>
60009d90:	2f2f      	cmp	r7, #47	; 0x2f
60009d92:	d0c4      	beq.n	60009d1e <fnmatchx+0x12>
            return *string == EOS ? 0 : FNM_NOMATCH;
60009d94:	1e38      	subs	r0, r7, #0
                        0 : FNM_NOMATCH;
60009d96:	bf18      	it	ne
60009d98:	2001      	movne	r0, #1
60009d9a:	e7c0      	b.n	60009d1e <fnmatchx+0x12>
            if (*string == EOS)
60009d9c:	2f00      	cmp	r7, #0
60009d9e:	d0bd      	beq.n	60009d1c <fnmatchx+0x10>
            if (*string == '/' && (flags & FNM_PATHNAME))
60009da0:	2f2f      	cmp	r7, #47	; 0x2f
60009da2:	d104      	bne.n	60009dae <fnmatchx+0xa2>
60009da4:	07a1      	lsls	r1, r4, #30
60009da6:	d4b9      	bmi.n	60009d1c <fnmatchx+0x10>
            ++string;
60009da8:	3201      	adds	r2, #1
            break;
60009daa:	4645      	mov	r5, r8
60009dac:	e7c4      	b.n	60009d38 <fnmatchx+0x2c>
            if (*string == '.' && (flags & FNM_PERIOD) &&
60009dae:	2f2e      	cmp	r7, #46	; 0x2e
60009db0:	d1fa      	bne.n	60009da8 <fnmatchx+0x9c>
60009db2:	9b04      	ldr	r3, [sp, #16]
60009db4:	2b00      	cmp	r3, #0
60009db6:	d0f7      	beq.n	60009da8 <fnmatchx+0x9c>
60009db8:	4552      	cmp	r2, sl
60009dba:	d0af      	beq.n	60009d1c <fnmatchx+0x10>
                (string == stringstart ||
60009dbc:	07a3      	lsls	r3, r4, #30
60009dbe:	d5f3      	bpl.n	60009da8 <fnmatchx+0x9c>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
60009dc0:	f812 3c01 	ldrb.w	r3, [r2, #-1]
60009dc4:	2b2f      	cmp	r3, #47	; 0x2f
60009dc6:	d1ef      	bne.n	60009da8 <fnmatchx+0x9c>
60009dc8:	e7a8      	b.n	60009d1c <fnmatchx+0x10>
            c = FOLDCASE(*pattern, flags);
60009dca:	7868      	ldrb	r0, [r5, #1]
                c = FOLDCASE(*++pattern, flags);
60009dcc:	f7ff ff96 	bl	60009cfc <foldcase>
60009dd0:	b2c1      	uxtb	r1, r0
            while (c == '*')
60009dd2:	292a      	cmp	r1, #42	; 0x2a
60009dd4:	d018      	beq.n	60009e08 <fnmatchx+0xfc>
            if (*string == '.' && (flags & FNM_PERIOD) &&
60009dd6:	2f2e      	cmp	r7, #46	; 0x2e
60009dd8:	d109      	bne.n	60009dee <fnmatchx+0xe2>
60009dda:	9b04      	ldr	r3, [sp, #16]
60009ddc:	b13b      	cbz	r3, 60009dee <fnmatchx+0xe2>
60009dde:	4552      	cmp	r2, sl
60009de0:	d09c      	beq.n	60009d1c <fnmatchx+0x10>
                (string == stringstart ||
60009de2:	07a7      	lsls	r7, r4, #30
60009de4:	d503      	bpl.n	60009dee <fnmatchx+0xe2>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
60009de6:	f812 3c01 	ldrb.w	r3, [r2, #-1]
60009dea:	2b2f      	cmp	r3, #47	; 0x2f
60009dec:	d096      	beq.n	60009d1c <fnmatchx+0x10>
            if (c == EOS) {
60009dee:	b979      	cbnz	r1, 60009e10 <fnmatchx+0x104>
                if (flags & FNM_PATHNAME)
60009df0:	f014 0002 	ands.w	r0, r4, #2
60009df4:	d093      	beq.n	60009d1e <fnmatchx+0x12>
                        0 : FNM_NOMATCH;
60009df6:	06e6      	lsls	r6, r4, #27
60009df8:	f100 80b4 	bmi.w	60009f64 <fnmatchx+0x258>
                        strchr(string, '/') == NULL ?
60009dfc:	212f      	movs	r1, #47	; 0x2f
60009dfe:	4610      	mov	r0, r2
60009e00:	f001 fd44 	bl	6000b88c <strchr>
                        0 : FNM_NOMATCH;
60009e04:	3800      	subs	r0, #0
60009e06:	e7c6      	b.n	60009d96 <fnmatchx+0x8a>
                c = FOLDCASE(*++pattern, flags);
60009e08:	4621      	mov	r1, r4
60009e0a:	f818 0f01 	ldrb.w	r0, [r8, #1]!
60009e0e:	e7dd      	b.n	60009dcc <fnmatchx+0xc0>
            } else if (c == '/' && flags & FNM_PATHNAME) {
60009e10:	292f      	cmp	r1, #47	; 0x2f
60009e12:	d020      	beq.n	60009e56 <fnmatchx+0x14a>
    if (recursion-- == 0)
60009e14:	9b02      	ldr	r3, [sp, #8]
60009e16:	4616      	mov	r6, r2
                switch ((e = fnmatchx(pattern, string,
60009e18:	f024 0904 	bic.w	r9, r4, #4
                if (test == '/' && flags & FNM_PATHNAME)
60009e1c:	f004 0a02 	and.w	sl, r4, #2
    if (recursion-- == 0)
60009e20:	1e5f      	subs	r7, r3, #1
60009e22:	46b3      	mov	fp, r6
            while ((test = FOLDCASE(*string, flags)) != EOS) {
60009e24:	4621      	mov	r1, r4
60009e26:	3601      	adds	r6, #1
60009e28:	f89b 0000 	ldrb.w	r0, [fp]
60009e2c:	f7ff ff66 	bl	60009cfc <foldcase>
60009e30:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
60009e34:	f43f af72 	beq.w	60009d1c <fnmatchx+0x10>
                switch ((e = fnmatchx(pattern, string,
60009e38:	463b      	mov	r3, r7
60009e3a:	464a      	mov	r2, r9
60009e3c:	4659      	mov	r1, fp
60009e3e:	4640      	mov	r0, r8
60009e40:	f7ff ff64 	bl	60009d0c <fnmatchx>
60009e44:	2801      	cmp	r0, #1
60009e46:	f47f af6a 	bne.w	60009d1e <fnmatchx+0x12>
                if (test == '/' && flags & FNM_PATHNAME)
60009e4a:	2d2f      	cmp	r5, #47	; 0x2f
60009e4c:	d1e9      	bne.n	60009e22 <fnmatchx+0x116>
60009e4e:	f1ba 0f00 	cmp.w	sl, #0
60009e52:	d0e6      	beq.n	60009e22 <fnmatchx+0x116>
60009e54:	e762      	b.n	60009d1c <fnmatchx+0x10>
            } else if (c == '/' && flags & FNM_PATHNAME) {
60009e56:	07a5      	lsls	r5, r4, #30
60009e58:	d5dc      	bpl.n	60009e14 <fnmatchx+0x108>
                if ((string = strchr(string, '/')) == NULL)
60009e5a:	4610      	mov	r0, r2
60009e5c:	f001 fd16 	bl	6000b88c <strchr>
60009e60:	4602      	mov	r2, r0
60009e62:	2800      	cmp	r0, #0
60009e64:	d1a1      	bne.n	60009daa <fnmatchx+0x9e>
60009e66:	e759      	b.n	60009d1c <fnmatchx+0x10>
            if (*string == EOS)
60009e68:	2f00      	cmp	r7, #0
60009e6a:	f43f af57 	beq.w	60009d1c <fnmatchx+0x10>
            if (*string == '/' && flags & FNM_PATHNAME)
60009e6e:	2f2f      	cmp	r7, #47	; 0x2f
60009e70:	d102      	bne.n	60009e78 <fnmatchx+0x16c>
60009e72:	07a0      	lsls	r0, r4, #30
60009e74:	f53f af52 	bmi.w	60009d1c <fnmatchx+0x10>
            if ((r = rangematch(pattern,
60009e78:	4621      	mov	r1, r4
60009e7a:	4638      	mov	r0, r7
60009e7c:	f7ff ff3e 	bl	60009cfc <foldcase>
60009e80:	9000      	str	r0, [sp, #0]
    if (pattern == NULL)
60009e82:	f1b8 0f00 	cmp.w	r8, #0
60009e86:	f43f af49 	beq.w	60009d1c <fnmatchx+0x10>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
60009e8a:	786b      	ldrb	r3, [r5, #1]
60009e8c:	2b21      	cmp	r3, #33	; 0x21
60009e8e:	d001      	beq.n	60009e94 <fnmatchx+0x188>
60009e90:	2b5e      	cmp	r3, #94	; 0x5e
60009e92:	d126      	bne.n	60009ee2 <fnmatchx+0x1d6>
        ++pattern;
60009e94:	3502      	adds	r5, #2
60009e96:	2301      	movs	r3, #1
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
60009e98:	9301      	str	r3, [sp, #4]
    need = 1;
60009e9a:	2301      	movs	r3, #1
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
60009e9c:	f04f 0b00 	mov.w	fp, #0
        if (c == '\\' && !(flags & FNM_NOESCAPE))
60009ea0:	ea04 0103 	and.w	r1, r4, r3
60009ea4:	9103      	str	r1, [sp, #12]
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
60009ea6:	462e      	mov	r6, r5
60009ea8:	4621      	mov	r1, r4
60009eaa:	9305      	str	r3, [sp, #20]
60009eac:	f816 0b01 	ldrb.w	r0, [r6], #1
60009eb0:	f7ff ff24 	bl	60009cfc <foldcase>
60009eb4:	9b05      	ldr	r3, [sp, #20]
60009eb6:	fa5f f980 	uxtb.w	r9, r0
60009eba:	f1b9 0f5d 	cmp.w	r9, #93	; 0x5d
60009ebe:	d113      	bne.n	60009ee8 <fnmatchx+0x1dc>
60009ec0:	bb23      	cbnz	r3, 60009f0c <fnmatchx+0x200>
    return ok == negate ? NULL : pattern;
60009ec2:	9b01      	ldr	r3, [sp, #4]
60009ec4:	455b      	cmp	r3, fp
60009ec6:	f43f af29 	beq.w	60009d1c <fnmatchx+0x10>
            if ((r = rangematch(pattern,
60009eca:	2e00      	cmp	r6, #0
60009ecc:	f43f af26 	beq.w	60009d1c <fnmatchx+0x10>
            if (r == (void *)-1) {
60009ed0:	1c71      	adds	r1, r6, #1
60009ed2:	d103      	bne.n	60009edc <fnmatchx+0x1d0>
                if (*string != '[')
60009ed4:	2f5b      	cmp	r7, #91	; 0x5b
60009ed6:	f47f af21 	bne.w	60009d1c <fnmatchx+0x10>
60009eda:	4646      	mov	r6, r8
            ++string;
60009edc:	3201      	adds	r2, #1
            break;
60009ede:	46b0      	mov	r8, r6
60009ee0:	e763      	b.n	60009daa <fnmatchx+0x9e>
60009ee2:	4645      	mov	r5, r8
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
60009ee4:	2300      	movs	r3, #0
60009ee6:	e7d7      	b.n	60009e98 <fnmatchx+0x18c>
        if (c == '/')
60009ee8:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
60009eec:	d0f2      	beq.n	60009ed4 <fnmatchx+0x1c8>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
60009eee:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
60009ef2:	d107      	bne.n	60009f04 <fnmatchx+0x1f8>
60009ef4:	9b03      	ldr	r3, [sp, #12]
60009ef6:	b94b      	cbnz	r3, 60009f0c <fnmatchx+0x200>
            c = FOLDCASE(*pattern++, flags);
60009ef8:	7868      	ldrb	r0, [r5, #1]
60009efa:	1cae      	adds	r6, r5, #2
60009efc:	f7ff fefe 	bl	60009cfc <foldcase>
60009f00:	fa5f f980 	uxtb.w	r9, r0
        if (c == EOS)
60009f04:	f1b9 0f00 	cmp.w	r9, #0
60009f08:	f43f af08 	beq.w	60009d1c <fnmatchx+0x10>
        if (*pattern == '-' 
60009f0c:	7833      	ldrb	r3, [r6, #0]
60009f0e:	2b2d      	cmp	r3, #45	; 0x2d
60009f10:	d11f      	bne.n	60009f52 <fnmatchx+0x246>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
60009f12:	4621      	mov	r1, r4
60009f14:	7870      	ldrb	r0, [r6, #1]
60009f16:	f7ff fef1 	bl	60009cfc <foldcase>
60009f1a:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
60009f1e:	d018      	beq.n	60009f52 <fnmatchx+0x246>
60009f20:	285d      	cmp	r0, #93	; 0x5d
60009f22:	d016      	beq.n	60009f52 <fnmatchx+0x246>
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
60009f24:	285c      	cmp	r0, #92	; 0x5c
            pattern += 2;
60009f26:	f106 0502 	add.w	r5, r6, #2
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
60009f2a:	d109      	bne.n	60009f40 <fnmatchx+0x234>
60009f2c:	9b03      	ldr	r3, [sp, #12]
60009f2e:	b93b      	cbnz	r3, 60009f40 <fnmatchx+0x234>
                c2 = FOLDCASE(*pattern++, flags);
60009f30:	78b0      	ldrb	r0, [r6, #2]
60009f32:	1cf5      	adds	r5, r6, #3
60009f34:	f7ff fee2 	bl	60009cfc <foldcase>
            if (c2 == EOS)
60009f38:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
60009f3c:	f43f aeee 	beq.w	60009d1c <fnmatchx+0x10>
            if (c <= test && test <= c2)
60009f40:	9b00      	ldr	r3, [sp, #0]
60009f42:	454b      	cmp	r3, r9
60009f44:	db03      	blt.n	60009f4e <fnmatchx+0x242>
                ok = 1;
60009f46:	4283      	cmp	r3, r0
60009f48:	bfd8      	it	le
60009f4a:	f04f 0b01 	movle.w	fp, #1
            ok = 1;
60009f4e:	2300      	movs	r3, #0
60009f50:	e7a9      	b.n	60009ea6 <fnmatchx+0x19a>
        } else if (c == test)
60009f52:	9b00      	ldr	r3, [sp, #0]
60009f54:	4635      	mov	r5, r6
60009f56:	454b      	cmp	r3, r9
60009f58:	bf08      	it	eq
60009f5a:	f04f 0b01 	moveq.w	fp, #1
60009f5e:	e7f6      	b.n	60009f4e <fnmatchx+0x242>
        return FNM_NORES;
60009f60:	2003      	movs	r0, #3
60009f62:	e6dc      	b.n	60009d1e <fnmatchx+0x12>
                return 0;
60009f64:	4608      	mov	r0, r1
60009f66:	e6da      	b.n	60009d1e <fnmatchx+0x12>

60009f68 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
60009f68:	2340      	movs	r3, #64	; 0x40
60009f6a:	f7ff becf 	b.w	60009d0c <fnmatchx>

60009f6e <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
60009f6e:	4770      	bx	lr

60009f70 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
60009f70:	2300      	movs	r3, #0
	list->head = NULL;
60009f72:	e9c0 3300 	strd	r3, r3, [r0]
}
60009f76:	4770      	bx	lr

60009f78 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
60009f78:	6803      	ldr	r3, [r0, #0]
60009f7a:	b923      	cbnz	r3, 60009f86 <log_list_add_tail+0xe>
		list->head = msg;
60009f7c:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
60009f7e:	2300      	movs	r3, #0
	list->tail = msg;
60009f80:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
60009f82:	600b      	str	r3, [r1, #0]
}
60009f84:	4770      	bx	lr
		list->tail->next = msg;
60009f86:	6843      	ldr	r3, [r0, #4]
60009f88:	6019      	str	r1, [r3, #0]
60009f8a:	e7f8      	b.n	60009f7e <log_list_add_tail+0x6>

60009f8c <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
60009f8c:	6800      	ldr	r0, [r0, #0]
60009f8e:	4770      	bx	lr

60009f90 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
60009f90:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
60009f92:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
60009f94:	b108      	cbz	r0, 60009f9a <log_list_head_get+0xa>
		list->head = list->head->next;
60009f96:	6802      	ldr	r2, [r0, #0]
60009f98:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
60009f9a:	4770      	bx	lr

60009f9c <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
60009f9c:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
60009f9e:	f7f9 fc59 	bl	60003854 <log_msg_chunk_alloc>

	if (msg != NULL) {
60009fa2:	b118      	cbz	r0, 60009fac <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
60009fa4:	2301      	movs	r3, #1
60009fa6:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
60009fa8:	2300      	movs	r3, #0
60009faa:	8103      	strh	r3, [r0, #8]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
60009fac:	bd08      	pop	{r3, pc}

60009fae <default_lf_get_timestamp>:
{
60009fae:	b508      	push	{r3, lr}
	return z_impl_k_uptime_ticks();
60009fb0:	f002 fac8 	bl	6000c544 <z_impl_k_uptime_ticks>
60009fb4:	220a      	movs	r2, #10
60009fb6:	2300      	movs	r3, #0
60009fb8:	f7f8 f982 	bl	600022c0 <__aeabi_uldivmod>
}
60009fbc:	bd08      	pop	{r3, pc}

60009fbe <dummy_timestamp>:
60009fbe:	2000      	movs	r0, #0
60009fc0:	4770      	bx	lr

60009fc2 <z_log_get_s_mask>:
{
60009fc2:	b5f0      	push	{r4, r5, r6, r7, lr}
60009fc4:	4605      	mov	r5, r0
	uint32_t mask = 0U;
60009fc6:	2000      	movs	r0, #0
				mask |= BIT(arg);
60009fc8:	2701      	movs	r7, #1
	uint32_t arg = 0U;
60009fca:	4603      	mov	r3, r0
	bool arm = false;
60009fcc:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
60009fce:	f815 4b01 	ldrb.w	r4, [r5], #1
60009fd2:	b10c      	cbz	r4, 60009fd8 <z_log_get_s_mask+0x16>
60009fd4:	428b      	cmp	r3, r1
60009fd6:	d300      	bcc.n	60009fda <z_log_get_s_mask+0x18>
}
60009fd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
60009fda:	2c25      	cmp	r4, #37	; 0x25
60009fdc:	d102      	bne.n	60009fe4 <z_log_get_s_mask+0x22>
			arm = !arm;
60009fde:	f082 0201 	eor.w	r2, r2, #1
60009fe2:	e7f4      	b.n	60009fce <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
60009fe4:	2a00      	cmp	r2, #0
60009fe6:	d0f2      	beq.n	60009fce <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
60009fe8:	f044 0620 	orr.w	r6, r4, #32
60009fec:	3e61      	subs	r6, #97	; 0x61
60009fee:	2e19      	cmp	r6, #25
60009ff0:	d8ed      	bhi.n	60009fce <z_log_get_s_mask+0xc>
			if (curr == 's') {
60009ff2:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
60009ff4:	bf08      	it	eq
60009ff6:	fa07 f203 	lsleq.w	r2, r7, r3
			arg++;
60009ffa:	f103 0301 	add.w	r3, r3, #1
				mask |= BIT(arg);
60009ffe:	bf08      	it	eq
6000a000:	4310      	orreq	r0, r2
			arm = false;
6000a002:	2200      	movs	r2, #0
6000a004:	e7e3      	b.n	60009fce <z_log_get_s_mask+0xc>

6000a006 <log_backend_disable>:
	backend->cb->active = false;
6000a006:	6843      	ldr	r3, [r0, #4]
6000a008:	2100      	movs	r1, #0
6000a00a:	7159      	strb	r1, [r3, #5]
	backend_filter_set(backend, LOG_LEVEL_NONE);
6000a00c:	f7f9 b9b2 	b.w	60003374 <backend_filter_set>

6000a010 <log_0>:
{
6000a010:	b538      	push	{r3, r4, r5, lr}
6000a012:	4605      	mov	r5, r0
6000a014:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
6000a016:	f7ff ffc1 	bl	60009f9c <z_log_msg_std_alloc>

	if (msg != NULL) {
6000a01a:	b128      	cbz	r0, 6000a028 <log_0+0x18>
		msg_finalize(msg, src_level);
6000a01c:	4621      	mov	r1, r4
		msg->str = str;
6000a01e:	6105      	str	r5, [r0, #16]
}
6000a020:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
6000a024:	f7f9 bb54 	b.w	600036d0 <msg_finalize>
}
6000a028:	bd38      	pop	{r3, r4, r5, pc}

6000a02a <log_1>:
{
6000a02a:	b570      	push	{r4, r5, r6, lr}
6000a02c:	4606      	mov	r6, r0
6000a02e:	460d      	mov	r5, r1
6000a030:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
6000a032:	f7ff ffb3 	bl	60009f9c <z_log_msg_std_alloc>

	if (msg != NULL) {
6000a036:	b158      	cbz	r0, 6000a050 <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
6000a038:	7a42      	ldrb	r2, [r0, #9]
6000a03a:	2101      	movs	r1, #1
		msg->str = str;
6000a03c:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
6000a03e:	f361 1207 	bfi	r2, r1, #4, #4
		msg->payload.single.args[0] = arg1;
6000a042:	6145      	str	r5, [r0, #20]
		msg_finalize(msg, src_level);
6000a044:	4621      	mov	r1, r4
		msg->hdr.params.std.nargs = 1U;
6000a046:	7242      	strb	r2, [r0, #9]
}
6000a048:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
6000a04c:	f7f9 bb40 	b.w	600036d0 <msg_finalize>
}
6000a050:	bd70      	pop	{r4, r5, r6, pc}

6000a052 <log_2>:
{
6000a052:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000a056:	4680      	mov	r8, r0
6000a058:	460f      	mov	r7, r1
6000a05a:	4616      	mov	r6, r2
6000a05c:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
6000a05e:	f7ff ff9d 	bl	60009f9c <z_log_msg_std_alloc>

	if (msg != NULL) {
6000a062:	b168      	cbz	r0, 6000a080 <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
6000a064:	7a43      	ldrb	r3, [r0, #9]
6000a066:	2202      	movs	r2, #2
		msg_finalize(msg, src_level);
6000a068:	4629      	mov	r1, r5
		msg->str = str;
6000a06a:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
6000a06e:	f362 1307 	bfi	r3, r2, #4, #4
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
6000a072:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->hdr.params.std.nargs = 2U;
6000a076:	7243      	strb	r3, [r0, #9]
}
6000a078:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
6000a07c:	f7f9 bb28 	b.w	600036d0 <msg_finalize>
}
6000a080:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

6000a084 <log_3>:
{
6000a084:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
6000a088:	4680      	mov	r8, r0
6000a08a:	460f      	mov	r7, r1
6000a08c:	4616      	mov	r6, r2
6000a08e:	461d      	mov	r5, r3
6000a090:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
6000a094:	f7ff ff82 	bl	60009f9c <z_log_msg_std_alloc>

	if (msg != NULL) {
6000a098:	b170      	cbz	r0, 6000a0b8 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
6000a09a:	7a43      	ldrb	r3, [r0, #9]
6000a09c:	2203      	movs	r2, #3
		msg_finalize(msg, src_level);
6000a09e:	4649      	mov	r1, r9
		msg->str = str;
6000a0a0:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
6000a0a4:	f362 1307 	bfi	r3, r2, #4, #4
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
6000a0a8:	61c5      	str	r5, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
6000a0aa:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[1] = arg2;
6000a0ac:	e9c0 7605 	strd	r7, r6, [r0, #20]
}
6000a0b0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
6000a0b4:	f7f9 bb0c 	b.w	600036d0 <msg_finalize>
}
6000a0b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

6000a0bc <z_log_printk>:
{
6000a0bc:	b500      	push	{lr}
6000a0be:	b0a3      	sub	sp, #140	; 0x8c
6000a0c0:	4602      	mov	r2, r0
6000a0c2:	460b      	mov	r3, r1
			length = vsnprintk(str, sizeof(str), fmt, ap);
6000a0c4:	2181      	movs	r1, #129	; 0x81
6000a0c6:	a801      	add	r0, sp, #4
6000a0c8:	f7f8 fb6e 	bl	600027a8 <vsnprintk>
			msg = log_msg_hexdump_create(NULL, str, length);
6000a0cc:	2881      	cmp	r0, #129	; 0x81
6000a0ce:	4602      	mov	r2, r0
6000a0d0:	a901      	add	r1, sp, #4
6000a0d2:	bf28      	it	cs
6000a0d4:	2281      	movcs	r2, #129	; 0x81
6000a0d6:	2000      	movs	r0, #0
6000a0d8:	f000 f8a2 	bl	6000a220 <log_msg_hexdump_create>
			if (msg == NULL) {
6000a0dc:	b118      	cbz	r0, 6000a0e6 <z_log_printk+0x2a>
			msg_finalize(msg, src_level_union.structure);
6000a0de:	f04f 0100 	mov.w	r1, #0
6000a0e2:	f7f9 faf5 	bl	600036d0 <msg_finalize>
}
6000a0e6:	b023      	add	sp, #140	; 0x8c
6000a0e8:	f85d fb04 	ldr.w	pc, [sp], #4

6000a0ec <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
6000a0ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
6000a0f0:	461c      	mov	r4, r3
	uint32_t available_len = msg->hdr.params.hexdump.length;
6000a0f2:	8903      	ldrh	r3, [r0, #8]
{
6000a0f4:	460e      	mov	r6, r1
6000a0f6:	4611      	mov	r1, r2
	uint32_t available_len = msg->hdr.params.hexdump.length;
6000a0f8:	f3c3 028d 	ubfx	r2, r3, #2, #14
{
6000a0fc:	f89d 7020 	ldrb.w	r7, [sp, #32]
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
6000a100:	42a2      	cmp	r2, r4
6000a102:	d803      	bhi.n	6000a10c <log_msg_hexdump_data_op+0x20>
		*length = 0;
6000a104:	2300      	movs	r3, #0
6000a106:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
6000a108:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
6000a10c:	680b      	ldr	r3, [r1, #0]
6000a10e:	4423      	add	r3, r4
6000a110:	4293      	cmp	r3, r2
		*length = available_len - offset;
6000a112:	bf84      	itt	hi
6000a114:	1b13      	subhi	r3, r2, r4
6000a116:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
6000a118:	2a0c      	cmp	r2, #12
	req_len = *length;
6000a11a:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
6000a11e:	d92a      	bls.n	6000a176 <log_msg_hexdump_data_op+0x8a>
	if (offset < chunk_len) {
6000a120:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
6000a122:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
6000a126:	d82d      	bhi.n	6000a184 <log_msg_hexdump_data_op+0x98>
		head_data = msg->payload.ext.data.bytes;
6000a128:	3018      	adds	r0, #24
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
6000a12a:	2208      	movs	r2, #8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
6000a12c:	454a      	cmp	r2, r9
			(void)memcpy(&head_data[offset], data, cpy_len);
6000a12e:	4420      	add	r0, r4
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
6000a130:	bf28      	it	cs
6000a132:	464a      	movcs	r2, r9
6000a134:	4615      	mov	r5, r2
		if (put_op) {
6000a136:	b317      	cbz	r7, 6000a17e <log_msg_hexdump_data_op+0x92>
			(void)memcpy(&head_data[offset], data, cpy_len);
6000a138:	4631      	mov	r1, r6
		req_len -= cpy_len;
6000a13a:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
6000a13e:	442e      	add	r6, r5
			(void)memcpy(data, &head_data[offset], cpy_len);
6000a140:	f001 fc07 	bl	6000b952 <memcpy>
	while ((req_len > 0) && (cont != NULL)) {
6000a144:	f1b9 0f00 	cmp.w	r9, #0
6000a148:	d0de      	beq.n	6000a108 <log_msg_hexdump_data_op+0x1c>
6000a14a:	f1b8 0f00 	cmp.w	r8, #0
6000a14e:	d0db      	beq.n	6000a108 <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
6000a150:	f1c4 051c 	rsb	r5, r4, #28
			(void)memcpy(&cont->payload.bytes[offset],
6000a154:	1d20      	adds	r0, r4, #4
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
6000a156:	454d      	cmp	r5, r9
			(void)memcpy(&cont->payload.bytes[offset],
6000a158:	4440      	add	r0, r8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
6000a15a:	bf28      	it	cs
6000a15c:	464d      	movcs	r5, r9
			(void)memcpy(&cont->payload.bytes[offset],
6000a15e:	462a      	mov	r2, r5
		if (put_op) {
6000a160:	b1bf      	cbz	r7, 6000a192 <log_msg_hexdump_data_op+0xa6>
			(void)memcpy(&cont->payload.bytes[offset],
6000a162:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
6000a164:	f001 fbf5 	bl	6000b952 <memcpy>
		req_len -= cpy_len;
6000a168:	eba9 0905 	sub.w	r9, r9, r5
		cont = cont->next;
6000a16c:	f8d8 8000 	ldr.w	r8, [r8]
		data += cpy_len;
6000a170:	442e      	add	r6, r5
		offset = 0;
6000a172:	2400      	movs	r4, #0
6000a174:	e7e6      	b.n	6000a144 <log_msg_hexdump_data_op+0x58>
		head_data = msg->payload.single.bytes;
6000a176:	3014      	adds	r0, #20
	struct log_msg_cont *cont = NULL;
6000a178:	f04f 0800 	mov.w	r8, #0
6000a17c:	e7d6      	b.n	6000a12c <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
6000a17e:	4601      	mov	r1, r0
6000a180:	4630      	mov	r0, r6
6000a182:	e7da      	b.n	6000a13a <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
6000a184:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
6000a186:	2c1b      	cmp	r4, #27
6000a188:	d9dc      	bls.n	6000a144 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
6000a18a:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
6000a18e:	3c1c      	subs	r4, #28
6000a190:	e7f9      	b.n	6000a186 <log_msg_hexdump_data_op+0x9a>
			(void)memcpy(data, &cont->payload.bytes[offset],
6000a192:	4601      	mov	r1, r0
6000a194:	4630      	mov	r0, r6
6000a196:	e7e5      	b.n	6000a164 <log_msg_hexdump_data_op+0x78>

6000a198 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
6000a198:	3004      	adds	r0, #4
6000a19a:	f3bf 8f5b 	dmb	ish
6000a19e:	e850 3f00 	ldrex	r3, [r0]
6000a1a2:	3301      	adds	r3, #1
6000a1a4:	e840 3200 	strex	r2, r3, [r0]
6000a1a8:	2a00      	cmp	r2, #0
6000a1aa:	d1f8      	bne.n	6000a19e <log_msg_get+0x6>
6000a1ac:	f3bf 8f5b 	dmb	ish
}
6000a1b0:	4770      	bx	lr

6000a1b2 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
6000a1b2:	7a40      	ldrb	r0, [r0, #9]
}
6000a1b4:	0900      	lsrs	r0, r0, #4
6000a1b6:	4770      	bx	lr

6000a1b8 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
6000a1b8:	7a43      	ldrb	r3, [r0, #9]
6000a1ba:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
6000a1be:	ea4f 1213 	mov.w	r2, r3, lsr #4
6000a1c2:	d216      	bcs.n	6000a1f2 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
6000a1c4:	2a03      	cmp	r2, #3
6000a1c6:	d803      	bhi.n	6000a1d0 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
6000a1c8:	eb00 0081 	add.w	r0, r0, r1, lsl #2
6000a1cc:	6940      	ldr	r0, [r0, #20]
6000a1ce:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
6000a1d0:	2901      	cmp	r1, #1
6000a1d2:	d803      	bhi.n	6000a1dc <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
6000a1d4:	eb00 0081 	add.w	r0, r0, r1, lsl #2
6000a1d8:	6980      	ldr	r0, [r0, #24]
6000a1da:	4770      	bx	lr
	cont = msg->payload.ext.next;
6000a1dc:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
6000a1de:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
6000a1e0:	2906      	cmp	r1, #6
6000a1e2:	d803      	bhi.n	6000a1ec <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
6000a1e4:	eb03 0181 	add.w	r1, r3, r1, lsl #2
6000a1e8:	6848      	ldr	r0, [r1, #4]
6000a1ea:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
6000a1ec:	3907      	subs	r1, #7
		cont = cont->next;
6000a1ee:	681b      	ldr	r3, [r3, #0]
6000a1f0:	e7f6      	b.n	6000a1e0 <log_msg_arg_get+0x28>
		return 0;
6000a1f2:	2000      	movs	r0, #0
}
6000a1f4:	4770      	bx	lr

6000a1f6 <log_msg_put>:
{
6000a1f6:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
6000a1f8:	1d02      	adds	r2, r0, #4
6000a1fa:	f3bf 8f5b 	dmb	ish
6000a1fe:	e852 1f00 	ldrex	r1, [r2]
6000a202:	3901      	subs	r1, #1
6000a204:	e842 1c00 	strex	ip, r1, [r2]
6000a208:	f1bc 0f00 	cmp.w	ip, #0
6000a20c:	d1f7      	bne.n	6000a1fe <log_msg_put+0x8>
6000a20e:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
6000a212:	685b      	ldr	r3, [r3, #4]
6000a214:	b90b      	cbnz	r3, 6000a21a <log_msg_put+0x24>
		msg_free(msg);
6000a216:	f7f9 bb31 	b.w	6000387c <msg_free>
}
6000a21a:	4770      	bx	lr

6000a21c <log_msg_str_get>:
}
6000a21c:	6900      	ldr	r0, [r0, #16]
6000a21e:	4770      	bx	lr

6000a220 <log_msg_hexdump_create>:
{
6000a220:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
6000a224:	f643 75ff 	movw	r5, #16383	; 0x3fff
{
6000a228:	4680      	mov	r8, r0
6000a22a:	460e      	mov	r6, r1
6000a22c:	4617      	mov	r7, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
6000a22e:	4295      	cmp	r5, r2
6000a230:	bf28      	it	cs
6000a232:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
6000a234:	f7f9 fb0e 	bl	60003854 <log_msg_chunk_alloc>
	if (msg == NULL) {
6000a238:	4604      	mov	r4, r0
6000a23a:	b398      	cbz	r0, 6000a2a4 <log_msg_hexdump_create+0x84>
	msg->hdr.ref_cnt = 1;
6000a23c:	2301      	movs	r3, #1
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
6000a23e:	8902      	ldrh	r2, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
6000a240:	2f0c      	cmp	r7, #12
	msg->str = str;
6000a242:	f8c0 8010 	str.w	r8, [r0, #16]
	msg->hdr.ref_cnt = 1;
6000a246:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
6000a248:	ea4f 0385 	mov.w	r3, r5, lsl #2
6000a24c:	f002 0202 	and.w	r2, r2, #2
		(void)memcpy(msg->payload.single.bytes, data, length);
6000a250:	f100 0814 	add.w	r8, r0, #20
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
6000a254:	f043 0301 	orr.w	r3, r3, #1
6000a258:	ea43 0302 	orr.w	r3, r3, r2
6000a25c:	8103      	strh	r3, [r0, #8]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
6000a25e:	d918      	bls.n	6000a292 <log_msg_hexdump_create+0x72>
		(void)memcpy(msg->payload.ext.data.bytes,
6000a260:	4631      	mov	r1, r6
6000a262:	2208      	movs	r2, #8
6000a264:	3018      	adds	r0, #24
		msg->payload.ext.next = NULL;
6000a266:	f04f 0900 	mov.w	r9, #0
		(void)memcpy(msg->payload.ext.data.bytes,
6000a26a:	f001 fb72 	bl	6000b952 <memcpy>
		msg->hdr.params.generic.ext = 1;
6000a26e:	7a23      	ldrb	r3, [r4, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
6000a270:	3608      	adds	r6, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
6000a272:	3d08      	subs	r5, #8
		msg->hdr.params.generic.ext = 1;
6000a274:	f043 0302 	orr.w	r3, r3, #2
		msg->payload.ext.next = NULL;
6000a278:	f8c4 9014 	str.w	r9, [r4, #20]
		msg->hdr.params.generic.ext = 1;
6000a27c:	7223      	strb	r3, [r4, #8]
	while (length > 0) {
6000a27e:	b18d      	cbz	r5, 6000a2a4 <log_msg_hexdump_create+0x84>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
6000a280:	f7f9 fae8 	bl	60003854 <log_msg_chunk_alloc>
		if (cont == NULL) {
6000a284:	4607      	mov	r7, r0
6000a286:	b980      	cbnz	r0, 6000a2aa <log_msg_hexdump_create+0x8a>
			msg_free(msg);
6000a288:	4620      	mov	r0, r4
			return NULL;
6000a28a:	463c      	mov	r4, r7
			msg_free(msg);
6000a28c:	f7f9 faf6 	bl	6000387c <msg_free>
			return NULL;
6000a290:	e008      	b.n	6000a2a4 <log_msg_hexdump_create+0x84>
		(void)memcpy(msg->payload.single.bytes, data, length);
6000a292:	462a      	mov	r2, r5
6000a294:	4631      	mov	r1, r6
6000a296:	4640      	mov	r0, r8
6000a298:	f001 fb5b 	bl	6000b952 <memcpy>
		msg->hdr.params.generic.ext = 0;
6000a29c:	7a23      	ldrb	r3, [r4, #8]
6000a29e:	f36f 0341 	bfc	r3, #1, #1
6000a2a2:	7223      	strb	r3, [r4, #8]
}
6000a2a4:	4620      	mov	r0, r4
6000a2a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
6000a2aa:	2d1c      	cmp	r5, #28
6000a2ac:	462f      	mov	r7, r5
		*prev_cont = cont;
6000a2ae:	f8c8 0000 	str.w	r0, [r8]
		(void)memcpy(cont->payload.bytes, data, chunk_length);
6000a2b2:	4631      	mov	r1, r6
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
6000a2b4:	bf28      	it	cs
6000a2b6:	271c      	movcs	r7, #28
		cont->next = NULL;
6000a2b8:	f8c0 9000 	str.w	r9, [r0]
		prev_cont = &cont->next;
6000a2bc:	4680      	mov	r8, r0
		(void)memcpy(cont->payload.bytes, data, chunk_length);
6000a2be:	3004      	adds	r0, #4
6000a2c0:	463a      	mov	r2, r7
		data += chunk_length;
6000a2c2:	443e      	add	r6, r7
		length -= chunk_length;
6000a2c4:	1bed      	subs	r5, r5, r7
		(void)memcpy(cont->payload.bytes, data, chunk_length);
6000a2c6:	f001 fb44 	bl	6000b952 <memcpy>
		length -= chunk_length;
6000a2ca:	e7d8      	b.n	6000a27e <log_msg_hexdump_create+0x5e>

6000a2cc <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
6000a2cc:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
6000a2ce:	2400      	movs	r4, #0
6000a2d0:	9400      	str	r4, [sp, #0]
6000a2d2:	f7ff ff0b 	bl	6000a0ec <log_msg_hexdump_data_op>
}
6000a2d6:	b002      	add	sp, #8
6000a2d8:	bd10      	pop	{r4, pc}

6000a2da <buffer_write>:
{
6000a2da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000a2dc:	4606      	mov	r6, r0
6000a2de:	460d      	mov	r5, r1
6000a2e0:	4614      	mov	r4, r2
6000a2e2:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
6000a2e4:	4621      	mov	r1, r4
6000a2e6:	4628      	mov	r0, r5
6000a2e8:	463a      	mov	r2, r7
6000a2ea:	47b0      	blx	r6
	} while (len != 0);
6000a2ec:	1a24      	subs	r4, r4, r0
		buf += processed;
6000a2ee:	4405      	add	r5, r0
	} while (len != 0);
6000a2f0:	d1f8      	bne.n	6000a2e4 <buffer_write+0xa>
}
6000a2f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

6000a2f4 <std_print>:
{
6000a2f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
6000a2f8:	b08e      	sub	sp, #56	; 0x38
6000a2fa:	4680      	mov	r8, r0
6000a2fc:	460d      	mov	r5, r1
	for (i = 0; i < nargs; i++) {
6000a2fe:	f04f 0900 	mov.w	r9, #0
{
6000a302:	af0e      	add	r7, sp, #56	; 0x38
	const char *str = log_msg_str_get(msg);
6000a304:	f7ff ff8a 	bl	6000a21c <log_msg_str_get>
6000a308:	4606      	mov	r6, r0
	uint32_t nargs = log_msg_nargs_get(msg);
6000a30a:	4640      	mov	r0, r8
6000a30c:	f7ff ff51 	bl	6000a1b2 <log_msg_nargs_get>
6000a310:	4682      	mov	sl, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
6000a312:	0083      	lsls	r3, r0, #2
6000a314:	3307      	adds	r3, #7
6000a316:	f023 0307 	bic.w	r3, r3, #7
6000a31a:	ebad 0d03 	sub.w	sp, sp, r3
6000a31e:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
6000a320:	45d1      	cmp	r9, sl
6000a322:	d116      	bne.n	6000a352 <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
6000a324:	4640      	mov	r0, r8
6000a326:	f7ff ff44 	bl	6000a1b2 <log_msg_nargs_get>
6000a32a:	280f      	cmp	r0, #15
6000a32c:	d81e      	bhi.n	6000a36c <std_print+0x78>
6000a32e:	e8df f010 	tbh	[pc, r0, lsl #1]
6000a332:	0019      	.short	0x0019
6000a334:	00260020 	.word	0x00260020
6000a338:	0036002d 	.word	0x0036002d
6000a33c:	004e0041 	.word	0x004e0041
6000a340:	006e005d 	.word	0x006e005d
6000a344:	00960081 	.word	0x00960081
6000a348:	00c600ad 	.word	0x00c600ad
6000a34c:	00fe00e1 	.word	0x00fe00e1
6000a350:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
6000a352:	4649      	mov	r1, r9
6000a354:	4640      	mov	r0, r8
6000a356:	f7ff ff2f 	bl	6000a1b8 <log_msg_arg_get>
6000a35a:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
6000a35e:	f109 0901 	add.w	r9, r9, #1
6000a362:	e7dd      	b.n	6000a320 <std_print+0x2c>
		print_formatted(output, str);
6000a364:	4631      	mov	r1, r6
6000a366:	4628      	mov	r0, r5
6000a368:	f7f9 fac6 	bl	600038f8 <print_formatted>
}
6000a36c:	46bd      	mov	sp, r7
6000a36e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
6000a372:	6822      	ldr	r2, [r4, #0]
6000a374:	4631      	mov	r1, r6
6000a376:	4628      	mov	r0, r5
6000a378:	f7f9 fabe 	bl	600038f8 <print_formatted>
		break;
6000a37c:	e7f6      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1]);
6000a37e:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a382:	4631      	mov	r1, r6
6000a384:	4628      	mov	r0, r5
6000a386:	f7f9 fab7 	bl	600038f8 <print_formatted>
		break;
6000a38a:	e7ef      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2]);
6000a38c:	68a3      	ldr	r3, [r4, #8]
6000a38e:	4631      	mov	r1, r6
6000a390:	4628      	mov	r0, r5
6000a392:	9300      	str	r3, [sp, #0]
6000a394:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a398:	f7f9 faae 	bl	600038f8 <print_formatted>
		break;
6000a39c:	e7e6      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a39e:	68e3      	ldr	r3, [r4, #12]
6000a3a0:	4631      	mov	r1, r6
6000a3a2:	4628      	mov	r0, r5
6000a3a4:	9301      	str	r3, [sp, #4]
6000a3a6:	68a3      	ldr	r3, [r4, #8]
6000a3a8:	9300      	str	r3, [sp, #0]
6000a3aa:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a3ae:	f7f9 faa3 	bl	600038f8 <print_formatted>
		break;
6000a3b2:	e7db      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a3b4:	6923      	ldr	r3, [r4, #16]
6000a3b6:	4631      	mov	r1, r6
6000a3b8:	4628      	mov	r0, r5
6000a3ba:	9302      	str	r3, [sp, #8]
6000a3bc:	68e3      	ldr	r3, [r4, #12]
6000a3be:	9301      	str	r3, [sp, #4]
6000a3c0:	68a3      	ldr	r3, [r4, #8]
6000a3c2:	9300      	str	r3, [sp, #0]
6000a3c4:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a3c8:	f7f9 fa96 	bl	600038f8 <print_formatted>
		break;
6000a3cc:	e7ce      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a3ce:	6963      	ldr	r3, [r4, #20]
6000a3d0:	4631      	mov	r1, r6
6000a3d2:	4628      	mov	r0, r5
6000a3d4:	9303      	str	r3, [sp, #12]
6000a3d6:	6923      	ldr	r3, [r4, #16]
6000a3d8:	9302      	str	r3, [sp, #8]
6000a3da:	68e3      	ldr	r3, [r4, #12]
6000a3dc:	9301      	str	r3, [sp, #4]
6000a3de:	68a3      	ldr	r3, [r4, #8]
6000a3e0:	9300      	str	r3, [sp, #0]
6000a3e2:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a3e6:	f7f9 fa87 	bl	600038f8 <print_formatted>
		break;
6000a3ea:	e7bf      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a3ec:	69a3      	ldr	r3, [r4, #24]
6000a3ee:	4631      	mov	r1, r6
6000a3f0:	4628      	mov	r0, r5
6000a3f2:	9304      	str	r3, [sp, #16]
6000a3f4:	6963      	ldr	r3, [r4, #20]
6000a3f6:	9303      	str	r3, [sp, #12]
6000a3f8:	6923      	ldr	r3, [r4, #16]
6000a3fa:	9302      	str	r3, [sp, #8]
6000a3fc:	68e3      	ldr	r3, [r4, #12]
6000a3fe:	9301      	str	r3, [sp, #4]
6000a400:	68a3      	ldr	r3, [r4, #8]
6000a402:	9300      	str	r3, [sp, #0]
6000a404:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a408:	f7f9 fa76 	bl	600038f8 <print_formatted>
		break;
6000a40c:	e7ae      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a40e:	69e3      	ldr	r3, [r4, #28]
6000a410:	4631      	mov	r1, r6
6000a412:	4628      	mov	r0, r5
6000a414:	9305      	str	r3, [sp, #20]
6000a416:	69a3      	ldr	r3, [r4, #24]
6000a418:	9304      	str	r3, [sp, #16]
6000a41a:	6963      	ldr	r3, [r4, #20]
6000a41c:	9303      	str	r3, [sp, #12]
6000a41e:	6923      	ldr	r3, [r4, #16]
6000a420:	9302      	str	r3, [sp, #8]
6000a422:	68e3      	ldr	r3, [r4, #12]
6000a424:	9301      	str	r3, [sp, #4]
6000a426:	68a3      	ldr	r3, [r4, #8]
6000a428:	9300      	str	r3, [sp, #0]
6000a42a:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a42e:	f7f9 fa63 	bl	600038f8 <print_formatted>
		break;
6000a432:	e79b      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a434:	6a23      	ldr	r3, [r4, #32]
6000a436:	4631      	mov	r1, r6
6000a438:	4628      	mov	r0, r5
6000a43a:	9306      	str	r3, [sp, #24]
6000a43c:	69e3      	ldr	r3, [r4, #28]
6000a43e:	9305      	str	r3, [sp, #20]
6000a440:	69a3      	ldr	r3, [r4, #24]
6000a442:	9304      	str	r3, [sp, #16]
6000a444:	6963      	ldr	r3, [r4, #20]
6000a446:	9303      	str	r3, [sp, #12]
6000a448:	6923      	ldr	r3, [r4, #16]
6000a44a:	9302      	str	r3, [sp, #8]
6000a44c:	68e3      	ldr	r3, [r4, #12]
6000a44e:	9301      	str	r3, [sp, #4]
6000a450:	68a3      	ldr	r3, [r4, #8]
6000a452:	9300      	str	r3, [sp, #0]
6000a454:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a458:	f7f9 fa4e 	bl	600038f8 <print_formatted>
		break;
6000a45c:	e786      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a45e:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000a460:	4631      	mov	r1, r6
6000a462:	4628      	mov	r0, r5
6000a464:	9307      	str	r3, [sp, #28]
6000a466:	6a23      	ldr	r3, [r4, #32]
6000a468:	9306      	str	r3, [sp, #24]
6000a46a:	69e3      	ldr	r3, [r4, #28]
6000a46c:	9305      	str	r3, [sp, #20]
6000a46e:	69a3      	ldr	r3, [r4, #24]
6000a470:	9304      	str	r3, [sp, #16]
6000a472:	6963      	ldr	r3, [r4, #20]
6000a474:	9303      	str	r3, [sp, #12]
6000a476:	6923      	ldr	r3, [r4, #16]
6000a478:	9302      	str	r3, [sp, #8]
6000a47a:	68e3      	ldr	r3, [r4, #12]
6000a47c:	9301      	str	r3, [sp, #4]
6000a47e:	68a3      	ldr	r3, [r4, #8]
6000a480:	9300      	str	r3, [sp, #0]
6000a482:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a486:	f7f9 fa37 	bl	600038f8 <print_formatted>
		break;
6000a48a:	e76f      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a48c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
6000a48e:	4631      	mov	r1, r6
6000a490:	4628      	mov	r0, r5
6000a492:	9308      	str	r3, [sp, #32]
6000a494:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000a496:	9307      	str	r3, [sp, #28]
6000a498:	6a23      	ldr	r3, [r4, #32]
6000a49a:	9306      	str	r3, [sp, #24]
6000a49c:	69e3      	ldr	r3, [r4, #28]
6000a49e:	9305      	str	r3, [sp, #20]
6000a4a0:	69a3      	ldr	r3, [r4, #24]
6000a4a2:	9304      	str	r3, [sp, #16]
6000a4a4:	6963      	ldr	r3, [r4, #20]
6000a4a6:	9303      	str	r3, [sp, #12]
6000a4a8:	6923      	ldr	r3, [r4, #16]
6000a4aa:	9302      	str	r3, [sp, #8]
6000a4ac:	68e3      	ldr	r3, [r4, #12]
6000a4ae:	9301      	str	r3, [sp, #4]
6000a4b0:	68a3      	ldr	r3, [r4, #8]
6000a4b2:	9300      	str	r3, [sp, #0]
6000a4b4:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a4b8:	f7f9 fa1e 	bl	600038f8 <print_formatted>
		break;
6000a4bc:	e756      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a4be:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
6000a4c0:	4631      	mov	r1, r6
6000a4c2:	4628      	mov	r0, r5
6000a4c4:	9309      	str	r3, [sp, #36]	; 0x24
6000a4c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
6000a4c8:	9308      	str	r3, [sp, #32]
6000a4ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000a4cc:	9307      	str	r3, [sp, #28]
6000a4ce:	6a23      	ldr	r3, [r4, #32]
6000a4d0:	9306      	str	r3, [sp, #24]
6000a4d2:	69e3      	ldr	r3, [r4, #28]
6000a4d4:	9305      	str	r3, [sp, #20]
6000a4d6:	69a3      	ldr	r3, [r4, #24]
6000a4d8:	9304      	str	r3, [sp, #16]
6000a4da:	6963      	ldr	r3, [r4, #20]
6000a4dc:	9303      	str	r3, [sp, #12]
6000a4de:	6923      	ldr	r3, [r4, #16]
6000a4e0:	9302      	str	r3, [sp, #8]
6000a4e2:	68e3      	ldr	r3, [r4, #12]
6000a4e4:	9301      	str	r3, [sp, #4]
6000a4e6:	68a3      	ldr	r3, [r4, #8]
6000a4e8:	9300      	str	r3, [sp, #0]
6000a4ea:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a4ee:	f7f9 fa03 	bl	600038f8 <print_formatted>
		break;
6000a4f2:	e73b      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a4f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
6000a4f6:	4631      	mov	r1, r6
6000a4f8:	4628      	mov	r0, r5
6000a4fa:	930a      	str	r3, [sp, #40]	; 0x28
6000a4fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
6000a4fe:	9309      	str	r3, [sp, #36]	; 0x24
6000a500:	6aa3      	ldr	r3, [r4, #40]	; 0x28
6000a502:	9308      	str	r3, [sp, #32]
6000a504:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000a506:	9307      	str	r3, [sp, #28]
6000a508:	6a23      	ldr	r3, [r4, #32]
6000a50a:	9306      	str	r3, [sp, #24]
6000a50c:	69e3      	ldr	r3, [r4, #28]
6000a50e:	9305      	str	r3, [sp, #20]
6000a510:	69a3      	ldr	r3, [r4, #24]
6000a512:	9304      	str	r3, [sp, #16]
6000a514:	6963      	ldr	r3, [r4, #20]
6000a516:	9303      	str	r3, [sp, #12]
6000a518:	6923      	ldr	r3, [r4, #16]
6000a51a:	9302      	str	r3, [sp, #8]
6000a51c:	68e3      	ldr	r3, [r4, #12]
6000a51e:	9301      	str	r3, [sp, #4]
6000a520:	68a3      	ldr	r3, [r4, #8]
6000a522:	9300      	str	r3, [sp, #0]
6000a524:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a528:	f7f9 f9e6 	bl	600038f8 <print_formatted>
		break;
6000a52c:	e71e      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a52e:	6b63      	ldr	r3, [r4, #52]	; 0x34
6000a530:	4631      	mov	r1, r6
6000a532:	4628      	mov	r0, r5
6000a534:	930b      	str	r3, [sp, #44]	; 0x2c
6000a536:	6b23      	ldr	r3, [r4, #48]	; 0x30
6000a538:	930a      	str	r3, [sp, #40]	; 0x28
6000a53a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
6000a53c:	9309      	str	r3, [sp, #36]	; 0x24
6000a53e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
6000a540:	9308      	str	r3, [sp, #32]
6000a542:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000a544:	9307      	str	r3, [sp, #28]
6000a546:	6a23      	ldr	r3, [r4, #32]
6000a548:	9306      	str	r3, [sp, #24]
6000a54a:	69e3      	ldr	r3, [r4, #28]
6000a54c:	9305      	str	r3, [sp, #20]
6000a54e:	69a3      	ldr	r3, [r4, #24]
6000a550:	9304      	str	r3, [sp, #16]
6000a552:	6963      	ldr	r3, [r4, #20]
6000a554:	9303      	str	r3, [sp, #12]
6000a556:	6923      	ldr	r3, [r4, #16]
6000a558:	9302      	str	r3, [sp, #8]
6000a55a:	68e3      	ldr	r3, [r4, #12]
6000a55c:	9301      	str	r3, [sp, #4]
6000a55e:	68a3      	ldr	r3, [r4, #8]
6000a560:	9300      	str	r3, [sp, #0]
6000a562:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a566:	f7f9 f9c7 	bl	600038f8 <print_formatted>
		break;
6000a56a:	e6ff      	b.n	6000a36c <std_print+0x78>
		print_formatted(output, str, args[0], args[1], args[2],
6000a56c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
6000a56e:	4631      	mov	r1, r6
6000a570:	4628      	mov	r0, r5
6000a572:	930c      	str	r3, [sp, #48]	; 0x30
6000a574:	6b63      	ldr	r3, [r4, #52]	; 0x34
6000a576:	930b      	str	r3, [sp, #44]	; 0x2c
6000a578:	6b23      	ldr	r3, [r4, #48]	; 0x30
6000a57a:	930a      	str	r3, [sp, #40]	; 0x28
6000a57c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
6000a57e:	9309      	str	r3, [sp, #36]	; 0x24
6000a580:	6aa3      	ldr	r3, [r4, #40]	; 0x28
6000a582:	9308      	str	r3, [sp, #32]
6000a584:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000a586:	9307      	str	r3, [sp, #28]
6000a588:	6a23      	ldr	r3, [r4, #32]
6000a58a:	9306      	str	r3, [sp, #24]
6000a58c:	69e3      	ldr	r3, [r4, #28]
6000a58e:	9305      	str	r3, [sp, #20]
6000a590:	69a3      	ldr	r3, [r4, #24]
6000a592:	9304      	str	r3, [sp, #16]
6000a594:	6963      	ldr	r3, [r4, #20]
6000a596:	9303      	str	r3, [sp, #12]
6000a598:	6923      	ldr	r3, [r4, #16]
6000a59a:	9302      	str	r3, [sp, #8]
6000a59c:	68e3      	ldr	r3, [r4, #12]
6000a59e:	9301      	str	r3, [sp, #4]
6000a5a0:	68a3      	ldr	r3, [r4, #8]
6000a5a2:	9300      	str	r3, [sp, #0]
6000a5a4:	e9d4 2300 	ldrd	r2, r3, [r4]
6000a5a8:	f7f9 f9a6 	bl	600038f8 <print_formatted>
}
6000a5ac:	e6de      	b.n	6000a36c <std_print+0x78>

6000a5ae <log_output_flush>:
		     output->control_block->offset,
6000a5ae:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
6000a5b0:	6881      	ldr	r1, [r0, #8]
{
6000a5b2:	b510      	push	{r4, lr}
6000a5b4:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
6000a5b6:	6800      	ldr	r0, [r0, #0]
6000a5b8:	e9d2 2300 	ldrd	r2, r3, [r2]
6000a5bc:	f7ff fe8d 	bl	6000a2da <buffer_write>
	output->control_block->offset = 0;
6000a5c0:	6863      	ldr	r3, [r4, #4]
6000a5c2:	2200      	movs	r2, #0
6000a5c4:	601a      	str	r2, [r3, #0]
}
6000a5c6:	bd10      	pop	{r4, pc}

6000a5c8 <out_func>:
{
6000a5c8:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
6000a5ca:	684b      	ldr	r3, [r1, #4]
{
6000a5cc:	4605      	mov	r5, r0
6000a5ce:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
6000a5d0:	681a      	ldr	r2, [r3, #0]
6000a5d2:	68cb      	ldr	r3, [r1, #12]
6000a5d4:	429a      	cmp	r2, r3
6000a5d6:	d102      	bne.n	6000a5de <out_func+0x16>
		log_output_flush(out_ctx);
6000a5d8:	4608      	mov	r0, r1
6000a5da:	f7ff ffe8 	bl	6000a5ae <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
6000a5de:	6863      	ldr	r3, [r4, #4]
6000a5e0:	f3bf 8f5b 	dmb	ish
6000a5e4:	e853 2f00 	ldrex	r2, [r3]
6000a5e8:	1c51      	adds	r1, r2, #1
6000a5ea:	e843 1000 	strex	r0, r1, [r3]
6000a5ee:	2800      	cmp	r0, #0
6000a5f0:	d1f8      	bne.n	6000a5e4 <out_func+0x1c>
6000a5f2:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (uint8_t)c;
6000a5f6:	68a3      	ldr	r3, [r4, #8]
}
6000a5f8:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (uint8_t)c;
6000a5fa:	549d      	strb	r5, [r3, r2]
}
6000a5fc:	bd38      	pop	{r3, r4, r5, pc}

6000a5fe <log_halt>:
6000a5fe:	684b      	ldr	r3, [r1, #4]
6000a600:	2000      	movs	r0, #0
6000a602:	7158      	strb	r0, [r3, #5]
}
6000a604:	4770      	bx	lr

6000a606 <log_go>:
	backend->cb->active = true;
6000a606:	684b      	ldr	r3, [r1, #4]
6000a608:	2201      	movs	r2, #1
}
6000a60a:	2000      	movs	r0, #0
6000a60c:	715a      	strb	r2, [r3, #5]
6000a60e:	4770      	bx	lr

6000a610 <cmd_log_self_status>:
{
6000a610:	b570      	push	{r4, r5, r6, lr}
6000a612:	4604      	mov	r4, r0
6000a614:	460d      	mov	r5, r1
6000a616:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
6000a618:	f7f9 fc82 	bl	60003f20 <shell_state_precheck>
6000a61c:	b130      	cbz	r0, 6000a62c <cmd_log_self_status+0x1c>
	log_status(shell, shell->log_backend->backend, argc, argv);
6000a61e:	69e1      	ldr	r1, [r4, #28]
6000a620:	4633      	mov	r3, r6
6000a622:	462a      	mov	r2, r5
6000a624:	4620      	mov	r0, r4
6000a626:	6809      	ldr	r1, [r1, #0]
6000a628:	f7f9 fbb2 	bl	60003d90 <log_status>
}
6000a62c:	2000      	movs	r0, #0
6000a62e:	bd70      	pop	{r4, r5, r6, pc}

6000a630 <cmd_log_self_enable>:
{
6000a630:	b570      	push	{r4, r5, r6, lr}
6000a632:	4604      	mov	r4, r0
6000a634:	460d      	mov	r5, r1
6000a636:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
6000a638:	f7f9 fc72 	bl	60003f20 <shell_state_precheck>
6000a63c:	b140      	cbz	r0, 6000a650 <cmd_log_self_enable+0x20>
	return log_enable(shell, shell->log_backend->backend, argc, argv);
6000a63e:	69e1      	ldr	r1, [r4, #28]
6000a640:	4633      	mov	r3, r6
6000a642:	462a      	mov	r2, r5
6000a644:	4620      	mov	r0, r4
6000a646:	6809      	ldr	r1, [r1, #0]
}
6000a648:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return log_enable(shell, shell->log_backend->backend, argc, argv);
6000a64c:	f7f9 bce2 	b.w	60004014 <log_enable>
}
6000a650:	bd70      	pop	{r4, r5, r6, pc}

6000a652 <log_disable>:
{
6000a652:	b513      	push	{r0, r1, r4, lr}
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
6000a654:	2400      	movs	r4, #0
6000a656:	3304      	adds	r3, #4
6000a658:	3a01      	subs	r2, #1
6000a65a:	9400      	str	r4, [sp, #0]
6000a65c:	f7f9 fc70 	bl	60003f40 <filters_set>
}
6000a660:	4620      	mov	r0, r4
6000a662:	b002      	add	sp, #8
6000a664:	bd10      	pop	{r4, pc}

6000a666 <cmd_log_self_disable>:
{
6000a666:	b570      	push	{r4, r5, r6, lr}
6000a668:	4604      	mov	r4, r0
6000a66a:	460d      	mov	r5, r1
6000a66c:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
6000a66e:	f7f9 fc57 	bl	60003f20 <shell_state_precheck>
6000a672:	b140      	cbz	r0, 6000a686 <cmd_log_self_disable+0x20>
	return log_disable(shell, shell->log_backend->backend, argc, argv);
6000a674:	69e1      	ldr	r1, [r4, #28]
6000a676:	4633      	mov	r3, r6
6000a678:	462a      	mov	r2, r5
6000a67a:	4620      	mov	r0, r4
6000a67c:	6809      	ldr	r1, [r1, #0]
}
6000a67e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return log_disable(shell, shell->log_backend->backend, argc, argv);
6000a682:	f7ff bfe6 	b.w	6000a652 <log_disable>
}
6000a686:	bd70      	pop	{r4, r5, r6, pc}

6000a688 <cmd_log_self_go>:
{
6000a688:	b510      	push	{r4, lr}
6000a68a:	4604      	mov	r4, r0
	if (!shell_state_precheck(shell)) {
6000a68c:	f7f9 fc48 	bl	60003f20 <shell_state_precheck>
6000a690:	b120      	cbz	r0, 6000a69c <cmd_log_self_go+0x14>
	return log_go(shell, shell->log_backend->backend, argc, argv);
6000a692:	69e3      	ldr	r3, [r4, #28]
6000a694:	2201      	movs	r2, #1
	log_backend_activate(backend, backend->cb->ctx);
6000a696:	681b      	ldr	r3, [r3, #0]
6000a698:	685b      	ldr	r3, [r3, #4]
6000a69a:	715a      	strb	r2, [r3, #5]
}
6000a69c:	2000      	movs	r0, #0
6000a69e:	bd10      	pop	{r4, pc}

6000a6a0 <cmd_log_self_halt>:
{
6000a6a0:	b510      	push	{r4, lr}
6000a6a2:	4604      	mov	r4, r0
	if (!shell_state_precheck(shell)) {
6000a6a4:	f7f9 fc3c 	bl	60003f20 <shell_state_precheck>
6000a6a8:	b120      	cbz	r0, 6000a6b4 <cmd_log_self_halt+0x14>
	return log_halt(shell, shell->log_backend->backend, argc, argv);
6000a6aa:	69e3      	ldr	r3, [r4, #28]
	backend->cb->active = false;
6000a6ac:	2200      	movs	r2, #0
6000a6ae:	681b      	ldr	r3, [r3, #0]
6000a6b0:	685b      	ldr	r3, [r3, #4]
6000a6b2:	715a      	strb	r2, [r3, #5]
}
6000a6b4:	2000      	movs	r0, #0
6000a6b6:	bd10      	pop	{r4, pc}

6000a6b8 <atomic_or>:
 * @param value Value to OR.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
6000a6b8:	4603      	mov	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
}
6000a6ba:	f3bf 8f5b 	dmb	ish
6000a6be:	e853 0f00 	ldrex	r0, [r3]
6000a6c2:	ea40 0201 	orr.w	r2, r0, r1
6000a6c6:	e843 2c00 	strex	ip, r2, [r3]
6000a6ca:	f1bc 0f00 	cmp.w	ip, #0
6000a6ce:	d1f6      	bne.n	6000a6be <atomic_or+0x6>
6000a6d0:	f3bf 8f5b 	dmb	ish
6000a6d4:	4770      	bx	lr

6000a6d6 <atomic_and>:
 * @param value Value to AND.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
6000a6d6:	4603      	mov	r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
}
6000a6d8:	f3bf 8f5b 	dmb	ish
6000a6dc:	e853 0f00 	ldrex	r0, [r3]
6000a6e0:	ea00 0201 	and.w	r2, r0, r1
6000a6e4:	e843 2c00 	strex	ip, r2, [r3]
6000a6e8:	f1bc 0f00 	cmp.w	ip, #0
6000a6ec:	d1f6      	bne.n	6000a6dc <atomic_and+0x6>
6000a6ee:	f3bf 8f5b 	dmb	ish
6000a6f2:	4770      	bx	lr

6000a6f4 <shell_signal_handle>:
{
6000a6f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
6000a6f6:	3126      	adds	r1, #38	; 0x26
6000a6f8:	6885      	ldr	r5, [r0, #8]
{
6000a6fa:	4604      	mov	r4, r0
6000a6fc:	4616      	mov	r6, r2
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
6000a6fe:	eb05 1501 	add.w	r5, r5, r1, lsl #4
		arch_syscall_invoke3(*(uintptr_t *)&sig, *(uintptr_t *)&signaled, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
6000a702:	aa01      	add	r2, sp, #4
6000a704:	4669      	mov	r1, sp
6000a706:	4628      	mov	r0, r5
6000a708:	f002 f8ba 	bl	6000c880 <z_impl_k_poll_signal_check>
	if (set) {
6000a70c:	9b00      	ldr	r3, [sp, #0]
6000a70e:	b123      	cbz	r3, 6000a71a <shell_signal_handle+0x26>
	z_impl_k_poll_signal_reset(sig);
6000a710:	4628      	mov	r0, r5
6000a712:	f002 f8b2 	bl	6000c87a <z_impl_k_poll_signal_reset>
		handler(shell);
6000a716:	4620      	mov	r0, r4
6000a718:	47b0      	blx	r6
}
6000a71a:	b002      	add	sp, #8
6000a71c:	bd70      	pop	{r4, r5, r6, pc}

6000a71e <z_shell_strlen>:
{
6000a71e:	b508      	push	{r3, lr}
	return str == NULL ? 0U : (uint16_t)strlen(str);
6000a720:	b110      	cbz	r0, 6000a728 <z_shell_strlen+0xa>
6000a722:	f001 f8c0 	bl	6000b8a6 <strlen>
6000a726:	b280      	uxth	r0, r0
}
6000a728:	bd08      	pop	{r3, pc}

6000a72a <z_shell_raw_fprintf>:
{
6000a72a:	b40e      	push	{r1, r2, r3}
6000a72c:	b503      	push	{r0, r1, lr}
6000a72e:	aa03      	add	r2, sp, #12
6000a730:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
6000a734:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
6000a736:	f7fa fd67 	bl	60005208 <z_shell_fprintf_fmt>
}
6000a73a:	b002      	add	sp, #8
6000a73c:	f85d eb04 	ldr.w	lr, [sp], #4
6000a740:	b003      	add	sp, #12
6000a742:	4770      	bx	lr

6000a744 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
6000a744:	f7fd bf76 	b.w	60008634 <z_impl_k_mutex_lock>

6000a748 <transport_evt_handler>:
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
6000a748:	688b      	ldr	r3, [r1, #8]
6000a74a:	b920      	cbnz	r0, 6000a756 <transport_evt_handler+0xe>
6000a74c:	f503 7018 	add.w	r0, r3, #608	; 0x260
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
6000a750:	2100      	movs	r1, #0
6000a752:	f7fe bf21 	b.w	60009598 <z_impl_k_poll_signal_raise>
6000a756:	f503 7024 	add.w	r0, r3, #656	; 0x290
6000a75a:	e7f9      	b.n	6000a750 <transport_evt_handler+0x8>

6000a75c <kill_handler>:
{
6000a75c:	b538      	push	{r3, r4, r5, lr}
	return shell->ctx->internal.flags.processing == 1;
6000a75e:	6883      	ldr	r3, [r0, #8]
6000a760:	4604      	mov	r4, r0
6000a762:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
	if (z_flag_processing_get(shell)) {
6000a766:	06db      	lsls	r3, r3, #27
6000a768:	d41d      	bmi.n	6000a7a6 <kill_handler+0x4a>
		z_shell_log_backend_disable(shell->log_backend);
6000a76a:	69c0      	ldr	r0, [r0, #28]
6000a76c:	f000 ff5a 	bl	6000b624 <z_shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
6000a770:	6860      	ldr	r0, [r4, #4]
6000a772:	6803      	ldr	r3, [r0, #0]
6000a774:	685b      	ldr	r3, [r3, #4]
6000a776:	4798      	blx	r3
	if (err != 0) {
6000a778:	4605      	mov	r5, r0
6000a77a:	b920      	cbnz	r0, 6000a786 <kill_handler+0x2a>
	z_shell_history_purge(shell->history);
6000a77c:	68e0      	ldr	r0, [r4, #12]
6000a77e:	f000 fe15 	bl	6000b3ac <z_shell_history_purge>
	shell->ctx->state = state;
6000a782:	68a3      	ldr	r3, [r4, #8]
6000a784:	711d      	strb	r5, [r3, #4]
	if (shell->ctx->uninit_cb) {
6000a786:	68a3      	ldr	r3, [r4, #8]
6000a788:	6b5b      	ldr	r3, [r3, #52]	; 0x34
6000a78a:	b113      	cbz	r3, 6000a792 <kill_handler+0x36>
		shell->ctx->uninit_cb(shell, err);
6000a78c:	4629      	mov	r1, r5
6000a78e:	4620      	mov	r0, r4
6000a790:	4798      	blx	r3
	shell->ctx->tid = NULL;
6000a792:	68a3      	ldr	r3, [r4, #8]
6000a794:	2200      	movs	r2, #0
6000a796:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	return z_impl_k_current_get();
6000a79a:	f7fe fbb7 	bl	60008f0c <z_impl_k_current_get>
}
6000a79e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_thread_abort(thread);
6000a7a2:	f7fc b895 	b.w	600068d0 <z_impl_k_thread_abort>
		return -EBUSY;
6000a7a6:	f06f 050f 	mvn.w	r5, #15
6000a7aa:	e7ec      	b.n	6000a786 <kill_handler+0x2a>

6000a7ac <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, history_exit, val, ret);
6000a7ac:	f500 7017 	add.w	r0, r0, #604	; 0x25c
6000a7b0:	b111      	cbz	r1, 6000a7b8 <z_flag_history_exit_set.isra.0+0xc>
6000a7b2:	2180      	movs	r1, #128	; 0x80
6000a7b4:	f7ff bf80 	b.w	6000a6b8 <atomic_or>
6000a7b8:	f06f 0180 	mvn.w	r1, #128	; 0x80
6000a7bc:	f7ff bf8b 	b.w	6000a6d6 <atomic_and>

6000a7c0 <z_flag_insert_mode_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(shell, insert_mode, val, ret);
6000a7c0:	f500 7017 	add.w	r0, r0, #604	; 0x25c
static inline bool z_flag_insert_mode_set(const struct shell *shell, bool val)
6000a7c4:	b508      	push	{r3, lr}
	Z_SHELL_SET_FLAG_ATOMIC(shell, insert_mode, val, ret);
6000a7c6:	b129      	cbz	r1, 6000a7d4 <z_flag_insert_mode_set.isra.0+0x14>
6000a7c8:	2101      	movs	r1, #1
6000a7ca:	f7ff ff75 	bl	6000a6b8 <atomic_or>
}
6000a7ce:	f000 0001 	and.w	r0, r0, #1
6000a7d2:	bd08      	pop	{r3, pc}
	Z_SHELL_SET_FLAG_ATOMIC(shell, insert_mode, val, ret);
6000a7d4:	f06f 0101 	mvn.w	r1, #1
6000a7d8:	f7ff ff7d 	bl	6000a6d6 <atomic_and>
6000a7dc:	e7f7      	b.n	6000a7ce <z_flag_insert_mode_set.isra.0+0xe>

6000a7de <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
6000a7de:	f7fd bfb3 	b.w	60008748 <z_impl_k_mutex_unlock>

6000a7e2 <shell_log_process>:
{
6000a7e2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int signaled = 0;
6000a7e4:	2300      	movs	r3, #0
{
6000a7e6:	4604      	mov	r4, r0
	int signaled = 0;
6000a7e8:	9300      	str	r3, [sp, #0]
			z_shell_cmd_line_erase(shell);
6000a7ea:	4620      	mov	r0, r4
6000a7ec:	f000 fb5a 	bl	6000aea4 <z_shell_cmd_line_erase>
			processed = z_shell_log_backend_process(
6000a7f0:	69e0      	ldr	r0, [r4, #28]
6000a7f2:	f000 ff20 	bl	6000b636 <z_shell_log_backend_process>
6000a7f6:	4605      	mov	r5, r0
		z_shell_print_prompt_and_cmd(shell);
6000a7f8:	4620      	mov	r0, r4
		struct k_poll_signal *signal =
6000a7fa:	68a6      	ldr	r6, [r4, #8]
		z_shell_print_prompt_and_cmd(shell);
6000a7fc:	f7fa fe9c 	bl	60005538 <z_shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
6000a800:	68a3      	ldr	r3, [r4, #8]
		struct k_poll_signal *signal =
6000a802:	f506 7618 	add.w	r6, r6, #608	; 0x260
		if (shell->ctx->cmd_buff_len) {
6000a806:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
6000a808:	b11b      	cbz	r3, 6000a812 <shell_log_process+0x30>
	return z_impl_k_sleep(timeout);
6000a80a:	2096      	movs	r0, #150	; 0x96
6000a80c:	2100      	movs	r1, #0
6000a80e:	f7fe fb4f 	bl	60008eb0 <z_impl_k_sleep>
	z_impl_k_poll_signal_check(sig, signaled, result);
6000a812:	aa01      	add	r2, sp, #4
6000a814:	4669      	mov	r1, sp
6000a816:	4630      	mov	r0, r6
6000a818:	f002 f832 	bl	6000c880 <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
6000a81c:	b115      	cbz	r5, 6000a824 <shell_log_process+0x42>
6000a81e:	9b00      	ldr	r3, [sp, #0]
6000a820:	2b00      	cmp	r3, #0
6000a822:	d0e2      	beq.n	6000a7ea <shell_log_process+0x8>
}
6000a824:	b002      	add	sp, #8
6000a826:	bd70      	pop	{r4, r5, r6, pc}

6000a828 <shell_vfprintf>:
{
6000a828:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000a82a:	4604      	mov	r4, r0
	return shell->ctx->state;
6000a82c:	6880      	ldr	r0, [r0, #8]
{
6000a82e:	461f      	mov	r7, r3
6000a830:	460d      	mov	r5, r1
	if (state_get(shell) != SHELL_STATE_ACTIVE) {
6000a832:	7903      	ldrb	r3, [r0, #4]
{
6000a834:	4616      	mov	r6, r2
	if (state_get(shell) != SHELL_STATE_ACTIVE) {
6000a836:	2b02      	cmp	r3, #2
6000a838:	d007      	beq.n	6000a84a <shell_vfprintf+0x22>
	Z_SHELL_SET_FLAG_ATOMIC(shell, print_noinit, val, ret);
6000a83a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
6000a83e:	f500 7017 	add.w	r0, r0, #604	; 0x25c
}
6000a842:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
6000a846:	f7ff bf37 	b.w	6000a6b8 <atomic_or>
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
6000a84a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
6000a84e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
6000a852:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
6000a856:	f7ff ff75 	bl	6000a744 <k_mutex_lock.constprop.0.isra.0>
	return shell->ctx->internal.flags.cmd_ctx == 1;
6000a85a:	68a3      	ldr	r3, [r4, #8]
6000a85c:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
	if (!z_flag_cmd_ctx_get(shell)) {
6000a860:	03da      	lsls	r2, r3, #15
6000a862:	d402      	bmi.n	6000a86a <shell_vfprintf+0x42>
		z_shell_cmd_line_erase(shell);
6000a864:	4620      	mov	r0, r4
6000a866:	f000 fb1d 	bl	6000aea4 <z_shell_cmd_line_erase>
	z_shell_vfprintf(shell, color, fmt, args);
6000a86a:	463b      	mov	r3, r7
6000a86c:	4632      	mov	r2, r6
6000a86e:	4629      	mov	r1, r5
6000a870:	4620      	mov	r0, r4
6000a872:	f000 fb72 	bl	6000af5a <z_shell_vfprintf>
6000a876:	68a3      	ldr	r3, [r4, #8]
6000a878:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
	if (!z_flag_cmd_ctx_get(shell)) {
6000a87c:	03db      	lsls	r3, r3, #15
6000a87e:	d402      	bmi.n	6000a886 <shell_vfprintf+0x5e>
		z_shell_print_prompt_and_cmd(shell);
6000a880:	4620      	mov	r0, r4
6000a882:	f7fa fe59 	bl	60005538 <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
6000a886:	6960      	ldr	r0, [r4, #20]
6000a888:	f000 f814 	bl	6000a8b4 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&shell->ctx->wr_mtx);
6000a88c:	68a0      	ldr	r0, [r4, #8]
}
6000a88e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	k_mutex_unlock(&shell->ctx->wr_mtx);
6000a892:	f500 703c 	add.w	r0, r0, #752	; 0x2f0
6000a896:	f7ff bfa2 	b.w	6000a7de <k_mutex_unlock.isra.0>

6000a89a <shell_fprintf>:
{
6000a89a:	b40c      	push	{r2, r3}
6000a89c:	b507      	push	{r0, r1, r2, lr}
6000a89e:	ab04      	add	r3, sp, #16
6000a8a0:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
6000a8a4:	9301      	str	r3, [sp, #4]
	shell_vfprintf(shell, color, fmt, args);
6000a8a6:	f7ff ffbf 	bl	6000a828 <shell_vfprintf>
}
6000a8aa:	b003      	add	sp, #12
6000a8ac:	f85d eb04 	ldr.w	lr, [sp], #4
6000a8b0:	b002      	add	sp, #8
6000a8b2:	4770      	bx	lr

6000a8b4 <z_shell_fprintf_buffer_flush>:


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
6000a8b4:	6902      	ldr	r2, [r0, #16]
6000a8b6:	6883      	ldr	r3, [r0, #8]
6000a8b8:	6812      	ldr	r2, [r2, #0]
6000a8ba:	6801      	ldr	r1, [r0, #0]
{
6000a8bc:	b510      	push	{r4, lr}
6000a8be:	4604      	mov	r4, r0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
6000a8c0:	68c0      	ldr	r0, [r0, #12]
6000a8c2:	4798      	blx	r3
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
6000a8c4:	2200      	movs	r2, #0
6000a8c6:	6923      	ldr	r3, [r4, #16]
6000a8c8:	601a      	str	r2, [r3, #0]
}
6000a8ca:	bd10      	pop	{r4, pc}

6000a8cc <out_func>:
{
6000a8cc:	b538      	push	{r3, r4, r5, lr}
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
6000a8ce:	68cb      	ldr	r3, [r1, #12]
{
6000a8d0:	4605      	mov	r5, r0
6000a8d2:	460c      	mov	r4, r1
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
6000a8d4:	7c1b      	ldrb	r3, [r3, #16]
6000a8d6:	2b02      	cmp	r3, #2
6000a8d8:	d104      	bne.n	6000a8e4 <out_func+0x18>
6000a8da:	280a      	cmp	r0, #10
6000a8dc:	d102      	bne.n	6000a8e4 <out_func+0x18>
		(void)out_func('\r', ctx);
6000a8de:	200d      	movs	r0, #13
6000a8e0:	f7ff fff4 	bl	6000a8cc <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
6000a8e4:	6923      	ldr	r3, [r4, #16]
6000a8e6:	6822      	ldr	r2, [r4, #0]
6000a8e8:	681b      	ldr	r3, [r3, #0]
6000a8ea:	54d5      	strb	r5, [r2, r3]
	sh_fprintf->ctrl_blk->buffer_cnt++;
6000a8ec:	6922      	ldr	r2, [r4, #16]
6000a8ee:	6813      	ldr	r3, [r2, #0]
6000a8f0:	3301      	adds	r3, #1
6000a8f2:	6013      	str	r3, [r2, #0]
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
6000a8f4:	6862      	ldr	r2, [r4, #4]
6000a8f6:	4293      	cmp	r3, r2
6000a8f8:	d102      	bne.n	6000a900 <out_func+0x34>
		z_shell_fprintf_buffer_flush(sh_fprintf);
6000a8fa:	4620      	mov	r0, r4
6000a8fc:	f7ff ffda 	bl	6000a8b4 <z_shell_fprintf_buffer_flush>
}
6000a900:	2000      	movs	r0, #0
6000a902:	bd38      	pop	{r3, r4, r5, pc}

6000a904 <isspace>:
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
6000a904:	2820      	cmp	r0, #32
6000a906:	d005      	beq.n	6000a914 <isspace+0x10>
6000a908:	3809      	subs	r0, #9
6000a90a:	2804      	cmp	r0, #4
6000a90c:	bf8c      	ite	hi
6000a90e:	2000      	movhi	r0, #0
6000a910:	2001      	movls	r0, #1
6000a912:	4770      	bx	lr
6000a914:	2001      	movs	r0, #1
}
6000a916:	4770      	bx	lr

6000a918 <z_shell_strlen>:
{
6000a918:	b508      	push	{r3, lr}
	return str == NULL ? 0U : (uint16_t)strlen(str);
6000a91a:	b110      	cbz	r0, 6000a922 <z_shell_strlen+0xa>
6000a91c:	f000 ffc3 	bl	6000b8a6 <strlen>
6000a920:	b280      	uxth	r0, r0
}
6000a922:	bd08      	pop	{r3, pc}

6000a924 <z_column_span_with_buffer_offsets_get>:
{
6000a924:	b510      	push	{r4, lr}
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
6000a926:	7b03      	ldrb	r3, [r0, #12]
6000a928:	8940      	ldrh	r0, [r0, #10]
6000a92a:	441a      	add	r2, r3
6000a92c:	4419      	add	r1, r3
6000a92e:	fbb2 f4f0 	udiv	r4, r2, r0
6000a932:	fbb1 f3f0 	udiv	r3, r1, r0
6000a936:	fb00 2214 	mls	r2, r0, r4, r2
6000a93a:	fb00 1013 	mls	r0, r0, r3, r1
}
6000a93e:	1a10      	subs	r0, r2, r0
6000a940:	bd10      	pop	{r4, pc}

6000a942 <z_row_span_with_buffer_offsets_get>:
{
6000a942:	b510      	push	{r4, lr}
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
6000a944:	7b04      	ldrb	r4, [r0, #12]
6000a946:	8943      	ldrh	r3, [r0, #10]
6000a948:	4421      	add	r1, r4
6000a94a:	1910      	adds	r0, r2, r4
6000a94c:	fbb1 f1f3 	udiv	r1, r1, r3
6000a950:	fbb0 f0f3 	udiv	r0, r0, r3
}
6000a954:	1a40      	subs	r0, r0, r1
6000a956:	bd10      	pop	{r4, pc}

6000a958 <z_shell_multiline_data_calc>:
{
6000a958:	b530      	push	{r4, r5, lr}
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
6000a95a:	7b05      	ldrb	r5, [r0, #12]
6000a95c:	8943      	ldrh	r3, [r0, #10]
6000a95e:	4429      	add	r1, r5
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
6000a960:	442a      	add	r2, r5
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
6000a962:	fbb1 f4f3 	udiv	r4, r1, r3
6000a966:	fb03 1114 	mls	r1, r3, r4, r1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
6000a96a:	3401      	adds	r4, #1
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
6000a96c:	3101      	adds	r1, #1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
6000a96e:	8084      	strh	r4, [r0, #4]
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
6000a970:	8001      	strh	r1, [r0, #0]
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
6000a972:	fbb2 f1f3 	udiv	r1, r2, r3
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
6000a976:	fb03 2211 	mls	r2, r3, r1, r2
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
6000a97a:	1c4c      	adds	r4, r1, #1
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
6000a97c:	3201      	adds	r2, #1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
6000a97e:	80c4      	strh	r4, [r0, #6]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
6000a980:	8042      	strh	r2, [r0, #2]
}
6000a982:	bd30      	pop	{r4, r5, pc}

6000a984 <z_shell_make_argv>:
{
6000a984:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*argc = 0;
6000a988:	2500      	movs	r5, #0
{
6000a98a:	4606      	mov	r6, r0
6000a98c:	460f      	mov	r7, r1
6000a98e:	4614      	mov	r4, r2
6000a990:	4698      	mov	r8, r3
	*argc = 0;
6000a992:	6005      	str	r5, [r0, #0]
		c = *cmd;
6000a994:	7820      	ldrb	r0, [r4, #0]
		if (c == '\0') {
6000a996:	2800      	cmp	r0, #0
6000a998:	f000 80b5 	beq.w	6000ab06 <z_shell_make_argv+0x182>
		if (isspace((int) c)) {
6000a99c:	f7ff ffb2 	bl	6000a904 <isspace>
6000a9a0:	b118      	cbz	r0, 6000a9aa <z_shell_make_argv+0x26>
			*cmd++ = '\0';
6000a9a2:	2300      	movs	r3, #0
6000a9a4:	f804 3b01 	strb.w	r3, [r4], #1
			continue;
6000a9a8:	e7f4      	b.n	6000a994 <z_shell_make_argv+0x10>
		argv[(*argc)++] = cmd;
6000a9aa:	6832      	ldr	r2, [r6, #0]
6000a9ac:	1c53      	adds	r3, r2, #1
		if (*argc == max_argc) {
6000a9ae:	4543      	cmp	r3, r8
		argv[(*argc)++] = cmd;
6000a9b0:	6033      	str	r3, [r6, #0]
6000a9b2:	f847 4022 	str.w	r4, [r7, r2, lsl #2]
		if (*argc == max_argc) {
6000a9b6:	f000 80a6 	beq.w	6000ab06 <z_shell_make_argv+0x182>
	char quote = 0;
6000a9ba:	4605      	mov	r5, r0
		c = *cmd;
6000a9bc:	f894 9000 	ldrb.w	r9, [r4]
		if (c == '\0') {
6000a9c0:	f1b9 0f00 	cmp.w	r9, #0
6000a9c4:	d0e6      	beq.n	6000a994 <z_shell_make_argv+0x10>
		if (!quote) {
6000a9c6:	2d00      	cmp	r5, #0
6000a9c8:	f040 8089 	bne.w	6000aade <z_shell_make_argv+0x15a>
			switch (c) {
6000a9cc:	f1b9 0f27 	cmp.w	r9, #39	; 0x27
6000a9d0:	d006      	beq.n	6000a9e0 <z_shell_make_argv+0x5c>
6000a9d2:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
6000a9d6:	f000 808a 	beq.w	6000aaee <z_shell_make_argv+0x16a>
6000a9da:	f1b9 0f22 	cmp.w	r9, #34	; 0x22
6000a9de:	d176      	bne.n	6000aace <z_shell_make_argv+0x14a>
						z_shell_strlen(cmd));
6000a9e0:	4620      	mov	r0, r4
				continue;
6000a9e2:	464d      	mov	r5, r9
						z_shell_strlen(cmd));
6000a9e4:	f7ff ff98 	bl	6000a918 <z_shell_strlen>
				memmove(cmd, cmd + 1,
6000a9e8:	1c61      	adds	r1, r4, #1
						z_shell_strlen(cmd));
6000a9ea:	4602      	mov	r2, r0
				memmove(cmd, cmd + 1,
6000a9ec:	4620      	mov	r0, r4
6000a9ee:	f000 ff98 	bl	6000b922 <memmove>
				continue;
6000a9f2:	e7e3      	b.n	6000a9bc <z_shell_make_argv+0x38>
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
6000a9f4:	4620      	mov	r0, r4
			quote = 0;
6000a9f6:	2500      	movs	r5, #0
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
6000a9f8:	f7ff ff8e 	bl	6000a918 <z_shell_strlen>
6000a9fc:	1c61      	adds	r1, r4, #1
6000a9fe:	4602      	mov	r2, r0
6000aa00:	4620      	mov	r0, r4
6000aa02:	f000 ff8e 	bl	6000b922 <memmove>
			continue;
6000aa06:	e7d9      	b.n	6000a9bc <z_shell_make_argv+0x38>
			if (t == '0') {
6000aa08:	2930      	cmp	r1, #48	; 0x30
6000aa0a:	d125      	bne.n	6000aa58 <z_shell_make_argv+0xd4>
6000aa0c:	2302      	movs	r3, #2
				uint8_t v = 0U;
6000aa0e:	f04f 0a00 	mov.w	sl, #0
					t = *(cmd + i);
6000aa12:	5ce1      	ldrb	r1, [r4, r3]
6000aa14:	fa5f f983 	uxtb.w	r9, r3
					if (t >= '0' && t <= '7') {
6000aa18:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
6000aa1c:	b2d0      	uxtb	r0, r2
6000aa1e:	2807      	cmp	r0, #7
6000aa20:	d817      	bhi.n	6000aa52 <z_shell_make_argv+0xce>
				for (i = 2U; i < (2 + 3); i++) {
6000aa22:	3301      	adds	r3, #1
						v = (v << 3) | (t - '0');
6000aa24:	ea42 0aca 	orr.w	sl, r2, sl, lsl #3
				for (i = 2U; i < (2 + 3); i++) {
6000aa28:	2b05      	cmp	r3, #5
						v = (v << 3) | (t - '0');
6000aa2a:	fa5f fa8a 	uxtb.w	sl, sl
				for (i = 2U; i < (2 + 3); i++) {
6000aa2e:	d1f0      	bne.n	6000aa12 <z_shell_make_argv+0x8e>
6000aa30:	4699      	mov	r9, r3
					memmove(cmd, cmd + (i - 1),
6000aa32:	f109 3bff 	add.w	fp, r9, #4294967295	; 0xffffffff
						z_shell_strlen(cmd) - (i - 2));
6000aa36:	4620      	mov	r0, r4
6000aa38:	f7ff ff6e 	bl	6000a918 <z_shell_strlen>
6000aa3c:	1c82      	adds	r2, r0, #2
					memmove(cmd, cmd + (i - 1),
6000aa3e:	44a3      	add	fp, r4
6000aa40:	4620      	mov	r0, r4
6000aa42:	eba2 0209 	sub.w	r2, r2, r9
6000aa46:	4659      	mov	r1, fp
6000aa48:	f000 ff6b 	bl	6000b922 <memmove>
					*cmd++ = v;
6000aa4c:	f804 ab01 	strb.w	sl, [r4], #1
					continue;
6000aa50:	e7b4      	b.n	6000a9bc <z_shell_make_argv+0x38>
				if (i > 2) {
6000aa52:	f1b9 0f02 	cmp.w	r9, #2
6000aa56:	d1ec      	bne.n	6000aa32 <z_shell_make_argv+0xae>
			if (t == 'x') {
6000aa58:	2978      	cmp	r1, #120	; 0x78
6000aa5a:	d13e      	bne.n	6000aada <z_shell_make_argv+0x156>
6000aa5c:	2302      	movs	r3, #2
				uint8_t v = 0U;
6000aa5e:	f04f 0900 	mov.w	r9, #0
					t = *(cmd + i);
6000aa62:	5ce2      	ldrb	r2, [r4, r3]
6000aa64:	b2d8      	uxtb	r0, r3
					if (t >= '0' && t <= '9') {
6000aa66:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
6000aa6a:	fa5f fc81 	uxtb.w	ip, r1
6000aa6e:	f1bc 0f09 	cmp.w	ip, #9
6000aa72:	d819      	bhi.n	6000aaa8 <z_shell_make_argv+0x124>
						v = (v << 4) | (t - '0');
6000aa74:	ea41 1209 	orr.w	r2, r1, r9, lsl #4
				for (i = 2U; i < (2 + 2); i++) {
6000aa78:	2b03      	cmp	r3, #3
						v = (v << 4) | (t - 'A' + 10);
6000aa7a:	fa5f f982 	uxtb.w	r9, r2
				for (i = 2U; i < (2 + 2); i++) {
6000aa7e:	d111      	bne.n	6000aaa4 <z_shell_make_argv+0x120>
6000aa80:	f04f 0b04 	mov.w	fp, #4
					memmove(cmd, cmd + (i - 1),
6000aa84:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
						z_shell_strlen(cmd) - (i - 2));
6000aa88:	4620      	mov	r0, r4
6000aa8a:	f7ff ff45 	bl	6000a918 <z_shell_strlen>
6000aa8e:	1c82      	adds	r2, r0, #2
					memmove(cmd, cmd + (i - 1),
6000aa90:	44a2      	add	sl, r4
6000aa92:	4620      	mov	r0, r4
6000aa94:	eba2 020b 	sub.w	r2, r2, fp
6000aa98:	4651      	mov	r1, sl
6000aa9a:	f000 ff42 	bl	6000b922 <memmove>
					*cmd++ = v;
6000aa9e:	f804 9b01 	strb.w	r9, [r4], #1
					continue;
6000aaa2:	e78b      	b.n	6000a9bc <z_shell_make_argv+0x38>
6000aaa4:	2303      	movs	r3, #3
6000aaa6:	e7dc      	b.n	6000aa62 <z_shell_make_argv+0xde>
					} else if ((t >= 'a') &&
6000aaa8:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
6000aaac:	2905      	cmp	r1, #5
6000aaae:	d803      	bhi.n	6000aab8 <z_shell_make_argv+0x134>
						v = (v << 4) | (t - 'a' + 10);
6000aab0:	3a57      	subs	r2, #87	; 0x57
						v = (v << 4) | (t - 'A' + 10);
6000aab2:	ea42 1209 	orr.w	r2, r2, r9, lsl #4
6000aab6:	e7df      	b.n	6000aa78 <z_shell_make_argv+0xf4>
					} else if ((t >= 'A') && (t <= 'F')) {
6000aab8:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
6000aabc:	2905      	cmp	r1, #5
6000aabe:	d801      	bhi.n	6000aac4 <z_shell_make_argv+0x140>
						v = (v << 4) | (t - 'A' + 10);
6000aac0:	3a37      	subs	r2, #55	; 0x37
6000aac2:	e7f6      	b.n	6000aab2 <z_shell_make_argv+0x12e>
				if (i > 2) {
6000aac4:	2802      	cmp	r0, #2
6000aac6:	d008      	beq.n	6000aada <z_shell_make_argv+0x156>
6000aac8:	f04f 0b03 	mov.w	fp, #3
6000aacc:	e7da      	b.n	6000aa84 <z_shell_make_argv+0x100>
		if (!quote && isspace((int) c)) {
6000aace:	4648      	mov	r0, r9
6000aad0:	f7ff ff18 	bl	6000a904 <isspace>
6000aad4:	2800      	cmp	r0, #0
6000aad6:	f47f af5d 	bne.w	6000a994 <z_shell_make_argv+0x10>
		cmd += 1;
6000aada:	3401      	adds	r4, #1
6000aadc:	e76e      	b.n	6000a9bc <z_shell_make_argv+0x38>
		if (quote == c) {
6000aade:	45a9      	cmp	r9, r5
6000aae0:	d088      	beq.n	6000a9f4 <z_shell_make_argv+0x70>
		if (quote && c == '\\') {
6000aae2:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
6000aae6:	d1f8      	bne.n	6000aada <z_shell_make_argv+0x156>
			char t = *(cmd + 1);
6000aae8:	7861      	ldrb	r1, [r4, #1]
			if (t == quote) {
6000aaea:	428d      	cmp	r5, r1
6000aaec:	d18c      	bne.n	6000aa08 <z_shell_make_argv+0x84>
				memmove(cmd, cmd + 1,
6000aaee:	f104 0901 	add.w	r9, r4, #1
						z_shell_strlen(cmd));
6000aaf2:	4620      	mov	r0, r4
6000aaf4:	f7ff ff10 	bl	6000a918 <z_shell_strlen>
6000aaf8:	4602      	mov	r2, r0
				memmove(cmd, cmd + 1,
6000aafa:	4649      	mov	r1, r9
6000aafc:	4620      	mov	r0, r4
6000aafe:	f000 ff10 	bl	6000b922 <memmove>
				cmd += 1;
6000ab02:	464c      	mov	r4, r9
				continue;
6000ab04:	e75a      	b.n	6000a9bc <z_shell_make_argv+0x38>
}
6000ab06:	4628      	mov	r0, r5
6000ab08:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

6000ab0c <z_shell_pattern_remove>:
{
6000ab0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000ab0e:	4615      	mov	r5, r2
6000ab10:	460e      	mov	r6, r1
	char *pattern_addr = strstr(buff, pattern);
6000ab12:	4611      	mov	r1, r2
{
6000ab14:	4607      	mov	r7, r0
	char *pattern_addr = strstr(buff, pattern);
6000ab16:	f000 fe7d 	bl	6000b814 <strstr>
6000ab1a:	4604      	mov	r4, r0
	uint16_t pattern_len = z_shell_strlen(pattern);
6000ab1c:	4628      	mov	r0, r5
6000ab1e:	f7ff fefb 	bl	6000a918 <z_shell_strlen>
6000ab22:	4605      	mov	r5, r0
	if (!pattern_addr) {
6000ab24:	b1c4      	cbz	r4, 6000ab58 <z_shell_pattern_remove+0x4c>
	if (pattern_addr > buff) {
6000ab26:	42a7      	cmp	r7, r4
6000ab28:	d207      	bcs.n	6000ab3a <z_shell_pattern_remove+0x2e>
		if (*(pattern_addr - 1) == ' ') {
6000ab2a:	f814 3c01 	ldrb.w	r3, [r4, #-1]
6000ab2e:	2b20      	cmp	r3, #32
			pattern_len++; /* space needs to be removed as well */
6000ab30:	bf02      	ittt	eq
6000ab32:	3501      	addeq	r5, #1
			pattern_addr--; /* set pointer to space */
6000ab34:	f104 34ff 	addeq.w	r4, r4, #4294967295	; 0xffffffff
			pattern_len++; /* space needs to be removed as well */
6000ab38:	b2ad      	uxtheq	r5, r5
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
6000ab3a:	4620      	mov	r0, r4
6000ab3c:	f7ff feec 	bl	6000a918 <z_shell_strlen>
	*buff_len -= pattern_len;
6000ab40:	8833      	ldrh	r3, [r6, #0]
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
6000ab42:	1b42      	subs	r2, r0, r5
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
6000ab44:	1961      	adds	r1, r4, r5
	*buff_len -= pattern_len;
6000ab46:	1b5b      	subs	r3, r3, r5
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
6000ab48:	4620      	mov	r0, r4
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
6000ab4a:	3201      	adds	r2, #1
	*buff_len -= pattern_len;
6000ab4c:	8033      	strh	r3, [r6, #0]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
6000ab4e:	b292      	uxth	r2, r2
}
6000ab50:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
6000ab54:	f000 bee5 	b.w	6000b922 <memmove>
}
6000ab58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

6000ab5a <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
6000ab5a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000ab5e:	4688      	mov	r8, r1
6000ab60:	b086      	sub	sp, #24
6000ab62:	4617      	mov	r7, r2
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
6000ab64:	4604      	mov	r4, r0
6000ab66:	b128      	cbz	r0, 6000ab74 <z_shell_find_cmd+0x1a>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
		parent = &parent_cpy;
6000ab68:	ac01      	add	r4, sp, #4
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
6000ab6a:	4601      	mov	r1, r0
6000ab6c:	2214      	movs	r2, #20
6000ab6e:	a801      	add	r0, sp, #4
6000ab70:	f000 feef 	bl	6000b952 <memcpy>
		parent = &parent_cpy;
6000ab74:	2600      	movs	r6, #0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
6000ab76:	4631      	mov	r1, r6
6000ab78:	463a      	mov	r2, r7
6000ab7a:	4620      	mov	r0, r4
6000ab7c:	3601      	adds	r6, #1
6000ab7e:	f7fa fb57 	bl	60005230 <z_shell_cmd_get>
6000ab82:	4605      	mov	r5, r0
6000ab84:	b128      	cbz	r0, 6000ab92 <z_shell_find_cmd+0x38>
		if (strcmp(cmd_str, entry->syntax) == 0) {
6000ab86:	6829      	ldr	r1, [r5, #0]
6000ab88:	4640      	mov	r0, r8
6000ab8a:	f000 fe9c 	bl	6000b8c6 <strcmp>
6000ab8e:	2800      	cmp	r0, #0
6000ab90:	d1f1      	bne.n	6000ab76 <z_shell_find_cmd+0x1c>
			return entry;
		}
	}

	return NULL;
}
6000ab92:	4628      	mov	r0, r5
6000ab94:	b006      	add	sp, #24
6000ab96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

6000ab9a <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
6000ab9a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
6000ab9e:	f8dd 8020 	ldr.w	r8, [sp, #32]
6000aba2:	461c      	mov	r4, r3
6000aba4:	460f      	mov	r7, r1
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
6000aba6:	2300      	movs	r3, #0
{
6000aba8:	4616      	mov	r6, r2
6000abaa:	f89d 9024 	ldrb.w	r9, [sp, #36]	; 0x24
	*match_arg = Z_SHELL_CMD_ROOT_LVL;
6000abae:	6023      	str	r3, [r4, #0]

	while (*match_arg < argc) {
6000abb0:	6823      	ldr	r3, [r4, #0]

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
6000abb2:	4605      	mov	r5, r0
	while (*match_arg < argc) {
6000abb4:	42bb      	cmp	r3, r7
6000abb6:	d21b      	bcs.n	6000abf0 <z_shell_get_last_command+0x56>
			if (z_shell_has_wildcard(argv[*match_arg])) {
6000abb8:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
6000abbc:	f000 fda4 	bl	6000b708 <z_shell_has_wildcard>
6000abc0:	6823      	ldr	r3, [r4, #0]
6000abc2:	4682      	mov	sl, r0
6000abc4:	b118      	cbz	r0, 6000abce <z_shell_get_last_command+0x34>
				(*match_arg)++;
6000abc6:	3301      	adds	r3, #1
				continue;
6000abc8:	4628      	mov	r0, r5
				(*match_arg)++;
6000abca:	6023      	str	r3, [r4, #0]
				continue;
6000abcc:	e7f0      	b.n	6000abb0 <z_shell_get_last_command+0x16>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
6000abce:	4642      	mov	r2, r8
6000abd0:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
6000abd4:	4628      	mov	r0, r5
6000abd6:	f7ff ffc0 	bl	6000ab5a <z_shell_find_cmd>
		if (entry) {
6000abda:	b148      	cbz	r0, 6000abf0 <z_shell_get_last_command+0x56>
			(*match_arg)++;
6000abdc:	6823      	ldr	r3, [r4, #0]
6000abde:	1c5a      	adds	r2, r3, #1
6000abe0:	6022      	str	r2, [r4, #0]
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
6000abe2:	f1b9 0f00 	cmp.w	r9, #0
6000abe6:	d0e3      	beq.n	6000abb0 <z_shell_get_last_command+0x16>
6000abe8:	4580      	cmp	r8, r0
6000abea:	d1e1      	bne.n	6000abb0 <z_shell_get_last_command+0x16>
			(*match_arg)--;
			return NULL;
6000abec:	4655      	mov	r5, sl
			(*match_arg)--;
6000abee:	6023      	str	r3, [r4, #0]
		}
	}

	return entry;
}
6000abf0:	4628      	mov	r0, r5
6000abf2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

6000abf6 <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
6000abf6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
6000abfa:	4606      	mov	r6, r0
	uint16_t len = z_shell_strlen(str);
6000abfc:	f7ff fe8c 	bl	6000a918 <z_shell_strlen>
6000ac00:	4605      	mov	r5, r0
	uint16_t shift = 0U;

	if (!str) {
6000ac02:	bb56      	cbnz	r6, 6000ac5a <z_shell_spaces_trim+0x64>

				break;
			}
		}
	}
}
6000ac04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (shift > 0) {
6000ac08:	b14c      	cbz	r4, 6000ac1e <z_shell_spaces_trim+0x28>
						len - j + 1);
6000ac0a:	1c6a      	adds	r2, r5, #1
					len -= shift;
6000ac0c:	1b2d      	subs	r5, r5, r4
						len - j + 1);
6000ac0e:	b29b      	uxth	r3, r3
					memmove(&str[i + 1],
6000ac10:	3701      	adds	r7, #1
					len -= shift;
6000ac12:	b2ad      	uxth	r5, r5
					shift = 0U;
6000ac14:	464c      	mov	r4, r9
					memmove(&str[i + 1],
6000ac16:	1ad2      	subs	r2, r2, r3
6000ac18:	19f0      	adds	r0, r6, r7
6000ac1a:	f000 fe82 	bl	6000b922 <memmove>
	for (uint16_t i = 0; i < len - 1; i++) {
6000ac1e:	f108 0801 	add.w	r8, r8, #1
6000ac22:	fa1f f388 	uxth.w	r3, r8
6000ac26:	1e6a      	subs	r2, r5, #1
6000ac28:	4293      	cmp	r3, r2
6000ac2a:	461f      	mov	r7, r3
6000ac2c:	daea      	bge.n	6000ac04 <z_shell_spaces_trim+0xe>
		if (isspace((int)str[i])) {
6000ac2e:	5df0      	ldrb	r0, [r6, r7]
6000ac30:	f7ff fe68 	bl	6000a904 <isspace>
6000ac34:	2800      	cmp	r0, #0
6000ac36:	d0f2      	beq.n	6000ac1e <z_shell_spaces_trim+0x28>
			for (uint16_t j = i + 1; j < len; j++) {
6000ac38:	3301      	adds	r3, #1
6000ac3a:	b29b      	uxth	r3, r3
6000ac3c:	b29a      	uxth	r2, r3
6000ac3e:	4295      	cmp	r5, r2
6000ac40:	d9ed      	bls.n	6000ac1e <z_shell_spaces_trim+0x28>
				if (isspace((int)str[j])) {
6000ac42:	5cf0      	ldrb	r0, [r6, r3]
6000ac44:	18f1      	adds	r1, r6, r3
6000ac46:	f7ff fe5d 	bl	6000a904 <isspace>
6000ac4a:	1c5a      	adds	r2, r3, #1
6000ac4c:	4681      	mov	r9, r0
6000ac4e:	2800      	cmp	r0, #0
6000ac50:	d0da      	beq.n	6000ac08 <z_shell_spaces_trim+0x12>
					shift++;
6000ac52:	3401      	adds	r4, #1
6000ac54:	4613      	mov	r3, r2
6000ac56:	b2a4      	uxth	r4, r4
			for (uint16_t j = i + 1; j < len; j++) {
6000ac58:	e7f0      	b.n	6000ac3c <z_shell_spaces_trim+0x46>
6000ac5a:	f04f 0800 	mov.w	r8, #0
	uint16_t shift = 0U;
6000ac5e:	4644      	mov	r4, r8
6000ac60:	e7df      	b.n	6000ac22 <z_shell_spaces_trim+0x2c>

6000ac62 <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *shell)
{
6000ac62:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
6000ac64:	6884      	ldr	r4, [r0, #8]
{
6000ac66:	4605      	mov	r5, r0
	if (buff[0] == '\0') {
6000ac68:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
6000ac6c:	b953      	cbnz	r3, 6000ac84 <z_shell_cmd_trim+0x22>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
6000ac6e:	68ab      	ldr	r3, [r5, #8]
6000ac70:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
6000ac72:	875a      	strh	r2, [r3, #58]	; 0x3a
}
6000ac74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		*buff_len -= 1U;
6000ac76:	3a01      	subs	r2, #1
6000ac78:	b292      	uxth	r2, r2
6000ac7a:	8722      	strh	r2, [r4, #56]	; 0x38
		if (*buff_len == 0U) {
6000ac7c:	b922      	cbnz	r2, 6000ac88 <z_shell_cmd_trim+0x26>
			buff[0] = '\0';
6000ac7e:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
			return;
6000ac82:	e7f4      	b.n	6000ac6e <z_shell_cmd_trim+0xc>
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
6000ac84:	f104 063e 	add.w	r6, r4, #62	; 0x3e
	while (isspace((int) buff[*buff_len - 1U])) {
6000ac88:	8f22      	ldrh	r2, [r4, #56]	; 0x38
6000ac8a:	18b3      	adds	r3, r6, r2
6000ac8c:	f813 0c01 	ldrb.w	r0, [r3, #-1]
6000ac90:	f7ff fe38 	bl	6000a904 <isspace>
6000ac94:	4603      	mov	r3, r0
6000ac96:	2800      	cmp	r0, #0
6000ac98:	d1ed      	bne.n	6000ac76 <z_shell_cmd_trim+0x14>
	buff[*buff_len] = '\0';
6000ac9a:	54b0      	strb	r0, [r6, r2]
	while (isspace((int) buff[i++])) {
6000ac9c:	b29f      	uxth	r7, r3
6000ac9e:	fa16 f183 	uxtah	r1, r6, r3
6000aca2:	3301      	adds	r3, #1
6000aca4:	5df0      	ldrb	r0, [r6, r7]
6000aca6:	f7ff fe2d 	bl	6000a904 <isspace>
6000acaa:	2800      	cmp	r0, #0
6000acac:	d1f6      	bne.n	6000ac9c <z_shell_cmd_trim+0x3a>
	if (--i > 0) {
6000acae:	2f00      	cmp	r7, #0
6000acb0:	d0dd      	beq.n	6000ac6e <z_shell_cmd_trim+0xc>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
6000acb2:	8f23      	ldrh	r3, [r4, #56]	; 0x38
6000acb4:	4630      	mov	r0, r6
6000acb6:	3301      	adds	r3, #1
6000acb8:	1bda      	subs	r2, r3, r7
6000acba:	f000 fe32 	bl	6000b922 <memmove>
		*buff_len = *buff_len - i;
6000acbe:	8f23      	ldrh	r3, [r4, #56]	; 0x38
6000acc0:	1bdb      	subs	r3, r3, r7
6000acc2:	8723      	strh	r3, [r4, #56]	; 0x38
6000acc4:	e7d3      	b.n	6000ac6e <z_shell_cmd_trim+0xc>

6000acc6 <z_shell_raw_fprintf>:
{
6000acc6:	b40e      	push	{r1, r2, r3}
6000acc8:	b503      	push	{r0, r1, lr}
6000acca:	aa03      	add	r2, sp, #12
6000accc:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
6000acd0:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
6000acd2:	f7fa fa99 	bl	60005208 <z_shell_fprintf_fmt>
}
6000acd6:	b002      	add	sp, #8
6000acd8:	f85d eb04 	ldr.w	lr, [sp], #4
6000acdc:	b003      	add	sp, #12
6000acde:	4770      	bx	lr

6000ace0 <full_line_cmd>:
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
6000ace0:	6882      	ldr	r2, [r0, #8]
{
6000ace2:	b538      	push	{r3, r4, r5, lr}
6000ace4:	4604      	mov	r4, r0
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
6000ace6:	6810      	ldr	r0, [r2, #0]
6000ace8:	8f15      	ldrh	r5, [r2, #56]	; 0x38
	return str == NULL ? 0U : (uint16_t)strlen(str);
6000acea:	b110      	cbz	r0, 6000acf2 <full_line_cmd+0x12>
6000acec:	f000 fddb 	bl	6000b8a6 <strlen>
6000acf0:	b280      	uxth	r0, r0
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
6000acf2:	68a2      	ldr	r2, [r4, #8]
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
6000acf4:	1943      	adds	r3, r0, r5
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
6000acf6:	8d50      	ldrh	r0, [r2, #42]	; 0x2a
6000acf8:	fbb3 f2f0 	udiv	r2, r3, r0
6000acfc:	fb00 3012 	mls	r0, r0, r2, r3
}
6000ad00:	fab0 f080 	clz	r0, r0
6000ad04:	0940      	lsrs	r0, r0, #5
6000ad06:	bd38      	pop	{r3, r4, r5, pc}

6000ad08 <z_shell_cursor_in_empty_line>:
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
6000ad08:	6882      	ldr	r2, [r0, #8]
{
6000ad0a:	b538      	push	{r3, r4, r5, lr}
6000ad0c:	4604      	mov	r4, r0
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
6000ad0e:	6810      	ldr	r0, [r2, #0]
6000ad10:	8f55      	ldrh	r5, [r2, #58]	; 0x3a
6000ad12:	b110      	cbz	r0, 6000ad1a <z_shell_cursor_in_empty_line+0x12>
6000ad14:	f000 fdc7 	bl	6000b8a6 <strlen>
6000ad18:	b280      	uxth	r0, r0
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
6000ad1a:	68a2      	ldr	r2, [r4, #8]
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
6000ad1c:	1943      	adds	r3, r0, r5
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
6000ad1e:	8d50      	ldrh	r0, [r2, #42]	; 0x2a
6000ad20:	fbb3 f2f0 	udiv	r2, r3, r0
6000ad24:	fb00 3012 	mls	r0, r0, r2, r3
}
6000ad28:	fab0 f080 	clz	r0, r0
6000ad2c:	0940      	lsrs	r0, r0, #5
6000ad2e:	bd38      	pop	{r3, r4, r5, pc}

6000ad30 <z_shell_op_cond_next_line>:
{
6000ad30:	b510      	push	{r4, lr}
6000ad32:	4604      	mov	r4, r0
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
6000ad34:	f7ff ffe8 	bl	6000ad08 <z_shell_cursor_in_empty_line>
6000ad38:	b120      	cbz	r0, 6000ad44 <z_shell_op_cond_next_line+0x14>
		z_cursor_next_line_move(shell);
6000ad3a:	6960      	ldr	r0, [r4, #20]
}
6000ad3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_cursor_next_line_move(shell);
6000ad40:	f7fa ba9c 	b.w	6000527c <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
6000ad44:	4620      	mov	r0, r4
6000ad46:	f7ff ffcb 	bl	6000ace0 <full_line_cmd>
6000ad4a:	2800      	cmp	r0, #0
6000ad4c:	d1f5      	bne.n	6000ad3a <z_shell_op_cond_next_line+0xa>
}
6000ad4e:	bd10      	pop	{r4, pc}

6000ad50 <z_shell_op_cursor_position_synchronize>:
{
6000ad50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
6000ad52:	6884      	ldr	r4, [r0, #8]
{
6000ad54:	4605      	mov	r5, r0
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
6000ad56:	8f22      	ldrh	r2, [r4, #56]	; 0x38
6000ad58:	f104 0020 	add.w	r0, r4, #32
6000ad5c:	8f61      	ldrh	r1, [r4, #58]	; 0x3a
6000ad5e:	f7ff fdfb 	bl	6000a958 <z_shell_multiline_data_calc>
	if (full_line_cmd(shell)) {
6000ad62:	4628      	mov	r0, r5
	last_line = (cons->cur_y == cons->cur_y_end);
6000ad64:	8ca7      	ldrh	r7, [r4, #36]	; 0x24
6000ad66:	8ce6      	ldrh	r6, [r4, #38]	; 0x26
	if (full_line_cmd(shell)) {
6000ad68:	f7ff ffba 	bl	6000ace0 <full_line_cmd>
6000ad6c:	b110      	cbz	r0, 6000ad74 <z_shell_op_cursor_position_synchronize+0x24>
		z_cursor_next_line_move(shell);
6000ad6e:	6968      	ldr	r0, [r5, #20]
6000ad70:	f7fa fa84 	bl	6000527c <z_cursor_next_line_move.isra.0>
	if (last_line) {
6000ad74:	42b7      	cmp	r7, r6
6000ad76:	d107      	bne.n	6000ad88 <z_shell_op_cursor_position_synchronize+0x38>
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
6000ad78:	8c21      	ldrh	r1, [r4, #32]
6000ad7a:	4628      	mov	r0, r5
							       cons->cur_x_end);
6000ad7c:	8c63      	ldrh	r3, [r4, #34]	; 0x22
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
6000ad7e:	1ac9      	subs	r1, r1, r3
}
6000ad80:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
6000ad84:	f7fa ba98 	b.w	600052b8 <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
6000ad88:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
6000ad8a:	4628      	mov	r0, r5
6000ad8c:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
6000ad8e:	1ac9      	subs	r1, r1, r3
6000ad90:	f7fa fa82 	bl	60005298 <z_shell_op_cursor_vert_move>
6000ad94:	e7f0      	b.n	6000ad78 <z_shell_op_cursor_position_synchronize+0x28>

6000ad96 <z_shell_op_cursor_move>:
{
6000ad96:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000ad98:	4604      	mov	r4, r0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
6000ad9a:	6880      	ldr	r0, [r0, #8]
{
6000ad9c:	460d      	mov	r5, r1
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
6000ad9e:	8f41      	ldrh	r1, [r0, #58]	; 0x3a
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
6000ada0:	3020      	adds	r0, #32
6000ada2:	8b02      	ldrh	r2, [r0, #24]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
6000ada4:	440d      	add	r5, r1
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
6000ada6:	f7ff fdd7 	bl	6000a958 <z_shell_multiline_data_calc>
						&shell->ctx->vt100_ctx.cons,
6000adaa:	68a0      	ldr	r0, [r4, #8]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
6000adac:	b2ad      	uxth	r5, r5
	row_span = z_row_span_with_buffer_offsets_get(
6000adae:	8f41      	ldrh	r1, [r0, #58]	; 0x3a
6000adb0:	3020      	adds	r0, #32
6000adb2:	462a      	mov	r2, r5
6000adb4:	f7ff fdc5 	bl	6000a942 <z_row_span_with_buffer_offsets_get>
6000adb8:	4607      	mov	r7, r0
						&shell->ctx->vt100_ctx.cons,
6000adba:	68a0      	ldr	r0, [r4, #8]
	col_span = z_column_span_with_buffer_offsets_get(
6000adbc:	462a      	mov	r2, r5
6000adbe:	8f41      	ldrh	r1, [r0, #58]	; 0x3a
6000adc0:	3020      	adds	r0, #32
6000adc2:	f7ff fdaf 	bl	6000a924 <z_column_span_with_buffer_offsets_get>
6000adc6:	4606      	mov	r6, r0
	z_shell_op_cursor_vert_move(shell, -row_span);
6000adc8:	4279      	negs	r1, r7
6000adca:	4620      	mov	r0, r4
6000adcc:	f7fa fa64 	bl	60005298 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, col_span);
6000add0:	4631      	mov	r1, r6
6000add2:	4620      	mov	r0, r4
6000add4:	f7fa fa70 	bl	600052b8 <z_shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
6000add8:	68a3      	ldr	r3, [r4, #8]
6000adda:	875d      	strh	r5, [r3, #58]	; 0x3a
}
6000addc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

6000adde <z_shell_op_cursor_word_move>:
{
6000adde:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (val < 0) {
6000ade2:	1e0c      	subs	r4, r1, #0
{
6000ade4:	4606      	mov	r6, r0
	if (val < 0) {
6000ade6:	da33      	bge.n	6000ae50 <z_shell_op_cursor_word_move+0x72>
		val = -val;
6000ade8:	4264      	negs	r4, r4
		sign = -1;
6000adea:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		val = -val;
6000adee:	b224      	sxth	r4, r4
		sign = -1;
6000adf0:	b2a4      	uxth	r4, r4
6000adf2:	b2af      	uxth	r7, r5
6000adf4:	e024      	b.n	6000ae40 <z_shell_op_cursor_word_move+0x62>
		shift = shift_calc(shell->ctx->cmd_buff,
6000adf6:	68b3      	ldr	r3, [r6, #8]
	bool found = false;
6000adf8:	2000      	movs	r0, #0
		shift = shift_calc(shell->ctx->cmd_buff,
6000adfa:	f8b3 e03a 	ldrh.w	lr, [r3, #58]	; 0x3a
6000adfe:	f103 083e 	add.w	r8, r3, #62	; 0x3e
6000ae02:	f8b3 9038 	ldrh.w	r9, [r3, #56]	; 0x38
6000ae06:	4673      	mov	r3, lr
		idx = pos + ret * sign;
6000ae08:	eba3 010e 	sub.w	r1, r3, lr
6000ae0c:	b209      	sxth	r1, r1
		if (((idx == 0U) && (sign < 0)) ||
6000ae0e:	b90b      	cbnz	r3, 6000ae14 <z_shell_op_cursor_word_move+0x36>
6000ae10:	1c6a      	adds	r2, r5, #1
6000ae12:	d010      	beq.n	6000ae36 <z_shell_op_cursor_word_move+0x58>
6000ae14:	4599      	cmp	r9, r3
6000ae16:	d101      	bne.n	6000ae1c <z_shell_op_cursor_word_move+0x3e>
		    ((idx == len) && (sign > 0))) {
6000ae18:	2d01      	cmp	r5, #1
6000ae1a:	d00c      	beq.n	6000ae36 <z_shell_op_cursor_word_move+0x58>
		if (isalnum((int)str[idx]) != 0) {
6000ae1c:	f818 2003 	ldrb.w	r2, [r8, r3]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
6000ae20:	f042 0c20 	orr.w	ip, r2, #32
6000ae24:	f1ac 0c61 	sub.w	ip, ip, #97	; 0x61
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
6000ae28:	f1bc 0f19 	cmp.w	ip, #25
6000ae2c:	d90c      	bls.n	6000ae48 <z_shell_op_cursor_word_move+0x6a>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
6000ae2e:	3a30      	subs	r2, #48	; 0x30
	return (int)(isalpha(chr) || isdigit(chr));
6000ae30:	2a09      	cmp	r2, #9
6000ae32:	d909      	bls.n	6000ae48 <z_shell_op_cursor_word_move+0x6a>
			if (found) {
6000ae34:	b148      	cbz	r0, 6000ae4a <z_shell_op_cursor_word_move+0x6c>
		z_shell_op_cursor_move(shell, sign * shift);
6000ae36:	3c01      	subs	r4, #1
6000ae38:	4630      	mov	r0, r6
6000ae3a:	f7ff ffac 	bl	6000ad96 <z_shell_op_cursor_move>
6000ae3e:	b2a4      	uxth	r4, r4
	while (val--) {
6000ae40:	2c00      	cmp	r4, #0
6000ae42:	d1d8      	bne.n	6000adf6 <z_shell_op_cursor_word_move+0x18>
}
6000ae44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			found = true;
6000ae48:	2001      	movs	r0, #1
	while (1) {
6000ae4a:	443b      	add	r3, r7
6000ae4c:	b29b      	uxth	r3, r3
		idx = pos + ret * sign;
6000ae4e:	e7db      	b.n	6000ae08 <z_shell_op_cursor_word_move+0x2a>
		sign = 1;
6000ae50:	2501      	movs	r5, #1
6000ae52:	e7cd      	b.n	6000adf0 <z_shell_op_cursor_word_move+0x12>

6000ae54 <z_shell_op_cursor_home_move>:
	z_shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
6000ae54:	6883      	ldr	r3, [r0, #8]
6000ae56:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
6000ae58:	4249      	negs	r1, r1
6000ae5a:	b209      	sxth	r1, r1
6000ae5c:	f7ff bf9b 	b.w	6000ad96 <z_shell_op_cursor_move>

6000ae60 <z_shell_op_cursor_end_move>:
	z_shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
6000ae60:	6883      	ldr	r3, [r0, #8]
6000ae62:	8f19      	ldrh	r1, [r3, #56]	; 0x38
6000ae64:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
6000ae66:	1ac9      	subs	r1, r1, r3
6000ae68:	b209      	sxth	r1, r1
6000ae6a:	f7ff bf94 	b.w	6000ad96 <z_shell_op_cursor_move>

6000ae6e <z_shell_op_left_arrow>:
	if (shell->ctx->cmd_buff_pos > 0) {
6000ae6e:	6883      	ldr	r3, [r0, #8]
6000ae70:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
6000ae72:	b11b      	cbz	r3, 6000ae7c <z_shell_op_left_arrow+0xe>
		z_shell_op_cursor_move(shell, -1);
6000ae74:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
6000ae78:	f7ff bf8d 	b.w	6000ad96 <z_shell_op_cursor_move>
}
6000ae7c:	4770      	bx	lr

6000ae7e <z_shell_op_right_arrow>:
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
6000ae7e:	6883      	ldr	r3, [r0, #8]
6000ae80:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
6000ae82:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
6000ae84:	429a      	cmp	r2, r3
6000ae86:	d202      	bcs.n	6000ae8e <z_shell_op_right_arrow+0x10>
		z_shell_op_cursor_move(shell, 1);
6000ae88:	2101      	movs	r1, #1
6000ae8a:	f7ff bf84 	b.w	6000ad96 <z_shell_op_cursor_move>
}
6000ae8e:	4770      	bx	lr

6000ae90 <z_shell_op_delete_from_cursor>:
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
6000ae90:	6883      	ldr	r3, [r0, #8]
6000ae92:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
6000ae94:	871a      	strh	r2, [r3, #56]	; 0x38
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
6000ae96:	4413      	add	r3, r2
6000ae98:	2200      	movs	r2, #0
6000ae9a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
	z_clear_eos(shell);
6000ae9e:	6940      	ldr	r0, [r0, #20]
6000aea0:	f7fa b9f2 	b.w	60005288 <z_clear_eos.isra.0>

6000aea4 <z_shell_cmd_line_erase>:
{
6000aea4:	b510      	push	{r4, lr}
6000aea6:	4604      	mov	r4, r0
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
6000aea8:	6880      	ldr	r0, [r0, #8]
6000aeaa:	8f02      	ldrh	r2, [r0, #56]	; 0x38
6000aeac:	3020      	adds	r0, #32
6000aeae:	8b41      	ldrh	r1, [r0, #26]
6000aeb0:	f7ff fd52 	bl	6000a958 <z_shell_multiline_data_calc>
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
6000aeb4:	68a3      	ldr	r3, [r4, #8]
	z_shell_op_cursor_horiz_move(shell,
6000aeb6:	4620      	mov	r0, r4
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
6000aeb8:	8c19      	ldrh	r1, [r3, #32]
	z_shell_op_cursor_horiz_move(shell,
6000aeba:	f1c1 0101 	rsb	r1, r1, #1
6000aebe:	f7fa f9fb 	bl	600052b8 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
6000aec2:	68a3      	ldr	r3, [r4, #8]
6000aec4:	4620      	mov	r0, r4
6000aec6:	8c99      	ldrh	r1, [r3, #36]	; 0x24
6000aec8:	3901      	subs	r1, #1
6000aeca:	f7fa f9e5 	bl	60005298 <z_shell_op_cursor_vert_move>
	z_clear_eos(shell);
6000aece:	6960      	ldr	r0, [r4, #20]
}
6000aed0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_clear_eos(shell);
6000aed4:	f7fa b9d8 	b.w	60005288 <z_clear_eos.isra.0>

6000aed8 <z_shell_write>:
{
6000aed8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
6000aedc:	4606      	mov	r6, r0
6000aede:	4688      	mov	r8, r1
6000aee0:	4615      	mov	r5, r2
	size_t offset = 0;
6000aee2:	2700      	movs	r7, #0
	while (length) {
6000aee4:	b915      	cbnz	r5, 6000aeec <z_shell_write+0x14>
}
6000aee6:	b002      	add	sp, #8
6000aee8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		int err = shell->iface->api->write(shell->iface,
6000aeec:	6870      	ldr	r0, [r6, #4]
6000aeee:	462a      	mov	r2, r5
6000aef0:	eb08 0107 	add.w	r1, r8, r7
6000aef4:	6803      	ldr	r3, [r0, #0]
6000aef6:	68dc      	ldr	r4, [r3, #12]
6000aef8:	ab01      	add	r3, sp, #4
6000aefa:	47a0      	blx	r4
		offset += tmp_cnt;
6000aefc:	9b01      	ldr	r3, [sp, #4]
6000aefe:	441f      	add	r7, r3
		length -= tmp_cnt;
6000af00:	1aed      	subs	r5, r5, r3
		if (tmp_cnt == 0 &&
6000af02:	2b00      	cmp	r3, #0
6000af04:	d1ee      	bne.n	6000aee4 <z_shell_write+0xc>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
6000af06:	68b4      	ldr	r4, [r6, #8]
6000af08:	7923      	ldrb	r3, [r4, #4]
		if (tmp_cnt == 0 &&
6000af0a:	2b03      	cmp	r3, #3
6000af0c:	d0ea      	beq.n	6000aee4 <z_shell_write+0xc>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
6000af0e:	2b02      	cmp	r3, #2
6000af10:	d80e      	bhi.n	6000af30 <z_shell_write+0x58>
	return z_impl_k_poll(events, num_events, timeout);
6000af12:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
6000af16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
6000af1a:	2101      	movs	r1, #1
6000af1c:	f504 7037 	add.w	r0, r4, #732	; 0x2dc
6000af20:	f7fe fade 	bl	600094e0 <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
6000af24:	68b0      	ldr	r0, [r6, #8]
6000af26:	f500 7024 	add.w	r0, r0, #656	; 0x290
	z_impl_k_poll_signal_reset(sig);
6000af2a:	f001 fca6 	bl	6000c87a <z_impl_k_poll_signal_reset>
6000af2e:	e7d9      	b.n	6000aee4 <z_shell_write+0xc>
	return shell->ctx->internal.flags.tx_rdy == 1;
6000af30:	f8d4 325c 	ldr.w	r3, [r4, #604]	; 0x25c
		while (!z_flag_tx_rdy_get(shell)) {
6000af34:	069b      	lsls	r3, r3, #26
6000af36:	d5fb      	bpl.n	6000af30 <z_shell_write+0x58>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
6000af38:	f504 7417 	add.w	r4, r4, #604	; 0x25c
6000af3c:	f3bf 8f5b 	dmb	ish
6000af40:	e854 3f00 	ldrex	r3, [r4]
6000af44:	f023 0320 	bic.w	r3, r3, #32
6000af48:	e844 3200 	strex	r2, r3, [r4]
6000af4c:	2a00      	cmp	r2, #0
6000af4e:	d1f7      	bne.n	6000af40 <z_shell_write+0x68>
6000af50:	f3bf 8f5b 	dmb	ish
	return ret;
6000af54:	e7c6      	b.n	6000aee4 <z_shell_write+0xc>

6000af56 <z_shell_print_stream>:
	z_shell_write((const struct shell *) user_ctx, data, len);
6000af56:	f7ff bfbf 	b.w	6000aed8 <z_shell_write>

6000af5a <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
6000af5a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
6000af5c:	460f      	mov	r7, r1
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
	    shell->ctx->internal.flags.use_colors &&
6000af5e:	6881      	ldr	r1, [r0, #8]
{
6000af60:	461e      	mov	r6, r3
6000af62:	4604      	mov	r4, r0
	    shell->ctx->internal.flags.use_colors &&
6000af64:	f8d1 325c 	ldr.w	r3, [r1, #604]	; 0x25c
{
6000af68:	4615      	mov	r5, r2
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
6000af6a:	079b      	lsls	r3, r3, #30
6000af6c:	d517      	bpl.n	6000af9e <z_shell_vfprintf+0x44>
	    shell->ctx->internal.flags.use_colors &&
6000af6e:	f891 302e 	ldrb.w	r3, [r1, #46]	; 0x2e
6000af72:	42bb      	cmp	r3, r7
6000af74:	d013      	beq.n	6000af9e <z_shell_vfprintf+0x44>
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *shell,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
6000af76:	2202      	movs	r2, #2
6000af78:	312e      	adds	r1, #46	; 0x2e
6000af7a:	a801      	add	r0, sp, #4
6000af7c:	f000 fce9 	bl	6000b952 <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(shell, &col);
		z_shell_vt100_color_set(shell, color);
6000af80:	4639      	mov	r1, r7
6000af82:	4620      	mov	r0, r4
6000af84:	f7fa f9b0 	bl	600052e8 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
6000af88:	4632      	mov	r2, r6
6000af8a:	4629      	mov	r1, r5
6000af8c:	6960      	ldr	r0, [r4, #20]
6000af8e:	f7fa f93b 	bl	60005208 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(shell, &col);
6000af92:	a901      	add	r1, sp, #4
6000af94:	4620      	mov	r0, r4
6000af96:	f7fa f9dd 	bl	60005354 <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
6000af9a:	b003      	add	sp, #12
6000af9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
6000af9e:	4632      	mov	r2, r6
6000afa0:	4629      	mov	r1, r5
6000afa2:	6960      	ldr	r0, [r4, #20]
}
6000afa4:	b003      	add	sp, #12
6000afa6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
6000afaa:	f7fa b92d 	b.w	60005208 <z_shell_fprintf_fmt>

6000afae <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *shell,
			    enum shell_vt100_color color,
			    const char *fmt, ...)
{
6000afae:	b40c      	push	{r2, r3}
6000afb0:	b507      	push	{r0, r1, r2, lr}
6000afb2:	ab04      	add	r3, sp, #16
6000afb4:	f853 2b04 	ldr.w	r2, [r3], #4
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args;

	va_start(args, fmt);
6000afb8:	9301      	str	r3, [sp, #4]
	z_shell_vfprintf(shell, color, fmt, args);
6000afba:	f7ff ffce 	bl	6000af5a <z_shell_vfprintf>
	va_end(args);
}
6000afbe:	b003      	add	sp, #12
6000afc0:	f85d eb04 	ldr.w	lr, [sp], #4
6000afc4:	b002      	add	sp, #8
6000afc6:	4770      	bx	lr

6000afc8 <data_insert>:
{
6000afc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
6000afcc:	6886      	ldr	r6, [r0, #8]
{
6000afce:	4607      	mov	r7, r0
6000afd0:	4688      	mov	r8, r1
6000afd2:	4614      	mov	r4, r2
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
6000afd4:	8f35      	ldrh	r5, [r6, #56]	; 0x38
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
6000afd6:	18ab      	adds	r3, r5, r2
6000afd8:	2bff      	cmp	r3, #255	; 0xff
6000afda:	dc1e      	bgt.n	6000b01a <data_insert+0x52>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
6000afdc:	8f73      	ldrh	r3, [r6, #58]	; 0x3a
6000afde:	1aed      	subs	r5, r5, r3
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
6000afe0:	333e      	adds	r3, #62	; 0x3e
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
6000afe2:	b2ad      	uxth	r5, r5
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
6000afe4:	441e      	add	r6, r3
	memmove(curr_pos + len, curr_pos, after);
6000afe6:	462a      	mov	r2, r5
6000afe8:	4631      	mov	r1, r6
6000afea:	1930      	adds	r0, r6, r4
6000afec:	f000 fc99 	bl	6000b922 <memmove>
	memcpy(curr_pos, data, len);
6000aff0:	4622      	mov	r2, r4
6000aff2:	4641      	mov	r1, r8
6000aff4:	4630      	mov	r0, r6
6000aff6:	f000 fcac 	bl	6000b952 <memcpy>
	shell->ctx->cmd_buff_len += len;
6000affa:	68b9      	ldr	r1, [r7, #8]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
6000affc:	2200      	movs	r2, #0
	shell->ctx->cmd_buff_len += len;
6000affe:	8f0b      	ldrh	r3, [r1, #56]	; 0x38
6000b000:	4423      	add	r3, r4
6000b002:	b29b      	uxth	r3, r3
6000b004:	870b      	strh	r3, [r1, #56]	; 0x38
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
6000b006:	440b      	add	r3, r1
6000b008:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
	return shell->ctx->internal.flags.echo == 1;
6000b00c:	f8d1 325c 	ldr.w	r3, [r1, #604]	; 0x25c
	if (!z_flag_echo_get(shell)) {
6000b010:	075b      	lsls	r3, r3, #29
6000b012:	d404      	bmi.n	6000b01e <data_insert+0x56>
		shell->ctx->cmd_buff_pos += len;
6000b014:	8f4a      	ldrh	r2, [r1, #58]	; 0x3a
6000b016:	4414      	add	r4, r2
6000b018:	874c      	strh	r4, [r1, #58]	; 0x3a
}
6000b01a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	reprint_from_cursor(shell, after, false);
6000b01e:	4629      	mov	r1, r5
6000b020:	4638      	mov	r0, r7
}
6000b022:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	reprint_from_cursor(shell, after, false);
6000b026:	f7fa ba15 	b.w	60005454 <reprint_from_cursor>

6000b02a <z_shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
6000b02a:	f7ff bfcd 	b.w	6000afc8 <data_insert>

6000b02e <z_shell_op_char_delete>:
{
6000b02e:	b538      	push	{r3, r4, r5, lr}
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
6000b030:	6883      	ldr	r3, [r0, #8]
{
6000b032:	4605      	mov	r5, r0
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
6000b034:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
6000b036:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
6000b038:	1a24      	subs	r4, r4, r0
6000b03a:	b2a4      	uxth	r4, r4
	if (diff == 0U) {
6000b03c:	b18c      	cbz	r4, 6000b062 <z_shell_op_char_delete+0x34>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
6000b03e:	303e      	adds	r0, #62	; 0x3e
	memmove(str, str + 1, diff);
6000b040:	4622      	mov	r2, r4
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
6000b042:	4418      	add	r0, r3
	memmove(str, str + 1, diff);
6000b044:	1c41      	adds	r1, r0, #1
6000b046:	f000 fc6c 	bl	6000b922 <memmove>
	--shell->ctx->cmd_buff_len;
6000b04a:	68aa      	ldr	r2, [r5, #8]
	reprint_from_cursor(shell, --diff, true);
6000b04c:	1e61      	subs	r1, r4, #1
6000b04e:	4628      	mov	r0, r5
	--shell->ctx->cmd_buff_len;
6000b050:	8f13      	ldrh	r3, [r2, #56]	; 0x38
	reprint_from_cursor(shell, --diff, true);
6000b052:	b289      	uxth	r1, r1
	--shell->ctx->cmd_buff_len;
6000b054:	3b01      	subs	r3, #1
6000b056:	8713      	strh	r3, [r2, #56]	; 0x38
	reprint_from_cursor(shell, --diff, true);
6000b058:	2201      	movs	r2, #1
}
6000b05a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	reprint_from_cursor(shell, --diff, true);
6000b05e:	f7fa b9f9 	b.w	60005454 <reprint_from_cursor>
}
6000b062:	bd38      	pop	{r3, r4, r5, pc}

6000b064 <z_shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
6000b064:	6883      	ldr	r3, [r0, #8]
6000b066:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
{
6000b068:	b510      	push	{r4, lr}
6000b06a:	4604      	mov	r4, r0
	if ((shell->ctx->cmd_buff_len == 0) ||
6000b06c:	b152      	cbz	r2, 6000b084 <z_shell_op_char_backspace+0x20>
6000b06e:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
6000b070:	b143      	cbz	r3, 6000b084 <z_shell_op_char_backspace+0x20>
	z_shell_op_cursor_move(shell, -1);
6000b072:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
6000b076:	f7ff fe8e 	bl	6000ad96 <z_shell_op_cursor_move>
	z_shell_op_char_delete(shell);
6000b07a:	4620      	mov	r0, r4
}
6000b07c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_shell_op_char_delete(shell);
6000b080:	f7ff bfd5 	b.w	6000b02e <z_shell_op_char_delete>
}
6000b084:	bd10      	pop	{r4, pc}

6000b086 <uart_irq_tx_disable>:
	if (api->irq_tx_disable != NULL) {
6000b086:	6883      	ldr	r3, [r0, #8]
6000b088:	6a1b      	ldr	r3, [r3, #32]
6000b08a:	b103      	cbz	r3, 6000b08e <uart_irq_tx_disable+0x8>
		api->irq_tx_disable(dev);
6000b08c:	4718      	bx	r3
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
}
6000b08e:	4770      	bx	lr

6000b090 <uninit>:
		const struct device *dev = sh_uart->ctrl_blk->dev;
6000b090:	6843      	ldr	r3, [r0, #4]
6000b092:	681b      	ldr	r3, [r3, #0]
{
6000b094:	b510      	push	{r4, lr}
		const struct device *dev = sh_uart->ctrl_blk->dev;
6000b096:	681c      	ldr	r4, [r3, #0]
		uart_irq_tx_disable(dev);
6000b098:	4620      	mov	r0, r4
6000b09a:	f7ff fff4 	bl	6000b086 <uart_irq_tx_disable>
	if (api->irq_rx_disable != NULL) {
6000b09e:	68a3      	ldr	r3, [r4, #8]
6000b0a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
6000b0a2:	b10b      	cbz	r3, 6000b0a8 <uninit+0x18>
		api->irq_rx_disable(dev);
6000b0a4:	4620      	mov	r0, r4
6000b0a6:	4798      	blx	r3
}
6000b0a8:	2000      	movs	r0, #0
6000b0aa:	bd10      	pop	{r4, pc}

6000b0ac <enable>:
{
6000b0ac:	b508      	push	{r3, lr}
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
6000b0ae:	6843      	ldr	r3, [r0, #4]
6000b0b0:	681b      	ldr	r3, [r3, #0]
6000b0b2:	7419      	strb	r1, [r3, #16]
	if (blocking_tx) {
6000b0b4:	b111      	cbz	r1, 6000b0bc <enable+0x10>
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
6000b0b6:	6818      	ldr	r0, [r3, #0]
6000b0b8:	f7ff ffe5 	bl	6000b086 <uart_irq_tx_disable>
}
6000b0bc:	2000      	movs	r0, #0
6000b0be:	bd08      	pop	{r3, pc}

6000b0c0 <read>:
{
6000b0c0:	b510      	push	{r4, lr}
6000b0c2:	461c      	mov	r4, r3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
6000b0c4:	6843      	ldr	r3, [r0, #4]
6000b0c6:	68d8      	ldr	r0, [r3, #12]
6000b0c8:	f7fe fdf8 	bl	60009cbc <ring_buf_get>
6000b0cc:	6020      	str	r0, [r4, #0]
}
6000b0ce:	2000      	movs	r0, #0
6000b0d0:	bd10      	pop	{r4, pc}

6000b0d2 <write>:
{
6000b0d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
6000b0d6:	6845      	ldr	r5, [r0, #4]
{
6000b0d8:	461e      	mov	r6, r3
6000b0da:	460c      	mov	r4, r1
6000b0dc:	4617      	mov	r7, r2
		!sh_uart->ctrl_blk->blocking_tx) {
6000b0de:	682b      	ldr	r3, [r5, #0]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
6000b0e0:	7c1b      	ldrb	r3, [r3, #16]
6000b0e2:	b153      	cbz	r3, 6000b0fa <write+0x28>
6000b0e4:	eb01 0802 	add.w	r8, r1, r2
		for (size_t i = 0; i < length; i++) {
6000b0e8:	4544      	cmp	r4, r8
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
6000b0ea:	682b      	ldr	r3, [r5, #0]
		for (size_t i = 0; i < length; i++) {
6000b0ec:	d120      	bne.n	6000b130 <write+0x5e>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
6000b0ee:	2001      	movs	r0, #1
		*cnt = length;
6000b0f0:	6037      	str	r7, [r6, #0]
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
6000b0f2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
6000b0f6:	4790      	blx	r2
6000b0f8:	e017      	b.n	6000b12a <write+0x58>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
6000b0fa:	68a8      	ldr	r0, [r5, #8]
6000b0fc:	f7fe fd74 	bl	60009be8 <ring_buf_put>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
6000b100:	682b      	ldr	r3, [r5, #0]
6000b102:	2101      	movs	r1, #1
6000b104:	6030      	str	r0, [r6, #0]
6000b106:	330c      	adds	r3, #12
6000b108:	f3bf 8f5b 	dmb	ish
6000b10c:	e853 2f00 	ldrex	r2, [r3]
6000b110:	e843 1000 	strex	r0, r1, [r3]
6000b114:	2800      	cmp	r0, #0
6000b116:	d1f9      	bne.n	6000b10c <write+0x3a>
6000b118:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
6000b11c:	b92a      	cbnz	r2, 6000b12a <write+0x58>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
6000b11e:	682b      	ldr	r3, [r5, #0]
6000b120:	6818      	ldr	r0, [r3, #0]
	if (api->irq_tx_enable != NULL) {
6000b122:	6883      	ldr	r3, [r0, #8]
6000b124:	69db      	ldr	r3, [r3, #28]
6000b126:	b103      	cbz	r3, 6000b12a <write+0x58>
		api->irq_tx_enable(dev);
6000b128:	4798      	blx	r3
}
6000b12a:	2000      	movs	r0, #0
6000b12c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
6000b130:	6818      	ldr	r0, [r3, #0]
6000b132:	f814 1b01 	ldrb.w	r1, [r4], #1
	api->poll_out(dev, out_char);
6000b136:	6883      	ldr	r3, [r0, #8]
6000b138:	685b      	ldr	r3, [r3, #4]
6000b13a:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
6000b13c:	e7d4      	b.n	6000b0e8 <write+0x16>

6000b13e <z_shell_raw_fprintf>:
{
6000b13e:	b40e      	push	{r1, r2, r3}
6000b140:	b503      	push	{r0, r1, lr}
6000b142:	aa03      	add	r2, sp, #12
6000b144:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
6000b148:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
6000b14a:	f7fa f85d 	bl	60005208 <z_shell_fprintf_fmt>
}
6000b14e:	b002      	add	sp, #8
6000b150:	f85d eb04 	ldr.w	lr, [sp], #4
6000b154:	b003      	add	sp, #12
6000b156:	4770      	bx	lr

6000b158 <formatted_text_print.constprop.0>:
static void formatted_text_print(const struct shell *shell, const char *str,
6000b158:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
6000b15c:	4604      	mov	r4, r0
6000b15e:	4690      	mov	r8, r2
	if (str == NULL) {
6000b160:	460e      	mov	r6, r1
6000b162:	2900      	cmp	r1, #0
6000b164:	d069      	beq.n	6000b23a <formatted_text_print.constprop.0+0xe2>
6000b166:	2500      	movs	r5, #0
	while (isspace((int) *(str + offset))) {
6000b168:	5d73      	ldrb	r3, [r6, r5]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
6000b16a:	2b20      	cmp	r3, #32
6000b16c:	d023      	beq.n	6000b1b6 <formatted_text_print.constprop.0+0x5e>
6000b16e:	3b09      	subs	r3, #9
6000b170:	2b04      	cmp	r3, #4
6000b172:	d920      	bls.n	6000b1b6 <formatted_text_print.constprop.0+0x5e>
6000b174:	4630      	mov	r0, r6
6000b176:	eb06 0905 	add.w	r9, r6, r5
6000b17a:	f000 fb94 	bl	6000b8a6 <strlen>
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
6000b17e:	68a3      	ldr	r3, [r4, #8]
		length = z_shell_strlen(str) - offset;
6000b180:	b280      	uxth	r0, r0
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
6000b182:	8d59      	ldrh	r1, [r3, #42]	; 0x2a
		length = z_shell_strlen(str) - offset;
6000b184:	1b40      	subs	r0, r0, r5
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
6000b186:	eba1 0308 	sub.w	r3, r1, r8
		if (length <=
6000b18a:	4298      	cmp	r0, r3
6000b18c:	d915      	bls.n	6000b1ba <formatted_text_print.constprop.0+0x62>
6000b18e:	4648      	mov	r0, r9
		size_t idx = 0;
6000b190:	2700      	movs	r7, #0
			if (isspace((int) (*(str + offset + idx)))) {
6000b192:	f810 2b01 	ldrb.w	r2, [r0], #1
6000b196:	2a20      	cmp	r2, #32
6000b198:	d006      	beq.n	6000b1a8 <formatted_text_print.constprop.0+0x50>
6000b19a:	f1a2 0c09 	sub.w	ip, r2, #9
6000b19e:	f1bc 0f04 	cmp.w	ip, #4
6000b1a2:	d802      	bhi.n	6000b1aa <formatted_text_print.constprop.0+0x52>
				if (*(str + offset + idx) == '\n') {
6000b1a4:	2a0a      	cmp	r2, #10
6000b1a6:	d02f      	beq.n	6000b208 <formatted_text_print.constprop.0+0xb0>
6000b1a8:	463b      	mov	r3, r7
			if ((idx + terminal_offset) >=
6000b1aa:	eb08 0207 	add.w	r2, r8, r7
6000b1ae:	4291      	cmp	r1, r2
6000b1b0:	d929      	bls.n	6000b206 <formatted_text_print.constprop.0+0xae>
			++idx;
6000b1b2:	3701      	adds	r7, #1
			if (isspace((int) (*(str + offset + idx)))) {
6000b1b4:	e7ed      	b.n	6000b192 <formatted_text_print.constprop.0+0x3a>
		++offset;
6000b1b6:	3501      	adds	r5, #1
6000b1b8:	e7d6      	b.n	6000b168 <formatted_text_print.constprop.0+0x10>
6000b1ba:	464b      	mov	r3, r9
			for (idx = 0; idx < length; idx++) {
6000b1bc:	2700      	movs	r7, #0
6000b1be:	42b8      	cmp	r0, r7
6000b1c0:	d016      	beq.n	6000b1f0 <formatted_text_print.constprop.0+0x98>
				if (*(str + offset + idx) == '\n') {
6000b1c2:	f813 2b01 	ldrb.w	r2, [r3], #1
6000b1c6:	eb05 0a07 	add.w	sl, r5, r7
6000b1ca:	2a0a      	cmp	r2, #10
6000b1cc:	d119      	bne.n	6000b202 <formatted_text_print.constprop.0+0xaa>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
6000b1ce:	6960      	ldr	r0, [r4, #20]
					offset += idx + 1;
6000b1d0:	f10a 0501 	add.w	r5, sl, #1
6000b1d4:	f7ff fb6e 	bl	6000a8b4 <z_shell_fprintf_buffer_flush>
					z_shell_write(shell, str + offset, idx);
6000b1d8:	4649      	mov	r1, r9
6000b1da:	463a      	mov	r2, r7
6000b1dc:	4620      	mov	r0, r4
6000b1de:	f7ff fe7b 	bl	6000aed8 <z_shell_write>
					z_cursor_next_line_move(shell);
6000b1e2:	6960      	ldr	r0, [r4, #20]
6000b1e4:	f7fa fa8c 	bl	60005700 <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(shell,
6000b1e8:	4641      	mov	r1, r8
6000b1ea:	4620      	mov	r0, r4
6000b1ec:	f7fa f864 	bl	600052b8 <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, str + offset);
6000b1f0:	6960      	ldr	r0, [r4, #20]
6000b1f2:	1971      	adds	r1, r6, r5
6000b1f4:	f7ff ffa3 	bl	6000b13e <z_shell_raw_fprintf>
	z_cursor_next_line_move(shell);
6000b1f8:	6960      	ldr	r0, [r4, #20]
}
6000b1fa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_cursor_next_line_move(shell);
6000b1fe:	f7fa ba7f 	b.w	60005700 <z_cursor_next_line_move.isra.0>
			for (idx = 0; idx < length; idx++) {
6000b202:	3701      	adds	r7, #1
6000b204:	e7db      	b.n	6000b1be <formatted_text_print.constprop.0+0x66>
6000b206:	461f      	mov	r7, r3
6000b208:	6960      	ldr	r0, [r4, #20]
		offset += length;
6000b20a:	443d      	add	r5, r7
6000b20c:	f7ff fb52 	bl	6000a8b4 <z_shell_fprintf_buffer_flush>
		z_shell_write(shell, str + offset, length);
6000b210:	463a      	mov	r2, r7
6000b212:	4649      	mov	r1, r9
6000b214:	4620      	mov	r0, r4
6000b216:	f7ff fe5f 	bl	6000aed8 <z_shell_write>
		while (isspace((int) (*(str + offset)))) {
6000b21a:	5d73      	ldrb	r3, [r6, r5]
6000b21c:	2b20      	cmp	r3, #32
6000b21e:	d00a      	beq.n	6000b236 <formatted_text_print.constprop.0+0xde>
6000b220:	3b09      	subs	r3, #9
6000b222:	2b04      	cmp	r3, #4
6000b224:	d907      	bls.n	6000b236 <formatted_text_print.constprop.0+0xde>
		z_cursor_next_line_move(shell);
6000b226:	6960      	ldr	r0, [r4, #20]
6000b228:	f7fa fa6a 	bl	60005700 <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
6000b22c:	4641      	mov	r1, r8
6000b22e:	4620      	mov	r0, r4
6000b230:	f7fa f842 	bl	600052b8 <z_shell_op_cursor_horiz_move>
	while (true) {
6000b234:	e79e      	b.n	6000b174 <formatted_text_print.constprop.0+0x1c>
			++offset;
6000b236:	3501      	adds	r5, #1
6000b238:	e7ef      	b.n	6000b21a <formatted_text_print.constprop.0+0xc2>
}
6000b23a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

6000b23e <cmd_shell_stats_reset>:
	shell->stats->log_lost_cnt = 0;
6000b23e:	6983      	ldr	r3, [r0, #24]
6000b240:	2000      	movs	r0, #0
6000b242:	6018      	str	r0, [r3, #0]
}
6000b244:	4770      	bx	lr

6000b246 <z_shell_raw_fprintf>:
{
6000b246:	b40e      	push	{r1, r2, r3}
6000b248:	b503      	push	{r0, r1, lr}
6000b24a:	aa03      	add	r2, sp, #12
6000b24c:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
6000b250:	9201      	str	r2, [sp, #4]
	z_shell_fprintf_fmt(ctx, fmt, args);
6000b252:	f7f9 ffd9 	bl	60005208 <z_shell_fprintf_fmt>
}
6000b256:	b002      	add	sp, #8
6000b258:	f85d eb04 	ldr.w	lr, [sp], #4
6000b25c:	b003      	add	sp, #12
6000b25e:	4770      	bx	lr

6000b260 <cmd_bacskpace_mode_backspace>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
6000b260:	6883      	ldr	r3, [r0, #8]
6000b262:	f3bf 8f5b 	dmb	ish
6000b266:	f503 7317 	add.w	r3, r3, #604	; 0x25c
6000b26a:	e853 2f00 	ldrex	r2, [r3]
6000b26e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
6000b272:	e843 2100 	strex	r1, r2, [r3]
6000b276:	2900      	cmp	r1, #0
6000b278:	d1f7      	bne.n	6000b26a <cmd_bacskpace_mode_backspace+0xa>
}
6000b27a:	2000      	movs	r0, #0
6000b27c:	f3bf 8f5b 	dmb	ish
6000b280:	4770      	bx	lr

6000b282 <cmd_bacskpace_mode_delete>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
6000b282:	6883      	ldr	r3, [r0, #8]
6000b284:	f3bf 8f5b 	dmb	ish
6000b288:	f503 7317 	add.w	r3, r3, #604	; 0x25c
6000b28c:	e853 2f00 	ldrex	r2, [r3]
6000b290:	f042 0240 	orr.w	r2, r2, #64	; 0x40
6000b294:	e843 2100 	strex	r1, r2, [r3]
6000b298:	2900      	cmp	r1, #0
6000b29a:	d1f7      	bne.n	6000b28c <cmd_bacskpace_mode_delete+0xa>
}
6000b29c:	2000      	movs	r0, #0
6000b29e:	f3bf 8f5b 	dmb	ish
6000b2a2:	4770      	bx	lr

6000b2a4 <cmd_echo_off>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
6000b2a4:	6883      	ldr	r3, [r0, #8]
6000b2a6:	f3bf 8f5b 	dmb	ish
6000b2aa:	f503 7317 	add.w	r3, r3, #604	; 0x25c
6000b2ae:	e853 2f00 	ldrex	r2, [r3]
6000b2b2:	f022 0204 	bic.w	r2, r2, #4
6000b2b6:	e843 2100 	strex	r1, r2, [r3]
6000b2ba:	2900      	cmp	r1, #0
6000b2bc:	d1f7      	bne.n	6000b2ae <cmd_echo_off+0xa>
}
6000b2be:	2000      	movs	r0, #0
6000b2c0:	f3bf 8f5b 	dmb	ish
6000b2c4:	4770      	bx	lr

6000b2c6 <cmd_colors_off>:
6000b2c6:	6883      	ldr	r3, [r0, #8]
6000b2c8:	f3bf 8f5b 	dmb	ish
6000b2cc:	f503 7317 	add.w	r3, r3, #604	; 0x25c
6000b2d0:	e853 2f00 	ldrex	r2, [r3]
6000b2d4:	f022 0202 	bic.w	r2, r2, #2
6000b2d8:	e843 2100 	strex	r1, r2, [r3]
6000b2dc:	2900      	cmp	r1, #0
6000b2de:	d1f7      	bne.n	6000b2d0 <cmd_colors_off+0xa>
}
6000b2e0:	2000      	movs	r0, #0
6000b2e2:	f3bf 8f5b 	dmb	ish
6000b2e6:	4770      	bx	lr

6000b2e8 <cmd_colors_on>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
6000b2e8:	6883      	ldr	r3, [r0, #8]
6000b2ea:	f3bf 8f5b 	dmb	ish
6000b2ee:	f503 7317 	add.w	r3, r3, #604	; 0x25c
6000b2f2:	e853 2f00 	ldrex	r2, [r3]
6000b2f6:	f042 0202 	orr.w	r2, r2, #2
6000b2fa:	e843 2100 	strex	r1, r2, [r3]
6000b2fe:	2900      	cmp	r1, #0
6000b300:	d1f7      	bne.n	6000b2f2 <cmd_colors_on+0xa>
}
6000b302:	2000      	movs	r0, #0
6000b304:	f3bf 8f5b 	dmb	ish
6000b308:	4770      	bx	lr

6000b30a <cmd_echo_on>:
6000b30a:	6883      	ldr	r3, [r0, #8]
6000b30c:	f3bf 8f5b 	dmb	ish
6000b310:	f503 7317 	add.w	r3, r3, #604	; 0x25c
6000b314:	e853 2f00 	ldrex	r2, [r3]
6000b318:	f042 0204 	orr.w	r2, r2, #4
6000b31c:	e843 2100 	strex	r1, r2, [r3]
6000b320:	2900      	cmp	r1, #0
6000b322:	d1f7      	bne.n	6000b314 <cmd_echo_on+0xa>
}
6000b324:	2000      	movs	r0, #0
6000b326:	f3bf 8f5b 	dmb	ish
6000b32a:	4770      	bx	lr

6000b32c <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
6000b32c:	b508      	push	{r3, lr}
	return sys_dlist_is_empty(list) ? NULL : list->tail;
6000b32e:	6883      	ldr	r3, [r0, #8]

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
6000b330:	6800      	ldr	r0, [r0, #0]
	sys_dnode_t *const next = node->next;
6000b332:	e9d3 2100 	ldrd	r2, r1, [r3]
	prev->next = next;
6000b336:	600a      	str	r2, [r1, #0]
	next->prev = prev;
6000b338:	6051      	str	r1, [r2, #4]
	node->next = NULL;
6000b33a:	2200      	movs	r2, #0
			h_item->len + h_item->padding;
6000b33c:	8919      	ldrh	r1, [r3, #8]
	node->prev = NULL;
6000b33e:	e9c3 2200 	strd	r2, r2, [r3]
6000b342:	895b      	ldrh	r3, [r3, #10]
6000b344:	4419      	add	r1, r3
	ring_buf_get_finish(history->ring_buf, total_len);
6000b346:	310c      	adds	r1, #12
6000b348:	f7fe fc89 	bl	60009c5e <ring_buf_get_finish>

	return true;
}
6000b34c:	2001      	movs	r0, #1
6000b34e:	bd08      	pop	{r3, pc}

6000b350 <z_shell_history_mode_exit>:
	history->current = NULL;
6000b350:	2300      	movs	r3, #0
6000b352:	60c3      	str	r3, [r0, #12]
}
6000b354:	4770      	bx	lr

6000b356 <z_shell_history_get>:
{
6000b356:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000b358:	461f      	mov	r7, r3
	return list->head == list;
6000b35a:	4603      	mov	r3, r0
6000b35c:	4616      	mov	r6, r2
6000b35e:	f853 4f04 	ldr.w	r4, [r3, #4]!
	if (sys_dlist_is_empty(&history->list)) {
6000b362:	429c      	cmp	r4, r3
6000b364:	d102      	bne.n	6000b36c <z_shell_history_get+0x16>
		*len = 0U;
6000b366:	2000      	movs	r0, #0
6000b368:	8038      	strh	r0, [r7, #0]
}
6000b36a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (history->current == NULL) {
6000b36c:	68c5      	ldr	r5, [r0, #12]
	if (!up) { /* button down */
6000b36e:	b9b1      	cbnz	r1, 6000b39e <z_shell_history_get+0x48>
		if (history->current == NULL) {
6000b370:	2d00      	cmp	r5, #0
6000b372:	d0f8      	beq.n	6000b366 <z_shell_history_get+0x10>
	return (node == list->head) ? NULL : node->prev;
6000b374:	42ac      	cmp	r4, r5
6000b376:	d102      	bne.n	6000b37e <z_shell_history_get+0x28>
	history->current = l_item;
6000b378:	2300      	movs	r3, #0
6000b37a:	60c3      	str	r3, [r0, #12]
	if (l_item) {
6000b37c:	e7f3      	b.n	6000b366 <z_shell_history_get+0x10>
6000b37e:	686c      	ldr	r4, [r5, #4]
	history->current = l_item;
6000b380:	60c4      	str	r4, [r0, #12]
	if (l_item) {
6000b382:	2c00      	cmp	r4, #0
6000b384:	d0ef      	beq.n	6000b366 <z_shell_history_get+0x10>
		memcpy(dst, h_item->data, h_item->len);
6000b386:	8922      	ldrh	r2, [r4, #8]
6000b388:	f104 010c 	add.w	r1, r4, #12
6000b38c:	4630      	mov	r0, r6
6000b38e:	f000 fae0 	bl	6000b952 <memcpy>
		*len = h_item->len;
6000b392:	8923      	ldrh	r3, [r4, #8]
		dst[*len] = '\0';
6000b394:	2200      	movs	r2, #0
		return true;
6000b396:	2001      	movs	r0, #1
		*len = h_item->len;
6000b398:	803b      	strh	r3, [r7, #0]
		dst[*len] = '\0';
6000b39a:	54f2      	strb	r2, [r6, r3]
		return true;
6000b39c:	e7e5      	b.n	6000b36a <z_shell_history_get+0x14>
		sys_dlist_peek_head_not_empty(&history->list) :
6000b39e:	2d00      	cmp	r5, #0
6000b3a0:	d0ee      	beq.n	6000b380 <z_shell_history_get+0x2a>
	return (node == list->tail) ? NULL : node->next;
6000b3a2:	6883      	ldr	r3, [r0, #8]
6000b3a4:	42ab      	cmp	r3, r5
6000b3a6:	d0e7      	beq.n	6000b378 <z_shell_history_get+0x22>
6000b3a8:	682c      	ldr	r4, [r5, #0]
6000b3aa:	e7e9      	b.n	6000b380 <z_shell_history_get+0x2a>

6000b3ac <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
6000b3ac:	b538      	push	{r3, r4, r5, lr}
6000b3ae:	4604      	mov	r4, r0
	if (sys_dlist_is_empty(&history->list)) {
6000b3b0:	1d05      	adds	r5, r0, #4
6000b3b2:	6863      	ldr	r3, [r4, #4]
6000b3b4:	42ab      	cmp	r3, r5
6000b3b6:	d004      	beq.n	6000b3c2 <z_shell_history_purge+0x16>
6000b3b8:	4620      	mov	r0, r4
6000b3ba:	f7ff ffb7 	bl	6000b32c <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
6000b3be:	2800      	cmp	r0, #0
6000b3c0:	d1f7      	bne.n	6000b3b2 <z_shell_history_purge+0x6>
	}
}
6000b3c2:	bd38      	pop	{r3, r4, r5, pc}

6000b3c4 <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
6000b3c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
6000b3c8:	f102 050c 	add.w	r5, r2, #12
 *
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	return buf->size;
6000b3cc:	6803      	ldr	r3, [r0, #0]
{
6000b3ce:	4604      	mov	r4, r0
6000b3d0:	468a      	mov	sl, r1
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
6000b3d2:	f1c5 0800 	rsb	r8, r5, #0

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
6000b3d6:	691b      	ldr	r3, [r3, #16]
{
6000b3d8:	4617      	mov	r7, r2
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
6000b3da:	f008 0803 	and.w	r8, r8, #3
	total_len += padding;
6000b3de:	4445      	add	r5, r8
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
6000b3e0:	429d      	cmp	r5, r3
6000b3e2:	d841      	bhi.n	6000b468 <z_shell_history_put+0xa4>
	history->current = NULL;
6000b3e4:	2300      	movs	r3, #0
6000b3e6:	60c3      	str	r3, [r0, #12]
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
6000b3e8:	2a00      	cmp	r2, #0
6000b3ea:	d03d      	beq.n	6000b468 <z_shell_history_put+0xa4>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
6000b3ec:	f100 0904 	add.w	r9, r0, #4
	return list->head == list;
6000b3f0:	6840      	ldr	r0, [r0, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000b3f2:	4581      	cmp	r9, r0
6000b3f4:	d12d      	bne.n	6000b452 <z_shell_history_put+0x8e>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
6000b3f6:	9301      	str	r3, [sp, #4]
			add_to_head(history, h_item, line, len, padding);
			ring_buf_put_finish(history->ring_buf, claim_len);
			break;
		}

		ring_buf_put_finish(history->ring_buf, 0);
6000b3f8:	f04f 0b00 	mov.w	fp, #0
		claim_len = ring_buf_put_claim(history->ring_buf,
6000b3fc:	462a      	mov	r2, r5
6000b3fe:	a901      	add	r1, sp, #4
6000b400:	6820      	ldr	r0, [r4, #0]
6000b402:	f7fe fbc8 	bl	60009b96 <ring_buf_put_claim>
		if (claim_len < total_len) {
6000b406:	4285      	cmp	r5, r0
		claim_len = ring_buf_put_claim(history->ring_buf,
6000b408:	4606      	mov	r6, r0
		if (claim_len < total_len) {
6000b40a:	d930      	bls.n	6000b46e <z_shell_history_put+0xaa>
				ring_buf_put_claim(history->ring_buf,
6000b40c:	462a      	mov	r2, r5
6000b40e:	a901      	add	r1, sp, #4
6000b410:	6820      	ldr	r0, [r4, #0]
6000b412:	f7fe fbc0 	bl	60009b96 <ring_buf_put_claim>
			if (claim2_len == total_len) {
6000b416:	4285      	cmp	r5, r0
6000b418:	d12a      	bne.n	6000b470 <z_shell_history_put+0xac>
				padding += claim_len;
6000b41a:	44b0      	add	r8, r6
				ring_buf_put_finish(history->ring_buf,
6000b41c:	4631      	mov	r1, r6
				padding += claim_len;
6000b41e:	462e      	mov	r6, r5
				ring_buf_put_finish(history->ring_buf,
6000b420:	6820      	ldr	r0, [r4, #0]
				padding += claim_len;
6000b422:	fa1f f888 	uxth.w	r8, r8
				ring_buf_put_finish(history->ring_buf,
6000b426:	f7fe fbd2 	bl	60009bce <ring_buf_put_finish>
			add_to_head(history, h_item, line, len, padding);
6000b42a:	9d01      	ldr	r5, [sp, #4]
	memcpy(item->data, src, len);
6000b42c:	4651      	mov	r1, sl
6000b42e:	463a      	mov	r2, r7
6000b430:	f105 000c 	add.w	r0, r5, #12
	item->len = len;
6000b434:	812f      	strh	r7, [r5, #8]
	item->padding = padding;
6000b436:	f8a5 800a 	strh.w	r8, [r5, #10]
	memcpy(item->data, src, len);
6000b43a:	f000 fa8a 	bl	6000b952 <memcpy>
	sys_dnode_t *const head = list->head;
6000b43e:	6863      	ldr	r3, [r4, #4]
			ring_buf_put_finish(history->ring_buf, claim_len);
6000b440:	4631      	mov	r1, r6
6000b442:	6820      	ldr	r0, [r4, #0]
	node->prev = list;
6000b444:	e9c5 3900 	strd	r3, r9, [r5]
	head->prev = node;
6000b448:	605d      	str	r5, [r3, #4]
	list->head = node;
6000b44a:	6065      	str	r5, [r4, #4]
6000b44c:	f7fe fbbf 	bl	60009bce <ring_buf_put_finish>
			break;
6000b450:	e00a      	b.n	6000b468 <z_shell_history_put+0xa4>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
6000b452:	9001      	str	r0, [sp, #4]
	if (l_item &&
6000b454:	2800      	cmp	r0, #0
6000b456:	d0cf      	beq.n	6000b3f8 <z_shell_history_put+0x34>
	   (h_item->len == len) &&
6000b458:	8903      	ldrh	r3, [r0, #8]
	if (l_item &&
6000b45a:	4293      	cmp	r3, r2
6000b45c:	d1cc      	bne.n	6000b3f8 <z_shell_history_put+0x34>
	   (memcmp(h_item->data, line, len) == 0)) {
6000b45e:	300c      	adds	r0, #12
6000b460:	f000 fa4e 	bl	6000b900 <memcmp>
	   (h_item->len == len) &&
6000b464:	2800      	cmp	r0, #0
6000b466:	d1c7      	bne.n	6000b3f8 <z_shell_history_put+0x34>
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
		}
	} while (1);
}
6000b468:	b003      	add	sp, #12
6000b46a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (claim_len == total_len) {
6000b46e:	d0dc      	beq.n	6000b42a <z_shell_history_put+0x66>
		ring_buf_put_finish(history->ring_buf, 0);
6000b470:	2100      	movs	r1, #0
6000b472:	6820      	ldr	r0, [r4, #0]
6000b474:	f7fe fbab 	bl	60009bce <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
6000b478:	6863      	ldr	r3, [r4, #4]
6000b47a:	4599      	cmp	r9, r3
6000b47c:	d108      	bne.n	6000b490 <z_shell_history_put+0xcc>
			ring_buf_reset(history->ring_buf);
6000b47e:	6820      	ldr	r0, [r4, #0]
	memset(&buf->misc, 0, sizeof(buf->misc));
6000b480:	2208      	movs	r2, #8
6000b482:	2100      	movs	r1, #0
	buf->tail = 0;
6000b484:	e9c0 bb00 	strd	fp, fp, [r0]
	memset(&buf->misc, 0, sizeof(buf->misc));
6000b488:	4410      	add	r0, r2
6000b48a:	f000 fa8d 	bl	6000b9a8 <memset>
}
6000b48e:	e7b5      	b.n	6000b3fc <z_shell_history_put+0x38>
6000b490:	4620      	mov	r0, r4
6000b492:	f7ff ff4b 	bl	6000b32c <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
6000b496:	2800      	cmp	r0, #0
6000b498:	d1b0      	bne.n	6000b3fc <z_shell_history_put+0x38>
6000b49a:	e7f0      	b.n	6000b47e <z_shell_history_put+0xba>

6000b49c <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
6000b49c:	1d03      	adds	r3, r0, #4
	list->tail = (sys_dnode_t *)list;
6000b49e:	e9c0 3301 	strd	r3, r3, [r0, #4]
	history->current = NULL;
6000b4a2:	2300      	movs	r3, #0
6000b4a4:	60c3      	str	r3, [r0, #12]
}
6000b4a6:	4770      	bx	lr

6000b4a8 <msg_from_fifo.isra.0>:
{
	z_shell_print_stream(ctx, data, length);
	return length;
}

static struct log_msg *msg_from_fifo(const struct shell_log_backend *backend)
6000b4a8:	b507      	push	{r0, r1, r2, lr}
	return z_impl_k_msgq_get(msgq, data, timeout);
6000b4aa:	2200      	movs	r2, #0
6000b4ac:	2300      	movs	r3, #0
6000b4ae:	4669      	mov	r1, sp
6000b4b0:	f7fd f866 	bl	60008580 <z_impl_k_msgq_get>
	struct shell_log_backend_msg msg;
	int err;

	err = k_msgq_get(backend->msgq, &msg, K_NO_WAIT);

	return (err == 0) ? msg.msg : NULL;
6000b4b4:	b918      	cbnz	r0, 6000b4be <msg_from_fifo.isra.0+0x16>
6000b4b6:	9800      	ldr	r0, [sp, #0]
}
6000b4b8:	b003      	add	sp, #12
6000b4ba:	f85d fb04 	ldr.w	pc, [sp], #4
	return (err == 0) ? msg.msg : NULL;
6000b4be:	2000      	movs	r0, #0
6000b4c0:	e7fa      	b.n	6000b4b8 <msg_from_fifo.isra.0+0x10>

6000b4c2 <put>:

	return true;
}

static void put(const struct log_backend *const backend, struct log_msg *msg)
{
6000b4c2:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
6000b4c6:	6843      	ldr	r3, [r0, #4]
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			shell->ctx->internal.flags.use_colors;
	struct k_poll_signal *signal;

	log_msg_get(msg);
6000b4c8:	4608      	mov	r0, r1
{
6000b4ca:	460d      	mov	r5, r1
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
6000b4cc:	681c      	ldr	r4, [r3, #0]
			shell->ctx->internal.flags.use_colors;
6000b4ce:	68a3      	ldr	r3, [r4, #8]
6000b4d0:	f8d3 625c 	ldr.w	r6, [r3, #604]	; 0x25c
	log_msg_get(msg);
6000b4d4:	f7fe fe60 	bl	6000a198 <log_msg_get>

	switch (shell->log_backend->control_block->state) {
6000b4d8:	69e3      	ldr	r3, [r4, #28]
			shell->ctx->internal.flags.use_colors;
6000b4da:	f3c6 0640 	ubfx	r6, r6, #1, #1
	switch (shell->log_backend->control_block->state) {
6000b4de:	68db      	ldr	r3, [r3, #12]
6000b4e0:	791b      	ldrb	r3, [r3, #4]
6000b4e2:	2b01      	cmp	r3, #1
6000b4e4:	d007      	beq.n	6000b4f6 <put+0x34>
6000b4e6:	2b03      	cmp	r3, #3
6000b4e8:	d04f      	beq.n	6000b58a <put+0xc8>

	case SHELL_LOG_BACKEND_DISABLED:
		__fallthrough;
	default:
		/* Discard message. */
		log_msg_put(msg);
6000b4ea:	4628      	mov	r0, r5
	}
}
6000b4ec:	b004      	add	sp, #16
6000b4ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		log_msg_put(msg);
6000b4f2:	f7fe be80 	b.w	6000a1f6 <log_msg_put>
	struct shell_log_backend_msg t_msg = {
6000b4f6:	9500      	str	r5, [sp, #0]
			return t * (to_hz / from_hz);
6000b4f8:	260a      	movs	r6, #10
	return z_impl_k_uptime_ticks();
6000b4fa:	f001 f823 	bl	6000c544 <z_impl_k_uptime_ticks>
			return t / (from_hz / to_hz);
6000b4fe:	220a      	movs	r2, #10
6000b500:	2300      	movs	r3, #0
6000b502:	f7f6 fedd 	bl	600022c0 <__aeabi_uldivmod>
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
	return (uint32_t)k_uptime_get();
6000b506:	9001      	str	r0, [sp, #4]
		err = k_msgq_put(shell->log_backend->msgq, &t_msg,
6000b508:	69e3      	ldr	r3, [r4, #28]
6000b50a:	6858      	ldr	r0, [r3, #4]
			return t * (to_hz / from_hz);
6000b50c:	691b      	ldr	r3, [r3, #16]
6000b50e:	fba3 2306 	umull	r2, r3, r3, r6
	return z_impl_k_msgq_put(msgq, data, timeout);
6000b512:	4669      	mov	r1, sp
6000b514:	f7fc ffde 	bl	600084d4 <z_impl_k_msgq_put>
		switch (err) {
6000b518:	f110 0f23 	cmn.w	r0, #35	; 0x23
6000b51c:	d00a      	beq.n	6000b534 <put+0x72>
6000b51e:	300b      	adds	r0, #11
6000b520:	d008      	beq.n	6000b534 <put+0x72>
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
6000b522:	68a0      	ldr	r0, [r4, #8]
6000b524:	f500 701c 	add.w	r0, r0, #624	; 0x270
	return z_impl_k_poll_signal_raise(sig, result);
6000b528:	2100      	movs	r1, #0
}
6000b52a:	b004      	add	sp, #16
6000b52c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
6000b530:	f7fe b832 	b.w	60009598 <z_impl_k_poll_signal_raise>
	struct k_msgq *msgq = shell->log_backend->msgq;
6000b534:	69e3      	ldr	r3, [r4, #28]
6000b536:	685f      	ldr	r7, [r3, #4]
	uint32_t timeout = shell->log_backend->timeout;
6000b538:	f8d3 8010 	ldr.w	r8, [r3, #16]
	return z_impl_k_uptime_ticks();
6000b53c:	f001 f802 	bl	6000c544 <z_impl_k_uptime_ticks>
			return t / (from_hz / to_hz);
6000b540:	220a      	movs	r2, #10
6000b542:	2300      	movs	r3, #0
6000b544:	f7f6 febc 	bl	600022c0 <__aeabi_uldivmod>
6000b548:	4605      	mov	r5, r0
	return z_impl_k_msgq_peek(msgq, data);
6000b54a:	a902      	add	r1, sp, #8
6000b54c:	4638      	mov	r0, r7
6000b54e:	f000 fe73 	bl	6000c238 <z_impl_k_msgq_peek>
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
6000b552:	2800      	cmp	r0, #0
6000b554:	d1d8      	bne.n	6000b508 <put+0x46>
6000b556:	9b03      	ldr	r3, [sp, #12]
6000b558:	1aeb      	subs	r3, r5, r3
6000b55a:	4598      	cmp	r8, r3
6000b55c:	d2d4      	bcs.n	6000b508 <put+0x46>
	return z_impl_k_msgq_get(msgq, data, timeout);
6000b55e:	2300      	movs	r3, #0
6000b560:	2200      	movs	r2, #0
6000b562:	a902      	add	r1, sp, #8
6000b564:	4638      	mov	r0, r7
6000b566:	f7fd f80b 	bl	60008580 <z_impl_k_msgq_get>
			log_msg_put(msg.msg);
6000b56a:	9802      	ldr	r0, [sp, #8]
6000b56c:	f7fe fe43 	bl	6000a1f6 <log_msg_put>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
6000b570:	69a3      	ldr	r3, [r4, #24]
6000b572:	f3bf 8f5b 	dmb	ish
6000b576:	e853 2f00 	ldrex	r2, [r3]
6000b57a:	3201      	adds	r2, #1
6000b57c:	e843 2100 	strex	r1, r2, [r3]
6000b580:	2900      	cmp	r1, #0
6000b582:	d1f8      	bne.n	6000b576 <put+0xb4>
6000b584:	f3bf 8f5b 	dmb	ish
		err = k_msgq_peek(msgq, &msg);
6000b588:	e7df      	b.n	6000b54a <put+0x88>
		z_shell_cmd_line_erase(shell);
6000b58a:	4620      	mov	r0, r4
6000b58c:	f7ff fc8a 	bl	6000aea4 <z_shell_cmd_line_erase>
		flags |= LOG_OUTPUT_FLAG_COLORS;
6000b590:	2e00      	cmp	r6, #0
		msg_process(shell->log_backend->log_output, msg, colors);
6000b592:	69e3      	ldr	r3, [r4, #28]
	log_output_msg_process(log_output, msg, flags);
6000b594:	4629      	mov	r1, r5
6000b596:	bf0c      	ite	eq
6000b598:	220e      	moveq	r2, #14
6000b59a:	220f      	movne	r2, #15
6000b59c:	6898      	ldr	r0, [r3, #8]
6000b59e:	f7f8 fadb 	bl	60003b58 <log_output_msg_process>
	log_msg_put(msg);
6000b5a2:	e7a2      	b.n	6000b4ea <put+0x28>

6000b5a4 <dropped>:
	}
}

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
6000b5a4:	6843      	ldr	r3, [r0, #4]
6000b5a6:	681b      	ldr	r3, [r3, #0]
6000b5a8:	e9d3 3206 	ldrd	r3, r2, [r3, #24]
6000b5ac:	f3bf 8f5b 	dmb	ish
6000b5b0:	e853 0f00 	ldrex	r0, [r3]
6000b5b4:	4408      	add	r0, r1
6000b5b6:	e843 0c00 	strex	ip, r0, [r3]
6000b5ba:	f1bc 0f00 	cmp.w	ip, #0
6000b5be:	d1f7      	bne.n	6000b5b0 <dropped+0xc>
6000b5c0:	f3bf 8f5b 	dmb	ish
6000b5c4:	68d3      	ldr	r3, [r2, #12]
6000b5c6:	f3bf 8f5b 	dmb	ish
6000b5ca:	e853 2f00 	ldrex	r2, [r3]
6000b5ce:	440a      	add	r2, r1
6000b5d0:	e843 2000 	strex	r0, r2, [r3]
6000b5d4:	2800      	cmp	r0, #0
6000b5d6:	d1f8      	bne.n	6000b5ca <dropped+0x26>
6000b5d8:	f3bf 8f5b 	dmb	ish
	const struct shell_log_backend *log_backend = shell->log_backend;

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
6000b5dc:	4770      	bx	lr

6000b5de <z_shell_log_backend_output_func>:
{
6000b5de:	4613      	mov	r3, r2
	z_shell_print_stream(ctx, data, length);
6000b5e0:	460a      	mov	r2, r1
{
6000b5e2:	b510      	push	{r4, lr}
6000b5e4:	460c      	mov	r4, r1
	z_shell_print_stream(ctx, data, length);
6000b5e6:	4601      	mov	r1, r0
6000b5e8:	4618      	mov	r0, r3
6000b5ea:	f7ff fcb4 	bl	6000af56 <z_shell_print_stream>
}
6000b5ee:	4620      	mov	r0, r4
6000b5f0:	bd10      	pop	{r4, pc}

6000b5f2 <z_shell_log_backend_enable>:
{
6000b5f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000b5f4:	4604      	mov	r4, r0
6000b5f6:	460e      	mov	r6, r1
6000b5f8:	4617      	mov	r7, r2
		while ((msg = msg_from_fifo(backend)) != NULL) {
6000b5fa:	6860      	ldr	r0, [r4, #4]
6000b5fc:	f7ff ff54 	bl	6000b4a8 <msg_from_fifo.isra.0>
6000b600:	4605      	mov	r5, r0
6000b602:	b960      	cbnz	r0, 6000b61e <z_shell_log_backend_enable+0x2c>
		log_backend_enable(backend->backend, ctx, init_log_level);
6000b604:	463a      	mov	r2, r7
6000b606:	4631      	mov	r1, r6
6000b608:	6820      	ldr	r0, [r4, #0]
6000b60a:	f7f7 fecb 	bl	600033a4 <log_backend_enable>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *output,
				      void *ctx)
{
	output->control_block->ctx = ctx;
6000b60e:	68a3      	ldr	r3, [r4, #8]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
6000b610:	2201      	movs	r2, #1
6000b612:	685b      	ldr	r3, [r3, #4]
6000b614:	605e      	str	r6, [r3, #4]
		backend->control_block->dropped_cnt = 0;
6000b616:	68e3      	ldr	r3, [r4, #12]
6000b618:	601d      	str	r5, [r3, #0]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
6000b61a:	711a      	strb	r2, [r3, #4]
}
6000b61c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			log_msg_put(msg);
6000b61e:	f7fe fdea 	bl	6000a1f6 <log_msg_put>
6000b622:	e7ea      	b.n	6000b5fa <z_shell_log_backend_enable+0x8>

6000b624 <z_shell_log_backend_disable>:
{
6000b624:	b510      	push	{r4, lr}
6000b626:	4604      	mov	r4, r0
	log_backend_disable(backend->backend);
6000b628:	6800      	ldr	r0, [r0, #0]
6000b62a:	f7fe fcec 	bl	6000a006 <log_backend_disable>
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
6000b62e:	2202      	movs	r2, #2
6000b630:	68e3      	ldr	r3, [r4, #12]
6000b632:	711a      	strb	r2, [r3, #4]
}
6000b634:	bd10      	pop	{r4, pc}

6000b636 <z_shell_log_backend_process>:
			(const struct shell *)backend->backend->cb->ctx;
6000b636:	6803      	ldr	r3, [r0, #0]
	const struct shell *shell =
6000b638:	685b      	ldr	r3, [r3, #4]
{
6000b63a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	const struct shell *shell =
6000b63c:	681e      	ldr	r6, [r3, #0]
{
6000b63e:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
6000b640:	2200      	movs	r2, #0
			shell->ctx->internal.flags.use_colors;
6000b642:	68b3      	ldr	r3, [r6, #8]
6000b644:	f8d3 525c 	ldr.w	r5, [r3, #604]	; 0x25c
6000b648:	68c3      	ldr	r3, [r0, #12]
6000b64a:	f3bf 8f5b 	dmb	ish
6000b64e:	f3c5 0540 	ubfx	r5, r5, #1, #1
6000b652:	e853 7f00 	ldrex	r7, [r3]
6000b656:	e843 2100 	strex	r1, r2, [r3]
6000b65a:	2900      	cmp	r1, #0
6000b65c:	d1f9      	bne.n	6000b652 <z_shell_log_backend_process+0x1c>
6000b65e:	f3bf 8f5b 	dmb	ish
	if (dropped) {
6000b662:	b19f      	cbz	r7, 6000b68c <z_shell_log_backend_process+0x56>
		if (colors) {
6000b664:	b14d      	cbz	r5, 6000b67a <z_shell_log_backend_process+0x44>
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
6000b666:	68b1      	ldr	r1, [r6, #8]
6000b668:	2202      	movs	r2, #2
6000b66a:	a801      	add	r0, sp, #4
6000b66c:	312e      	adds	r1, #46	; 0x2e
6000b66e:	f000 f970 	bl	6000b952 <memcpy>
			z_shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
6000b672:	2102      	movs	r1, #2
6000b674:	4630      	mov	r0, r6
6000b676:	f7f9 fe37 	bl	600052e8 <z_shell_vt100_color_set>
		log_output_dropped_process(backend->log_output, dropped);
6000b67a:	4639      	mov	r1, r7
6000b67c:	68a0      	ldr	r0, [r4, #8]
6000b67e:	f7f8 fae7 	bl	60003c50 <log_output_dropped_process>
		if (colors) {
6000b682:	b11d      	cbz	r5, 6000b68c <z_shell_log_backend_process+0x56>
			z_shell_vt100_colors_restore(shell, &col);
6000b684:	a901      	add	r1, sp, #4
6000b686:	4630      	mov	r0, r6
6000b688:	f7f9 fe64 	bl	60005354 <z_shell_vt100_colors_restore>
	struct log_msg *msg = msg_from_fifo(backend);
6000b68c:	6860      	ldr	r0, [r4, #4]
6000b68e:	f7ff ff0b 	bl	6000b4a8 <msg_from_fifo.isra.0>
	if (!msg) {
6000b692:	4604      	mov	r4, r0
6000b694:	b168      	cbz	r0, 6000b6b2 <z_shell_log_backend_process+0x7c>
		flags |= LOG_OUTPUT_FLAG_COLORS;
6000b696:	2d00      	cmp	r5, #0
	msg_process(shell->log_backend->log_output, msg, colors);
6000b698:	69f3      	ldr	r3, [r6, #28]
	log_output_msg_process(log_output, msg, flags);
6000b69a:	4601      	mov	r1, r0
6000b69c:	bf08      	it	eq
6000b69e:	220e      	moveq	r2, #14
6000b6a0:	6898      	ldr	r0, [r3, #8]
6000b6a2:	bf18      	it	ne
6000b6a4:	220f      	movne	r2, #15
6000b6a6:	f7f8 fa57 	bl	60003b58 <log_output_msg_process>
	log_msg_put(msg);
6000b6aa:	4620      	mov	r0, r4
6000b6ac:	f7fe fda3 	bl	6000a1f6 <log_msg_put>
	return true;
6000b6b0:	2001      	movs	r0, #1
}
6000b6b2:	b003      	add	sp, #12
6000b6b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

6000b6b6 <panic>:
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
6000b6b6:	6843      	ldr	r3, [r0, #4]
	err = shell->iface->api->enable(shell->iface, true);
6000b6b8:	2101      	movs	r1, #1
{
6000b6ba:	b510      	push	{r4, lr}
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
6000b6bc:	681c      	ldr	r4, [r3, #0]
	err = shell->iface->api->enable(shell->iface, true);
6000b6be:	6860      	ldr	r0, [r4, #4]
6000b6c0:	6803      	ldr	r3, [r0, #0]
6000b6c2:	689b      	ldr	r3, [r3, #8]
6000b6c4:	4798      	blx	r3
	if (err == 0) {
6000b6c6:	b9d0      	cbnz	r0, 6000b6fe <panic+0x48>
		shell->log_backend->control_block->state =
6000b6c8:	69e3      	ldr	r3, [r4, #28]
6000b6ca:	2203      	movs	r2, #3
6000b6cc:	68db      	ldr	r3, [r3, #12]
6000b6ce:	711a      	strb	r2, [r3, #4]
		z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
6000b6d0:	68a0      	ldr	r0, [r4, #8]
6000b6d2:	8f02      	ldrh	r2, [r0, #56]	; 0x38
6000b6d4:	3020      	adds	r0, #32
6000b6d6:	8b41      	ldrh	r1, [r0, #26]
6000b6d8:	f7ff f93e 	bl	6000a958 <z_shell_multiline_data_calc>
		z_shell_op_cursor_vert_move(shell, -1);
6000b6dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
6000b6e0:	4620      	mov	r0, r4
6000b6e2:	f7f9 fdd9 	bl	60005298 <z_shell_op_cursor_vert_move>
					   -shell->ctx->vt100_ctx.cons.cur_x);
6000b6e6:	68a3      	ldr	r3, [r4, #8]
		z_shell_op_cursor_horiz_move(shell,
6000b6e8:	4620      	mov	r0, r4
					   -shell->ctx->vt100_ctx.cons.cur_x);
6000b6ea:	8c19      	ldrh	r1, [r3, #32]
		z_shell_op_cursor_horiz_move(shell,
6000b6ec:	4249      	negs	r1, r1
6000b6ee:	f7f9 fde3 	bl	600052b8 <z_shell_op_cursor_horiz_move>
			while (z_shell_log_backend_process(
6000b6f2:	69e0      	ldr	r0, [r4, #28]
6000b6f4:	f7ff ff9f 	bl	6000b636 <z_shell_log_backend_process>
6000b6f8:	2800      	cmp	r0, #0
6000b6fa:	d1fa      	bne.n	6000b6f2 <panic+0x3c>
}
6000b6fc:	bd10      	pop	{r4, pc}
		z_shell_log_backend_disable(shell->log_backend);
6000b6fe:	69e0      	ldr	r0, [r4, #28]
}
6000b700:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_shell_log_backend_disable(shell->log_backend);
6000b704:	f7ff bf8e 	b.w	6000b624 <z_shell_log_backend_disable>

6000b708 <z_shell_has_wildcard>:
{
6000b708:	b510      	push	{r4, lr}
	return str == NULL ? 0U : (uint16_t)strlen(str);
6000b70a:	4604      	mov	r4, r0
6000b70c:	b908      	cbnz	r0, 6000b712 <z_shell_has_wildcard+0xa>
	return false;
6000b70e:	2000      	movs	r0, #0
}
6000b710:	bd10      	pop	{r4, pc}
6000b712:	f000 f8c8 	bl	6000b8a6 <strlen>
	for (size_t i = 0; i < str_len; i++) {
6000b716:	2300      	movs	r3, #0
6000b718:	b280      	uxth	r0, r0
6000b71a:	4283      	cmp	r3, r0
6000b71c:	d2f7      	bcs.n	6000b70e <z_shell_has_wildcard+0x6>
		if ((str[i] == '?') || (str[i] == '*')) {
6000b71e:	5ce2      	ldrb	r2, [r4, r3]
6000b720:	2a3f      	cmp	r2, #63	; 0x3f
6000b722:	d003      	beq.n	6000b72c <z_shell_has_wildcard+0x24>
6000b724:	2a2a      	cmp	r2, #42	; 0x2a
6000b726:	d001      	beq.n	6000b72c <z_shell_has_wildcard+0x24>
	for (size_t i = 0; i < str_len; i++) {
6000b728:	3301      	adds	r3, #1
6000b72a:	e7f6      	b.n	6000b71a <z_shell_has_wildcard+0x12>
			return true;
6000b72c:	2001      	movs	r0, #1
6000b72e:	e7ef      	b.n	6000b710 <z_shell_has_wildcard+0x8>

6000b730 <z_shell_wildcard_prepare>:
{
6000b730:	b510      	push	{r4, lr}
6000b732:	4604      	mov	r4, r0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
6000b734:	6880      	ldr	r0, [r0, #8]
6000b736:	f44f 7280 	mov.w	r2, #256	; 0x100
6000b73a:	2100      	movs	r1, #0
6000b73c:	f500 709f 	add.w	r0, r0, #318	; 0x13e
6000b740:	f000 f932 	bl	6000b9a8 <memset>
	memcpy(shell->ctx->temp_buff,
6000b744:	68a0      	ldr	r0, [r4, #8]
6000b746:	8f02      	ldrh	r2, [r0, #56]	; 0x38
6000b748:	f100 013e 	add.w	r1, r0, #62	; 0x3e
6000b74c:	f500 709f 	add.w	r0, r0, #318	; 0x13e
6000b750:	f000 f8ff 	bl	6000b952 <memcpy>
	z_shell_spaces_trim(shell->ctx->temp_buff);
6000b754:	68a0      	ldr	r0, [r4, #8]
6000b756:	f500 709f 	add.w	r0, r0, #318	; 0x13e
6000b75a:	f7ff fa4c 	bl	6000abf6 <z_shell_spaces_trim>
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
6000b75e:	68a3      	ldr	r3, [r4, #8]
6000b760:	f513 709f 	adds.w	r0, r3, #318	; 0x13e
6000b764:	d006      	beq.n	6000b774 <z_shell_wildcard_prepare+0x44>
6000b766:	f000 f89e 	bl	6000b8a6 <strlen>
6000b76a:	b283      	uxth	r3, r0
6000b76c:	68a2      	ldr	r2, [r4, #8]
6000b76e:	3301      	adds	r3, #1
6000b770:	8793      	strh	r3, [r2, #60]	; 0x3c
}
6000b772:	bd10      	pop	{r4, pc}
6000b774:	4603      	mov	r3, r0
6000b776:	e7f9      	b.n	6000b76c <z_shell_wildcard_prepare+0x3c>

6000b778 <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *shell)
{
6000b778:	b510      	push	{r4, lr}
6000b77a:	4604      	mov	r4, r0
	memcpy(shell->ctx->cmd_buff,
6000b77c:	6880      	ldr	r0, [r0, #8]
6000b77e:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
6000b780:	f500 719f 	add.w	r1, r0, #318	; 0x13e
6000b784:	303e      	adds	r0, #62	; 0x3e
6000b786:	f000 f8e4 	bl	6000b952 <memcpy>
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
6000b78a:	68a3      	ldr	r3, [r4, #8]
6000b78c:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
6000b78e:	871a      	strh	r2, [r3, #56]	; 0x38
}
6000b790:	bd10      	pop	{r4, pc}

6000b792 <get_time_cb>:
{
6000b792:	b508      	push	{r3, lr}
6000b794:	f7fa fc08 	bl	60005fa8 <sys_clock_cycle_get_32>
}
6000b798:	2100      	movs	r1, #0
6000b79a:	bd08      	pop	{r3, pc}

6000b79c <sys_trace_thread_info>:
{
6000b79c:	b530      	push	{r4, r5, lr}
6000b79e:	b08f      	sub	sp, #60	; 0x3c
6000b7a0:	4604      	mov	r4, r0
	set_thread_name(name, thread);
6000b7a2:	4601      	mov	r1, r0
6000b7a4:	ad06      	add	r5, sp, #24
6000b7a6:	4628      	mov	r0, r5
6000b7a8:	f7fa f9f8 	bl	60005b9c <set_thread_name>
	Info.Prio = thread->base.prio;
6000b7ac:	f994 300e 	ldrsb.w	r3, [r4, #14]
	SEGGER_SYSVIEW_SendTaskInfo(&Info);
6000b7b0:	a801      	add	r0, sp, #4
	Info.Prio = thread->base.prio;
6000b7b2:	9303      	str	r3, [sp, #12]
	Info.StackBase = thread->stack_info.size;
6000b7b4:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
6000b7b8:	9304      	str	r3, [sp, #16]
	Info.StackSize = thread->stack_info.start;
6000b7ba:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
	Info.sName = name;
6000b7be:	e9cd 4501 	strd	r4, r5, [sp, #4]
	Info.StackSize = thread->stack_info.start;
6000b7c2:	9305      	str	r3, [sp, #20]
	SEGGER_SYSVIEW_SendTaskInfo(&Info);
6000b7c4:	f7fc f88a 	bl	600078dc <SEGGER_SYSVIEW_SendTaskInfo>
}
6000b7c8:	b00f      	add	sp, #60	; 0x3c
6000b7ca:	bd30      	pop	{r4, r5, pc}

6000b7cc <sysview_init>:
{
	SEGGER_SYSVIEW_OnIdle();
}

static int sysview_init(const struct device *arg)
{
6000b7cc:	b508      	push	{r3, lr}
	ARG_UNUSED(arg);

	SEGGER_SYSVIEW_Conf();
6000b7ce:	f7fa fa39 	bl	60005c44 <SEGGER_SYSVIEW_Conf>
	if (IS_ENABLED(CONFIG_SEGGER_SYSTEMVIEW_BOOT_ENABLE)) {
		SEGGER_SYSVIEW_Start();
	}
	return 0;
}
6000b7d2:	2000      	movs	r0, #0
6000b7d4:	bd08      	pop	{r3, pc}

6000b7d6 <sysview_get_timestamp>:
6000b7d6:	f7fa bbe7 	b.w	60005fa8 <sys_clock_cycle_get_32>

6000b7da <sys_trace_k_thread_switched_out>:
	SEGGER_SYSVIEW_OnTaskStopExec();
6000b7da:	f7fc b9fb 	b.w	60007bd4 <SEGGER_SYSVIEW_OnTaskStopExec>

6000b7de <sys_trace_isr_enter>:
	SEGGER_SYSVIEW_RecordEnterISR();
6000b7de:	f7fc b907 	b.w	600079f0 <SEGGER_SYSVIEW_RecordEnterISR>

6000b7e2 <sys_trace_isr_exit>:
	SEGGER_SYSVIEW_RecordExitISR();
6000b7e2:	f7fc b929 	b.w	60007a38 <SEGGER_SYSVIEW_RecordExitISR>

6000b7e6 <sys_trace_idle>:
	SEGGER_SYSVIEW_OnIdle();
6000b7e6:	f7fc b98f 	b.w	60007b08 <SEGGER_SYSVIEW_OnIdle>

6000b7ea <mcux_ccm_on>:
}
6000b7ea:	2000      	movs	r0, #0
6000b7ec:	4770      	bx	lr

6000b7ee <mcux_ccm_init>:

static int mcux_ccm_init(const struct device *dev)
{
	return 0;
}
6000b7ee:	2000      	movs	r0, #0
6000b7f0:	4770      	bx	lr

6000b7f2 <mcux_ccm_off>:
6000b7f2:	2000      	movs	r0, #0
6000b7f4:	4770      	bx	lr

6000b7f6 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
6000b7f6:	2100      	movs	r1, #0
6000b7f8:	2001      	movs	r0, #1
6000b7fa:	f7fa bcd5 	b.w	600061a8 <z_arm_fatal_error>

6000b7fe <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
6000b7fe:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
6000b800:	6800      	ldr	r0, [r0, #0]
6000b802:	f7fa bcd1 	b.w	600061a8 <z_arm_fatal_error>

6000b806 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
6000b806:	b508      	push	{r3, lr}
	handler();
6000b808:	f7fa fd12 	bl	60006230 <z_SysNmiOnReset>
	z_arm_int_exit();
}
6000b80c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
6000b810:	f7fb b844 	b.w	6000689c <z_arm_exc_exit>

6000b814 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
6000b814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char c, sc;
	size_t len;

	c = *find++;
6000b818:	f891 8000 	ldrb.w	r8, [r1]
{
6000b81c:	4605      	mov	r5, r0
	if (c != 0) {
6000b81e:	f1b8 0f00 	cmp.w	r8, #0
6000b822:	d010      	beq.n	6000b846 <strstr+0x32>
	c = *find++;
6000b824:	1c4c      	adds	r4, r1, #1
		len = strlen(find);
6000b826:	4620      	mov	r0, r4
6000b828:	f000 f83d 	bl	6000b8a6 <strlen>
6000b82c:	4607      	mov	r7, r0
		do {
			do {
				sc = *s++;
6000b82e:	462e      	mov	r6, r5
6000b830:	f816 3b01 	ldrb.w	r3, [r6], #1
				if (sc == 0) {
6000b834:	b163      	cbz	r3, 6000b850 <strstr+0x3c>
					return NULL;
				}
			} while (sc != c);
6000b836:	4598      	cmp	r8, r3
6000b838:	d108      	bne.n	6000b84c <strstr+0x38>
		} while (strncmp(s, find, len) != 0);
6000b83a:	463a      	mov	r2, r7
6000b83c:	4621      	mov	r1, r4
6000b83e:	4630      	mov	r0, r6
6000b840:	f000 f84d 	bl	6000b8de <strncmp>
6000b844:	b910      	cbnz	r0, 6000b84c <strstr+0x38>
	s--;
	}
	return (char *)s;
}
6000b846:	4628      	mov	r0, r5
6000b848:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
6000b84c:	4635      	mov	r5, r6
6000b84e:	e7ee      	b.n	6000b82e <strstr+0x1a>
					return NULL;
6000b850:	461d      	mov	r5, r3
6000b852:	e7f8      	b.n	6000b846 <strstr+0x32>

6000b854 <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
6000b854:	3901      	subs	r1, #1
6000b856:	4603      	mov	r3, r0
6000b858:	f811 2f01 	ldrb.w	r2, [r1, #1]!
6000b85c:	b90a      	cbnz	r2, 6000b862 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
6000b85e:	701a      	strb	r2, [r3, #0]

	return dest;
}
6000b860:	4770      	bx	lr
		*d = *s;
6000b862:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
6000b866:	e7f7      	b.n	6000b858 <strcpy+0x4>

6000b868 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
6000b868:	b570      	push	{r4, r5, r6, lr}
6000b86a:	4605      	mov	r5, r0
6000b86c:	462b      	mov	r3, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
6000b86e:	b142      	cbz	r2, 6000b882 <strncpy+0x1a>
6000b870:	f811 4b01 	ldrb.w	r4, [r1], #1
		*d = *s;
		s++;
		d++;
		n--;
6000b874:	1e56      	subs	r6, r2, #1
	while ((n > 0) && *s != '\0') {
6000b876:	b92c      	cbnz	r4, 6000b884 <strncpy+0x1c>
6000b878:	442a      	add	r2, r5
	}

	while (n > 0) {
		*d = '\0';
6000b87a:	f803 4b01 	strb.w	r4, [r3], #1
	while (n > 0) {
6000b87e:	429a      	cmp	r2, r3
6000b880:	d1fb      	bne.n	6000b87a <strncpy+0x12>
		d++;
		n--;
	}

	return dest;
}
6000b882:	bd70      	pop	{r4, r5, r6, pc}
		n--;
6000b884:	4632      	mov	r2, r6
		*d = *s;
6000b886:	f805 4b01 	strb.w	r4, [r5], #1
		n--;
6000b88a:	e7ef      	b.n	6000b86c <strncpy+0x4>

6000b88c <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
6000b88c:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
6000b88e:	4603      	mov	r3, r0
6000b890:	781a      	ldrb	r2, [r3, #0]
6000b892:	4618      	mov	r0, r3
6000b894:	3301      	adds	r3, #1
6000b896:	428a      	cmp	r2, r1
6000b898:	d004      	beq.n	6000b8a4 <strchr+0x18>
6000b89a:	2a00      	cmp	r2, #0
6000b89c:	d1f8      	bne.n	6000b890 <strchr+0x4>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
6000b89e:	2900      	cmp	r1, #0
6000b8a0:	bf18      	it	ne
6000b8a2:	2000      	movne	r0, #0
}
6000b8a4:	4770      	bx	lr

6000b8a6 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
6000b8a6:	4603      	mov	r3, r0
	size_t n = 0;
6000b8a8:	2000      	movs	r0, #0

	while (*s != '\0') {
6000b8aa:	5c1a      	ldrb	r2, [r3, r0]
6000b8ac:	b902      	cbnz	r2, 6000b8b0 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
6000b8ae:	4770      	bx	lr
		n++;
6000b8b0:	3001      	adds	r0, #1
6000b8b2:	e7fa      	b.n	6000b8aa <strlen+0x4>

6000b8b4 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
6000b8b4:	4603      	mov	r3, r0
	size_t n = 0;
6000b8b6:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
6000b8b8:	5c1a      	ldrb	r2, [r3, r0]
6000b8ba:	b10a      	cbz	r2, 6000b8c0 <strnlen+0xc>
6000b8bc:	4288      	cmp	r0, r1
6000b8be:	d100      	bne.n	6000b8c2 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
6000b8c0:	4770      	bx	lr
		n++;
6000b8c2:	3001      	adds	r0, #1
6000b8c4:	e7f8      	b.n	6000b8b8 <strnlen+0x4>

6000b8c6 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
6000b8c6:	1e43      	subs	r3, r0, #1
6000b8c8:	3901      	subs	r1, #1
6000b8ca:	f813 2f01 	ldrb.w	r2, [r3, #1]!
6000b8ce:	f811 0f01 	ldrb.w	r0, [r1, #1]!
6000b8d2:	4282      	cmp	r2, r0
6000b8d4:	d101      	bne.n	6000b8da <strcmp+0x14>
6000b8d6:	2a00      	cmp	r2, #0
6000b8d8:	d1f7      	bne.n	6000b8ca <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
6000b8da:	1a10      	subs	r0, r2, r0
6000b8dc:	4770      	bx	lr

6000b8de <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
6000b8de:	3901      	subs	r1, #1
6000b8e0:	4402      	add	r2, r0
{
6000b8e2:	b510      	push	{r4, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
6000b8e4:	4282      	cmp	r2, r0
6000b8e6:	d009      	beq.n	6000b8fc <strncmp+0x1e>
6000b8e8:	7803      	ldrb	r3, [r0, #0]
6000b8ea:	f811 4f01 	ldrb.w	r4, [r1, #1]!
6000b8ee:	42a3      	cmp	r3, r4
6000b8f0:	d100      	bne.n	6000b8f4 <strncmp+0x16>
6000b8f2:	b90b      	cbnz	r3, 6000b8f8 <strncmp+0x1a>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
6000b8f4:	1b18      	subs	r0, r3, r4
6000b8f6:	e002      	b.n	6000b8fe <strncmp+0x20>
		s1++;
6000b8f8:	3001      	adds	r0, #1
		n--;
6000b8fa:	e7f3      	b.n	6000b8e4 <strncmp+0x6>
	return (n == 0) ? 0 : (*s1 - *s2);
6000b8fc:	2000      	movs	r0, #0
}
6000b8fe:	bd10      	pop	{r4, pc}

6000b900 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
6000b900:	4603      	mov	r3, r0
6000b902:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
6000b904:	b15a      	cbz	r2, 6000b91e <memcmp+0x1e>
6000b906:	3901      	subs	r1, #1
6000b908:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
6000b90a:	f813 0b01 	ldrb.w	r0, [r3], #1
6000b90e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
6000b912:	42a3      	cmp	r3, r4
6000b914:	d001      	beq.n	6000b91a <memcmp+0x1a>
6000b916:	4290      	cmp	r0, r2
6000b918:	d0f7      	beq.n	6000b90a <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
6000b91a:	1a80      	subs	r0, r0, r2
}
6000b91c:	bd10      	pop	{r4, pc}
		return 0;
6000b91e:	4610      	mov	r0, r2
6000b920:	e7fc      	b.n	6000b91c <memcmp+0x1c>

6000b922 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
6000b922:	1a43      	subs	r3, r0, r1
6000b924:	4293      	cmp	r3, r2
6000b926:	eb00 0302 	add.w	r3, r0, r2
{
6000b92a:	b510      	push	{r4, lr}
	if ((size_t) (dest - src) < n) {
6000b92c:	d308      	bcc.n	6000b940 <memmove+0x1e>
6000b92e:	3901      	subs	r1, #1
	char *dest = d;
6000b930:	4602      	mov	r2, r0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
6000b932:	429a      	cmp	r2, r3
6000b934:	d007      	beq.n	6000b946 <memmove+0x24>
			*dest = *src;
6000b936:	f811 4f01 	ldrb.w	r4, [r1, #1]!
6000b93a:	f802 4b01 	strb.w	r4, [r2], #1
			dest++;
			src++;
			n--;
6000b93e:	e7f8      	b.n	6000b932 <memmove+0x10>
6000b940:	440a      	add	r2, r1
		while (n > 0) {
6000b942:	428a      	cmp	r2, r1
6000b944:	d100      	bne.n	6000b948 <memmove+0x26>
		}
	}

	return d;
}
6000b946:	bd10      	pop	{r4, pc}
			dest[n] = src[n];
6000b948:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
6000b94c:	f803 4d01 	strb.w	r4, [r3, #-1]!
6000b950:	e7f7      	b.n	6000b942 <memmove+0x20>

6000b952 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
6000b952:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
6000b954:	ea81 0400 	eor.w	r4, r1, r0
6000b958:	4603      	mov	r3, r0
6000b95a:	07a5      	lsls	r5, r4, #30
6000b95c:	d00b      	beq.n	6000b976 <memcpy+0x24>
6000b95e:	3b01      	subs	r3, #1
6000b960:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
6000b962:	4291      	cmp	r1, r2
6000b964:	d11b      	bne.n	6000b99e <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
6000b966:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
6000b968:	2a00      	cmp	r2, #0
6000b96a:	d0fc      	beq.n	6000b966 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
6000b96c:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
6000b970:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
6000b972:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
6000b976:	079c      	lsls	r4, r3, #30
6000b978:	d1f6      	bne.n	6000b968 <memcpy+0x16>
6000b97a:	f022 0403 	bic.w	r4, r2, #3
6000b97e:	1f1d      	subs	r5, r3, #4
6000b980:	0896      	lsrs	r6, r2, #2
6000b982:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
6000b984:	42b9      	cmp	r1, r7
6000b986:	d105      	bne.n	6000b994 <memcpy+0x42>
6000b988:	f06f 0503 	mvn.w	r5, #3
		d_byte = (unsigned char *)d_word;
6000b98c:	4423      	add	r3, r4
6000b98e:	fb05 2206 	mla	r2, r5, r6, r2
6000b992:	e7e4      	b.n	6000b95e <memcpy+0xc>
			*(d_word++) = *(s_word++);
6000b994:	f851 cb04 	ldr.w	ip, [r1], #4
6000b998:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
6000b99c:	e7f2      	b.n	6000b984 <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
6000b99e:	f811 4b01 	ldrb.w	r4, [r1], #1
6000b9a2:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
6000b9a6:	e7dc      	b.n	6000b962 <memcpy+0x10>

6000b9a8 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
6000b9a8:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
6000b9aa:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
6000b9ac:	4604      	mov	r4, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
6000b9ae:	07a3      	lsls	r3, r4, #30
6000b9b0:	d111      	bne.n	6000b9d6 <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
6000b9b2:	ea41 2301 	orr.w	r3, r1, r1, lsl #8
	c_word |= c_word << 16;
6000b9b6:	0896      	lsrs	r6, r2, #2
6000b9b8:	ea43 4503 	orr.w	r5, r3, r3, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
6000b9bc:	f022 0303 	bic.w	r3, r2, #3
6000b9c0:	4423      	add	r3, r4
6000b9c2:	429c      	cmp	r4, r3
6000b9c4:	d10d      	bne.n	6000b9e2 <memset+0x3a>
6000b9c6:	f06f 0403 	mvn.w	r4, #3
6000b9ca:	fb04 2206 	mla	r2, r4, r6, r2
6000b9ce:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
6000b9d0:	4293      	cmp	r3, r2
6000b9d2:	d109      	bne.n	6000b9e8 <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
6000b9d4:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
6000b9d6:	2a00      	cmp	r2, #0
6000b9d8:	d0fc      	beq.n	6000b9d4 <memset+0x2c>
		n--;
6000b9da:	3a01      	subs	r2, #1
		*(d_byte++) = c_byte;
6000b9dc:	f804 1b01 	strb.w	r1, [r4], #1
		n--;
6000b9e0:	e7e5      	b.n	6000b9ae <memset+0x6>
		*(d_word++) = c_word;
6000b9e2:	f844 5b04 	str.w	r5, [r4], #4
		n -= sizeof(mem_word_t);
6000b9e6:	e7ec      	b.n	6000b9c2 <memset+0x1a>
		*(d_byte++) = c_byte;
6000b9e8:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
6000b9ec:	e7f0      	b.n	6000b9d0 <memset+0x28>

6000b9ee <_stdout_hook_default>:
}
6000b9ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
6000b9f2:	4770      	bx	lr

6000b9f4 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
6000b9f4:	684b      	ldr	r3, [r1, #4]
6000b9f6:	2b01      	cmp	r3, #1
6000b9f8:	dd07      	ble.n	6000ba0a <sprintf_out+0x16>
		*(p->ptr) = c;
6000b9fa:	680b      	ldr	r3, [r1, #0]
6000b9fc:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
6000b9fe:	680b      	ldr	r3, [r1, #0]
6000ba00:	3301      	adds	r3, #1
6000ba02:	600b      	str	r3, [r1, #0]
		p->len -= 1;
6000ba04:	684b      	ldr	r3, [r1, #4]
6000ba06:	3b01      	subs	r3, #1
6000ba08:	604b      	str	r3, [r1, #4]
}
6000ba0a:	2000      	movs	r0, #0
6000ba0c:	4770      	bx	lr

6000ba0e <mcux_igpio_configure>:

static int mcux_igpio_configure(const struct device *dev,
				gpio_pin_t pin, gpio_flags_t flags)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba0e:	6843      	ldr	r3, [r0, #4]
6000ba10:	6858      	ldr	r0, [r3, #4]

	if (((flags & GPIO_INPUT) != 0) && ((flags & GPIO_OUTPUT) != 0)) {
6000ba12:	f402 7340 	and.w	r3, r2, #768	; 0x300
6000ba16:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
6000ba1a:	d016      	beq.n	6000ba4a <mcux_igpio_configure+0x3c>

	if ((flags & GPIO_SINGLE_ENDED) != 0) {
		return -ENOTSUP;
	}

	if (((flags & GPIO_PULL_UP) != 0) || ((flags & GPIO_PULL_DOWN) != 0)) {
6000ba1c:	f012 0f32 	tst.w	r2, #50	; 0x32
6000ba20:	d113      	bne.n	6000ba4a <mcux_igpio_configure+0x3c>
		return -ENOTSUP;
	}

	if (flags & GPIO_OUTPUT_INIT_HIGH) {
		base->DR_SET = BIT(pin);
6000ba22:	2301      	movs	r3, #1
6000ba24:	fa03 f101 	lsl.w	r1, r3, r1
	if (flags & GPIO_OUTPUT_INIT_HIGH) {
6000ba28:	0513      	lsls	r3, r2, #20
6000ba2a:	d501      	bpl.n	6000ba30 <mcux_igpio_configure+0x22>
		base->DR_SET = BIT(pin);
6000ba2c:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	}

	if (flags & GPIO_OUTPUT_INIT_LOW) {
6000ba30:	0553      	lsls	r3, r2, #21
6000ba32:	d501      	bpl.n	6000ba38 <mcux_igpio_configure+0x2a>
		base->DR_CLEAR = BIT(pin);
6000ba34:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
	}

	WRITE_BIT(base->GDIR, pin, flags & GPIO_OUTPUT);
6000ba38:	6843      	ldr	r3, [r0, #4]
6000ba3a:	0592      	lsls	r2, r2, #22
6000ba3c:	bf4c      	ite	mi
6000ba3e:	4319      	orrmi	r1, r3
6000ba40:	ea23 0101 	bicpl.w	r1, r3, r1
6000ba44:	6041      	str	r1, [r0, #4]

	return 0;
6000ba46:	2000      	movs	r0, #0
6000ba48:	4770      	bx	lr
		return -ENOTSUP;
6000ba4a:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
6000ba4e:	4770      	bx	lr

6000ba50 <mcux_igpio_port_get_raw>:

static int mcux_igpio_port_get_raw(const struct device *dev, uint32_t *value)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba50:	6843      	ldr	r3, [r0, #4]

	*value = base->DR;

	return 0;
}
6000ba52:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ba54:	685b      	ldr	r3, [r3, #4]
	*value = base->DR;
6000ba56:	681b      	ldr	r3, [r3, #0]
6000ba58:	600b      	str	r3, [r1, #0]
}
6000ba5a:	4770      	bx	lr

6000ba5c <mcux_igpio_port_set_masked_raw>:
static int mcux_igpio_port_set_masked_raw(const struct device *dev,
					  uint32_t mask,
					  uint32_t value)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba5c:	6843      	ldr	r3, [r0, #4]
6000ba5e:	685b      	ldr	r3, [r3, #4]

	base->DR = (base->DR & ~mask) | (mask & value);
6000ba60:	6818      	ldr	r0, [r3, #0]
6000ba62:	4042      	eors	r2, r0
6000ba64:	400a      	ands	r2, r1
6000ba66:	4042      	eors	r2, r0

	return 0;
}
6000ba68:	2000      	movs	r0, #0
	base->DR = (base->DR & ~mask) | (mask & value);
6000ba6a:	601a      	str	r2, [r3, #0]
}
6000ba6c:	4770      	bx	lr

6000ba6e <mcux_igpio_port_set_bits_raw>:

static int mcux_igpio_port_set_bits_raw(const struct device *dev,
					uint32_t mask)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba6e:	6843      	ldr	r3, [r0, #4]

	base->DR_SET = mask;

	return 0;
}
6000ba70:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ba72:	685b      	ldr	r3, [r3, #4]
	base->DR_SET = mask;
6000ba74:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
}
6000ba78:	4770      	bx	lr

6000ba7a <mcux_igpio_port_clear_bits_raw>:

static int mcux_igpio_port_clear_bits_raw(const struct device *dev,
					  uint32_t mask)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba7a:	6843      	ldr	r3, [r0, #4]

	base->DR_CLEAR = mask;

	return 0;
}
6000ba7c:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ba7e:	685b      	ldr	r3, [r3, #4]
	base->DR_CLEAR = mask;
6000ba80:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
}
6000ba84:	4770      	bx	lr

6000ba86 <mcux_igpio_port_toggle_bits>:

static int mcux_igpio_port_toggle_bits(const struct device *dev,
				       uint32_t mask)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba86:	6843      	ldr	r3, [r0, #4]

	base->DR_TOGGLE = mask;

	return 0;
}
6000ba88:	2000      	movs	r0, #0
	GPIO_Type *base = config->base;
6000ba8a:	685b      	ldr	r3, [r3, #4]
	base->DR_TOGGLE = mask;
6000ba8c:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
}
6000ba90:	4770      	bx	lr

6000ba92 <mcux_igpio_pin_interrupt_configure>:
					      gpio_pin_t pin,
					      enum gpio_int_mode mode,
					      enum gpio_int_trig trig)
{
	const struct mcux_igpio_config *config = dev->config;
	GPIO_Type *base = config->base;
6000ba92:	6840      	ldr	r0, [r0, #4]
	unsigned int key;
	uint8_t icr;
	int shift;

	if (mode == GPIO_INT_MODE_DISABLED) {
6000ba94:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	GPIO_Type *base = config->base;
6000ba98:	6840      	ldr	r0, [r0, #4]
{
6000ba9a:	b570      	push	{r4, r5, r6, lr}
	if (mode == GPIO_INT_MODE_DISABLED) {
6000ba9c:	d114      	bne.n	6000bac8 <mcux_igpio_pin_interrupt_configure+0x36>
	__asm__ volatile(
6000ba9e:	f04f 0310 	mov.w	r3, #16
6000baa2:	f3ef 8411 	mrs	r4, BASEPRI
6000baa6:	f383 8811 	msr	BASEPRI, r3
6000baaa:	f3bf 8f6f 	isb	sy
		key = irq_lock();

		WRITE_BIT(base->IMR, pin, 0);
6000baae:	2201      	movs	r2, #1
6000bab0:	6943      	ldr	r3, [r0, #20]
6000bab2:	fa02 f101 	lsl.w	r1, r2, r1
6000bab6:	ea23 0101 	bic.w	r1, r3, r1

	key = irq_lock();

	WRITE_BIT(base->EDGE_SEL, pin, trig == GPIO_INT_TRIG_BOTH);
	WRITE_BIT(base->ISR, pin, 1);
	WRITE_BIT(base->IMR, pin, 1);
6000baba:	6141      	str	r1, [r0, #20]
	__asm__ volatile(
6000babc:	f384 8811 	msr	BASEPRI, r4
6000bac0:	f3bf 8f6f 	isb	sy

	irq_unlock(key);

	return 0;
6000bac4:	2000      	movs	r0, #0
}
6000bac6:	bd70      	pop	{r4, r5, r6, pc}
	if ((mode == GPIO_INT_MODE_EDGE) && (trig == GPIO_INT_TRIG_LOW)) {
6000bac8:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
6000bacc:	d12a      	bne.n	6000bb24 <mcux_igpio_pin_interrupt_configure+0x92>
6000bace:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
6000bad2:	d02f      	beq.n	6000bb34 <mcux_igpio_pin_interrupt_configure+0xa2>
		icr = 0;
6000bad4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
6000bad8:	bf0c      	ite	eq
6000bada:	2202      	moveq	r2, #2
6000badc:	2200      	movne	r2, #0
	if (pin < 16) {
6000bade:	290f      	cmp	r1, #15
6000bae0:	d82c      	bhi.n	6000bb3c <mcux_igpio_pin_interrupt_configure+0xaa>
		shift = 2 * pin;
6000bae2:	004d      	lsls	r5, r1, #1
		base->ICR1 = (base->ICR1 & ~(3 << shift)) | (icr << shift);
6000bae4:	2603      	movs	r6, #3
6000bae6:	68c4      	ldr	r4, [r0, #12]
6000bae8:	40ae      	lsls	r6, r5
6000baea:	40aa      	lsls	r2, r5
6000baec:	ea24 0406 	bic.w	r4, r4, r6
6000baf0:	4322      	orrs	r2, r4
6000baf2:	60c2      	str	r2, [r0, #12]
	__asm__ volatile(
6000baf4:	f04f 0210 	mov.w	r2, #16
6000baf8:	f3ef 8411 	mrs	r4, BASEPRI
6000bafc:	f382 8811 	msr	BASEPRI, r2
6000bb00:	f3bf 8f6f 	isb	sy
		WRITE_BIT(base->IMR, pin, 0);
6000bb04:	2201      	movs	r2, #1
	WRITE_BIT(base->EDGE_SEL, pin, trig == GPIO_INT_TRIG_BOTH);
6000bb06:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
6000bb0a:	69c3      	ldr	r3, [r0, #28]
		WRITE_BIT(base->IMR, pin, 0);
6000bb0c:	fa02 f101 	lsl.w	r1, r2, r1
	WRITE_BIT(base->EDGE_SEL, pin, trig == GPIO_INT_TRIG_BOTH);
6000bb10:	bf0c      	ite	eq
6000bb12:	430b      	orreq	r3, r1
6000bb14:	438b      	bicne	r3, r1
6000bb16:	61c3      	str	r3, [r0, #28]
	WRITE_BIT(base->ISR, pin, 1);
6000bb18:	6983      	ldr	r3, [r0, #24]
6000bb1a:	430b      	orrs	r3, r1
6000bb1c:	6183      	str	r3, [r0, #24]
	WRITE_BIT(base->IMR, pin, 1);
6000bb1e:	6943      	ldr	r3, [r0, #20]
6000bb20:	4319      	orrs	r1, r3
6000bb22:	e7ca      	b.n	6000baba <mcux_igpio_pin_interrupt_configure+0x28>
	} else if ((mode == GPIO_INT_MODE_LEVEL) &&
6000bb24:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
6000bb28:	d106      	bne.n	6000bb38 <mcux_igpio_pin_interrupt_configure+0xa6>
		icr = 0;
6000bb2a:	f5a3 2480 	sub.w	r4, r3, #262144	; 0x40000
6000bb2e:	4262      	negs	r2, r4
6000bb30:	4162      	adcs	r2, r4
6000bb32:	e7d4      	b.n	6000bade <mcux_igpio_pin_interrupt_configure+0x4c>
		icr = 3;
6000bb34:	2203      	movs	r2, #3
6000bb36:	e7d2      	b.n	6000bade <mcux_igpio_pin_interrupt_configure+0x4c>
		icr = 0;
6000bb38:	2200      	movs	r2, #0
6000bb3a:	e7d0      	b.n	6000bade <mcux_igpio_pin_interrupt_configure+0x4c>
	} else if (pin < 32) {
6000bb3c:	291f      	cmp	r1, #31
6000bb3e:	d80b      	bhi.n	6000bb58 <mcux_igpio_pin_interrupt_configure+0xc6>
		shift = 2 * (pin - 16);
6000bb40:	f1a1 0510 	sub.w	r5, r1, #16
		base->ICR2 = (base->ICR2 & ~(3 << shift)) | (icr << shift);
6000bb44:	2603      	movs	r6, #3
6000bb46:	6904      	ldr	r4, [r0, #16]
		shift = 2 * (pin - 16);
6000bb48:	006d      	lsls	r5, r5, #1
		base->ICR2 = (base->ICR2 & ~(3 << shift)) | (icr << shift);
6000bb4a:	40ae      	lsls	r6, r5
6000bb4c:	40aa      	lsls	r2, r5
6000bb4e:	ea24 0406 	bic.w	r4, r4, r6
6000bb52:	4322      	orrs	r2, r4
6000bb54:	6102      	str	r2, [r0, #16]
6000bb56:	e7cd      	b.n	6000baf4 <mcux_igpio_pin_interrupt_configure+0x62>
		return -EINVAL;
6000bb58:	f06f 0015 	mvn.w	r0, #21
6000bb5c:	e7b3      	b.n	6000bac6 <mcux_igpio_pin_interrupt_configure+0x34>

6000bb5e <mcux_igpio_manage_callback>:

static int mcux_igpio_manage_callback(const struct device *dev,
				      struct gpio_callback *callback,
				      bool set)
{
	struct mcux_igpio_data *data = dev->data;
6000bb5e:	6903      	ldr	r3, [r0, #16]
	return list->head;
6000bb60:	6858      	ldr	r0, [r3, #4]
{
6000bb62:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
6000bb64:	b158      	cbz	r0, 6000bb7e <mcux_igpio_manage_callback+0x20>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
6000bb66:	2400      	movs	r4, #0
6000bb68:	4281      	cmp	r1, r0
6000bb6a:	d112      	bne.n	6000bb92 <mcux_igpio_manage_callback+0x34>
	return node->next;
6000bb6c:	6808      	ldr	r0, [r1, #0]
	return list->tail;
6000bb6e:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
6000bb70:	b954      	cbnz	r4, 6000bb88 <mcux_igpio_manage_callback+0x2a>
6000bb72:	428d      	cmp	r5, r1
	list->head = node;
6000bb74:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
6000bb76:	d100      	bne.n	6000bb7a <mcux_igpio_manage_callback+0x1c>
	list->tail = node;
6000bb78:	6098      	str	r0, [r3, #8]
	parent->next = child;
6000bb7a:	2000      	movs	r0, #0
6000bb7c:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
6000bb7e:	b96a      	cbnz	r2, 6000bb9c <mcux_igpio_manage_callback+0x3e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
6000bb80:	2000      	movs	r0, #0

	return gpio_manage_callback(&data->callbacks, callback, set);
}
6000bb82:	bd30      	pop	{r4, r5, pc}
6000bb84:	4628      	mov	r0, r5
6000bb86:	e7ef      	b.n	6000bb68 <mcux_igpio_manage_callback+0xa>
Z_GENLIST_REMOVE(slist, snode)
6000bb88:	428d      	cmp	r5, r1
	parent->next = child;
6000bb8a:	6020      	str	r0, [r4, #0]
	list->tail = node;
6000bb8c:	bf08      	it	eq
6000bb8e:	609c      	streq	r4, [r3, #8]
}
6000bb90:	e7f3      	b.n	6000bb7a <mcux_igpio_manage_callback+0x1c>
	return node->next;
6000bb92:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
6000bb94:	4604      	mov	r4, r0
6000bb96:	2d00      	cmp	r5, #0
6000bb98:	d1f4      	bne.n	6000bb84 <mcux_igpio_manage_callback+0x26>
			if (!set) {
6000bb9a:	b13a      	cbz	r2, 6000bbac <mcux_igpio_manage_callback+0x4e>
	parent->next = child;
6000bb9c:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
6000bb9e:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
6000bba0:	600a      	str	r2, [r1, #0]
	list->head = node;
6000bba2:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
6000bba4:	2800      	cmp	r0, #0
6000bba6:	d1eb      	bne.n	6000bb80 <mcux_igpio_manage_callback+0x22>
	list->tail = node;
6000bba8:	6099      	str	r1, [r3, #8]
}
6000bbaa:	e7ea      	b.n	6000bb82 <mcux_igpio_manage_callback+0x24>
				return -EINVAL;
6000bbac:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&data->callbacks, callback, set);
6000bbb0:	e7e7      	b.n	6000bb82 <mcux_igpio_manage_callback+0x24>

6000bbb2 <mcux_igpio_0_init>:
			   (MCUX_IGPIO_IRQ_INIT(n, 1);))		\
									\
		return 0;						\
	}

DT_INST_FOREACH_STATUS_OKAY(MCUX_IGPIO_INIT)
6000bbb2:	2200      	movs	r2, #0
6000bbb4:	2050      	movs	r0, #80	; 0x50
6000bbb6:	b508      	push	{r3, lr}
6000bbb8:	4611      	mov	r1, r2
6000bbba:	f7fa fa7d 	bl	600060b8 <z_arm_irq_priority_set>
6000bbbe:	2050      	movs	r0, #80	; 0x50
6000bbc0:	f7fa fa6a 	bl	60006098 <arch_irq_enable>
6000bbc4:	2200      	movs	r2, #0
6000bbc6:	2051      	movs	r0, #81	; 0x51
6000bbc8:	4611      	mov	r1, r2
6000bbca:	f7fa fa75 	bl	600060b8 <z_arm_irq_priority_set>
6000bbce:	2051      	movs	r0, #81	; 0x51
6000bbd0:	f7fa fa62 	bl	60006098 <arch_irq_enable>
6000bbd4:	2000      	movs	r0, #0
6000bbd6:	bd08      	pop	{r3, pc}

6000bbd8 <mcux_igpio_1_init>:
6000bbd8:	2200      	movs	r2, #0
6000bbda:	2052      	movs	r0, #82	; 0x52
6000bbdc:	b508      	push	{r3, lr}
6000bbde:	4611      	mov	r1, r2
6000bbe0:	f7fa fa6a 	bl	600060b8 <z_arm_irq_priority_set>
6000bbe4:	2052      	movs	r0, #82	; 0x52
6000bbe6:	f7fa fa57 	bl	60006098 <arch_irq_enable>
6000bbea:	2200      	movs	r2, #0
6000bbec:	2053      	movs	r0, #83	; 0x53
6000bbee:	4611      	mov	r1, r2
6000bbf0:	f7fa fa62 	bl	600060b8 <z_arm_irq_priority_set>
6000bbf4:	2053      	movs	r0, #83	; 0x53
6000bbf6:	f7fa fa4f 	bl	60006098 <arch_irq_enable>
6000bbfa:	2000      	movs	r0, #0
6000bbfc:	bd08      	pop	{r3, pc}

6000bbfe <mcux_igpio_2_init>:
6000bbfe:	2200      	movs	r2, #0
6000bc00:	2054      	movs	r0, #84	; 0x54
6000bc02:	b508      	push	{r3, lr}
6000bc04:	4611      	mov	r1, r2
6000bc06:	f7fa fa57 	bl	600060b8 <z_arm_irq_priority_set>
6000bc0a:	2054      	movs	r0, #84	; 0x54
6000bc0c:	f7fa fa44 	bl	60006098 <arch_irq_enable>
6000bc10:	2200      	movs	r2, #0
6000bc12:	2055      	movs	r0, #85	; 0x55
6000bc14:	4611      	mov	r1, r2
6000bc16:	f7fa fa4f 	bl	600060b8 <z_arm_irq_priority_set>
6000bc1a:	2055      	movs	r0, #85	; 0x55
6000bc1c:	f7fa fa3c 	bl	60006098 <arch_irq_enable>
6000bc20:	2000      	movs	r0, #0
6000bc22:	bd08      	pop	{r3, pc}

6000bc24 <mcux_igpio_3_init>:
6000bc24:	2200      	movs	r2, #0
6000bc26:	2056      	movs	r0, #86	; 0x56
6000bc28:	b508      	push	{r3, lr}
6000bc2a:	4611      	mov	r1, r2
6000bc2c:	f7fa fa44 	bl	600060b8 <z_arm_irq_priority_set>
6000bc30:	2056      	movs	r0, #86	; 0x56
6000bc32:	f7fa fa31 	bl	60006098 <arch_irq_enable>
6000bc36:	2200      	movs	r2, #0
6000bc38:	2057      	movs	r0, #87	; 0x57
6000bc3a:	4611      	mov	r1, r2
6000bc3c:	f7fa fa3c 	bl	600060b8 <z_arm_irq_priority_set>
6000bc40:	2057      	movs	r0, #87	; 0x57
6000bc42:	f7fa fa29 	bl	60006098 <arch_irq_enable>
6000bc46:	2000      	movs	r0, #0
6000bc48:	bd08      	pop	{r3, pc}

6000bc4a <mcux_igpio_4_init>:
6000bc4a:	2200      	movs	r2, #0
6000bc4c:	2058      	movs	r0, #88	; 0x58
6000bc4e:	b508      	push	{r3, lr}
6000bc50:	4611      	mov	r1, r2
6000bc52:	f7fa fa31 	bl	600060b8 <z_arm_irq_priority_set>
6000bc56:	2058      	movs	r0, #88	; 0x58
6000bc58:	f7fa fa1e 	bl	60006098 <arch_irq_enable>
6000bc5c:	2200      	movs	r2, #0
6000bc5e:	2059      	movs	r0, #89	; 0x59
6000bc60:	4611      	mov	r1, r2
6000bc62:	f7fa fa29 	bl	600060b8 <z_arm_irq_priority_set>
6000bc66:	2059      	movs	r0, #89	; 0x59
6000bc68:	f7fa fa16 	bl	60006098 <arch_irq_enable>
6000bc6c:	2000      	movs	r0, #0
6000bc6e:	bd08      	pop	{r3, pc}

6000bc70 <mcux_igpio_port_isr>:
	GPIO_Type *base = config->base;
6000bc70:	6843      	ldr	r3, [r0, #4]
	struct mcux_igpio_data *data = dev->data;
6000bc72:	6902      	ldr	r2, [r0, #16]
	GPIO_Type *base = config->base;
6000bc74:	685b      	ldr	r3, [r3, #4]
	int_flags = base->ISR;
6000bc76:	6851      	ldr	r1, [r2, #4]
{
6000bc78:	b570      	push	{r4, r5, r6, lr}
	int_flags = base->ISR;
6000bc7a:	699e      	ldr	r6, [r3, #24]
{
6000bc7c:	4604      	mov	r4, r0
	base->ISR = int_flags;
6000bc7e:	619e      	str	r6, [r3, #24]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
6000bc80:	b151      	cbz	r1, 6000bc98 <mcux_igpio_port_isr+0x28>
	return node->next;
6000bc82:	680d      	ldr	r5, [r1, #0]
		if (cb->pin_mask & pins) {
6000bc84:	688a      	ldr	r2, [r1, #8]
6000bc86:	4032      	ands	r2, r6
6000bc88:	d002      	beq.n	6000bc90 <mcux_igpio_port_isr+0x20>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
6000bc8a:	684b      	ldr	r3, [r1, #4]
6000bc8c:	4620      	mov	r0, r4
6000bc8e:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
6000bc90:	b115      	cbz	r5, 6000bc98 <mcux_igpio_port_isr+0x28>
6000bc92:	4629      	mov	r1, r5
6000bc94:	682d      	ldr	r5, [r5, #0]
6000bc96:	e7f5      	b.n	6000bc84 <mcux_igpio_port_isr+0x14>
}
6000bc98:	bd70      	pop	{r4, r5, r6, pc}

6000bc9a <LPUART_ReadByte>:
 * @return Data read from data register.
 */
static inline uint8_t LPUART_ReadByte(LPUART_Type *base)
{
#if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    uint32_t ctrl = base->CTRL;
6000bc9a:	6983      	ldr	r3, [r0, #24]
                            (((ctrl & LPUART_CTRL_M7_MASK) == 0U) && ((ctrl & LPUART_CTRL_M_MASK) == 0U) &&
                             ((ctrl & LPUART_CTRL_PE_MASK) != 0U)));

    if (isSevenDataBits)
    {
        result = (uint8_t)(base->DATA & 0x7FU);
6000bc9c:	69c0      	ldr	r0, [r0, #28]
    bool isSevenDataBits = (((ctrl & LPUART_CTRL_M7_MASK) != 0U) ||
6000bc9e:	051a      	lsls	r2, r3, #20
6000bca0:	d407      	bmi.n	6000bcb2 <LPUART_ReadByte+0x18>
                            (((ctrl & LPUART_CTRL_M7_MASK) == 0U) && ((ctrl & LPUART_CTRL_M_MASK) == 0U) &&
6000bca2:	f423 63fd 	bic.w	r3, r3, #2024	; 0x7e8
6000bca6:	f023 0305 	bic.w	r3, r3, #5
6000bcaa:	051b      	lsls	r3, r3, #20
6000bcac:	0d1b      	lsrs	r3, r3, #20
    if (isSevenDataBits)
6000bcae:	2b02      	cmp	r3, #2
6000bcb0:	d102      	bne.n	6000bcb8 <LPUART_ReadByte+0x1e>
        result = (uint8_t)(base->DATA & 0x7FU);
6000bcb2:	f000 007f 	and.w	r0, r0, #127	; 0x7f
6000bcb6:	4770      	bx	lr
    }
    else
    {
        result = (uint8_t)base->DATA;
6000bcb8:	b2c0      	uxtb	r0, r0

    return result;
#else
    return (uint8_t)(base->DATA);
#endif
}
6000bcba:	4770      	bx	lr

6000bcbc <mcux_lpuart_irq_update>:
}
6000bcbc:	2001      	movs	r0, #1
6000bcbe:	4770      	bx	lr

6000bcc0 <mcux_lpuart_irq_callback_set>:
	struct mcux_lpuart_data *data = dev->data;
6000bcc0:	6903      	ldr	r3, [r0, #16]
	data->cb_data = cb_data;
6000bcc2:	e9c3 1200 	strd	r1, r2, [r3]
}
6000bcc6:	4770      	bx	lr

6000bcc8 <mcux_lpuart_isr>:
	struct mcux_lpuart_data *data = dev->data;
6000bcc8:	6902      	ldr	r2, [r0, #16]
	if (data->callback) {
6000bcca:	6813      	ldr	r3, [r2, #0]
6000bccc:	b10b      	cbz	r3, 6000bcd2 <mcux_lpuart_isr+0xa>
		data->callback(dev, data->cb_data);
6000bcce:	6851      	ldr	r1, [r2, #4]
6000bcd0:	4718      	bx	r3
}
6000bcd2:	4770      	bx	lr

6000bcd4 <mcux_lpuart_config_get>:
	*cfg = data->uart_config;
6000bcd4:	6902      	ldr	r2, [r0, #16]
{
6000bcd6:	460b      	mov	r3, r1
	*cfg = data->uart_config;
6000bcd8:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
6000bcdc:	e883 0003 	stmia.w	r3, {r0, r1}
}
6000bce0:	2000      	movs	r0, #0
6000bce2:	4770      	bx	lr

6000bce4 <mcux_lpuart_irq_err_disable>:
	LPUART_DisableInterrupts(config->base, mask);
6000bce4:	6843      	ldr	r3, [r0, #4]
6000bce6:	f04f 61e0 	mov.w	r1, #117440512	; 0x7000000
6000bcea:	6818      	ldr	r0, [r3, #0]
6000bcec:	f000 b958 	b.w	6000bfa0 <LPUART_DisableInterrupts>

6000bcf0 <mcux_lpuart_irq_rx_disable>:
	LPUART_DisableInterrupts(config->base, mask);
6000bcf0:	6843      	ldr	r3, [r0, #4]
6000bcf2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
6000bcf6:	6818      	ldr	r0, [r3, #0]
6000bcf8:	f000 b952 	b.w	6000bfa0 <LPUART_DisableInterrupts>

6000bcfc <mcux_lpuart_irq_tx_disable>:
	LPUART_DisableInterrupts(config->base, mask);
6000bcfc:	6843      	ldr	r3, [r0, #4]
6000bcfe:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
6000bd02:	6818      	ldr	r0, [r3, #0]
6000bd04:	f000 b94c 	b.w	6000bfa0 <LPUART_DisableInterrupts>

6000bd08 <mcux_lpuart_irq_err_enable>:
	LPUART_EnableInterrupts(config->base, mask);
6000bd08:	6843      	ldr	r3, [r0, #4]
6000bd0a:	f04f 61e0 	mov.w	r1, #117440512	; 0x7000000
6000bd0e:	6818      	ldr	r0, [r3, #0]
6000bd10:	f000 b932 	b.w	6000bf78 <LPUART_EnableInterrupts>

6000bd14 <mcux_lpuart_irq_rx_enable>:
	LPUART_EnableInterrupts(config->base, mask);
6000bd14:	6843      	ldr	r3, [r0, #4]
6000bd16:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
6000bd1a:	6818      	ldr	r0, [r3, #0]
6000bd1c:	f000 b92c 	b.w	6000bf78 <LPUART_EnableInterrupts>

6000bd20 <mcux_lpuart_irq_tx_enable>:
	LPUART_EnableInterrupts(config->base, mask);
6000bd20:	6843      	ldr	r3, [r0, #4]
6000bd22:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
6000bd26:	6818      	ldr	r0, [r3, #0]
6000bd28:	f000 b926 	b.w	6000bf78 <LPUART_EnableInterrupts>

6000bd2c <mcux_lpuart_irq_rx_full>:
{
6000bd2c:	b508      	push	{r3, lr}
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000bd2e:	6843      	ldr	r3, [r0, #4]
6000bd30:	6818      	ldr	r0, [r3, #0]
6000bd32:	f000 f95f 	bl	6000bff4 <LPUART_GetStatusFlags>
}
6000bd36:	f3c0 5040 	ubfx	r0, r0, #21, #1
6000bd3a:	bd08      	pop	{r3, pc}

6000bd3c <mcux_lpuart_irq_tx_complete>:
{
6000bd3c:	b508      	push	{r3, lr}
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000bd3e:	6843      	ldr	r3, [r0, #4]
6000bd40:	6818      	ldr	r0, [r3, #0]
6000bd42:	f000 f957 	bl	6000bff4 <LPUART_GetStatusFlags>
}
6000bd46:	f3c0 5080 	ubfx	r0, r0, #22, #1
6000bd4a:	bd08      	pop	{r3, pc}

6000bd4c <mcux_lpuart_irq_tx_ready>:
{
6000bd4c:	b538      	push	{r3, r4, r5, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000bd4e:	6845      	ldr	r5, [r0, #4]
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000bd50:	6828      	ldr	r0, [r5, #0]
6000bd52:	f000 f94f 	bl	6000bff4 <LPUART_GetStatusFlags>
6000bd56:	4604      	mov	r4, r0
	return (LPUART_GetEnabledInterrupts(config->base) & mask)
6000bd58:	6828      	ldr	r0, [r5, #0]
6000bd5a:	f000 f938 	bl	6000bfce <LPUART_GetEnabledInterrupts>
		&& (flags & kLPUART_TxDataRegEmptyFlag);
6000bd5e:	f410 0000 	ands.w	r0, r0, #8388608	; 0x800000
6000bd62:	bf18      	it	ne
6000bd64:	f3c4 50c0 	ubfxne	r0, r4, #23, #1
}
6000bd68:	bd38      	pop	{r3, r4, r5, pc}

6000bd6a <mcux_lpuart_fifo_read>:
{
6000bd6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000bd6e:	460e      	mov	r6, r1
6000bd70:	4617      	mov	r7, r2
	const struct mcux_lpuart_config *config = dev->config;
6000bd72:	f8d0 8004 	ldr.w	r8, [r0, #4]
	while ((len - num_rx > 0) &&
6000bd76:	2400      	movs	r4, #0
6000bd78:	b2e5      	uxtb	r5, r4
6000bd7a:	1b7b      	subs	r3, r7, r5
6000bd7c:	2b00      	cmp	r3, #0
6000bd7e:	dd06      	ble.n	6000bd8e <mcux_lpuart_fifo_read+0x24>
	       (LPUART_GetStatusFlags(config->base)
6000bd80:	f8d8 0000 	ldr.w	r0, [r8]
	while ((len - num_rx > 0) &&
6000bd84:	3401      	adds	r4, #1
	       (LPUART_GetStatusFlags(config->base)
6000bd86:	f000 f935 	bl	6000bff4 <LPUART_GetStatusFlags>
	while ((len - num_rx > 0) &&
6000bd8a:	0283      	lsls	r3, r0, #10
6000bd8c:	d402      	bmi.n	6000bd94 <mcux_lpuart_fifo_read+0x2a>
}
6000bd8e:	4628      	mov	r0, r5
6000bd90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx_data[num_rx++] = LPUART_ReadByte(config->base);
6000bd94:	f8d8 0000 	ldr.w	r0, [r8]
6000bd98:	f7ff ff7f 	bl	6000bc9a <LPUART_ReadByte>
6000bd9c:	5570      	strb	r0, [r6, r5]
6000bd9e:	e7eb      	b.n	6000bd78 <mcux_lpuart_fifo_read+0xe>

6000bda0 <mcux_lpuart_fifo_fill>:
{
6000bda0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000bda4:	460e      	mov	r6, r1
6000bda6:	4617      	mov	r7, r2
	const struct mcux_lpuart_config *config = dev->config;
6000bda8:	f8d0 8004 	ldr.w	r8, [r0, #4]
	while ((len - num_tx > 0) &&
6000bdac:	2400      	movs	r4, #0
6000bdae:	b2e5      	uxtb	r5, r4
6000bdb0:	1b7b      	subs	r3, r7, r5
6000bdb2:	2b00      	cmp	r3, #0
6000bdb4:	dd06      	ble.n	6000bdc4 <mcux_lpuart_fifo_fill+0x24>
	       (LPUART_GetStatusFlags(config->base)
6000bdb6:	f8d8 0000 	ldr.w	r0, [r8]
	while ((len - num_tx > 0) &&
6000bdba:	3401      	adds	r4, #1
	       (LPUART_GetStatusFlags(config->base)
6000bdbc:	f000 f91a 	bl	6000bff4 <LPUART_GetStatusFlags>
	while ((len - num_tx > 0) &&
6000bdc0:	0203      	lsls	r3, r0, #8
6000bdc2:	d402      	bmi.n	6000bdca <mcux_lpuart_fifo_fill+0x2a>
}
6000bdc4:	4628      	mov	r0, r5
6000bdc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LPUART_WriteByte(config->base, tx_data[num_tx++]);
6000bdca:	f8d8 3000 	ldr.w	r3, [r8]
    base->DATA = data;
6000bdce:	5d72      	ldrb	r2, [r6, r5]
6000bdd0:	61da      	str	r2, [r3, #28]
}
6000bdd2:	e7ec      	b.n	6000bdae <mcux_lpuart_fifo_fill+0xe>

6000bdd4 <mcux_lpuart_poll_out>:
{
6000bdd4:	b538      	push	{r3, r4, r5, lr}
6000bdd6:	460c      	mov	r4, r1
	const struct mcux_lpuart_config *config = dev->config;
6000bdd8:	6845      	ldr	r5, [r0, #4]
	while (!(LPUART_GetStatusFlags(config->base)
6000bdda:	6828      	ldr	r0, [r5, #0]
6000bddc:	f000 f90a 	bl	6000bff4 <LPUART_GetStatusFlags>
6000bde0:	0203      	lsls	r3, r0, #8
6000bde2:	d5fa      	bpl.n	6000bdda <mcux_lpuart_poll_out+0x6>
	LPUART_WriteByte(config->base, c);
6000bde4:	682b      	ldr	r3, [r5, #0]
    base->DATA = data;
6000bde6:	61dc      	str	r4, [r3, #28]
}
6000bde8:	bd38      	pop	{r3, r4, r5, pc}

6000bdea <mcux_lpuart_poll_in>:
{
6000bdea:	b538      	push	{r3, r4, r5, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000bdec:	6845      	ldr	r5, [r0, #4]
{
6000bdee:	460c      	mov	r4, r1
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000bdf0:	6828      	ldr	r0, [r5, #0]
6000bdf2:	f000 f8ff 	bl	6000bff4 <LPUART_GetStatusFlags>
	if (flags & kLPUART_RxDataRegFullFlag) {
6000bdf6:	0283      	lsls	r3, r0, #10
6000bdf8:	d505      	bpl.n	6000be06 <mcux_lpuart_poll_in+0x1c>
		*c = LPUART_ReadByte(config->base);
6000bdfa:	6828      	ldr	r0, [r5, #0]
6000bdfc:	f7ff ff4d 	bl	6000bc9a <LPUART_ReadByte>
6000be00:	7020      	strb	r0, [r4, #0]
		ret = 0;
6000be02:	2000      	movs	r0, #0
}
6000be04:	bd38      	pop	{r3, r4, r5, pc}
	int ret = -1;
6000be06:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	return ret;
6000be0a:	e7fb      	b.n	6000be04 <mcux_lpuart_poll_in+0x1a>

6000be0c <mcux_lpuart_configure_init>:
{
6000be0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000be10:	6847      	ldr	r7, [r0, #4]
{
6000be12:	b086      	sub	sp, #24
6000be14:	460c      	mov	r4, r1
	struct mcux_lpuart_data *data = dev->data;
6000be16:	6906      	ldr	r6, [r0, #16]
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
6000be18:	e9d7 5801 	ldrd	r5, r8, [r7, #4]
	return z_device_ready(dev) ? 0 : -ENODEV;
6000be1c:	4628      	mov	r0, r5
6000be1e:	f000 f96b 	bl	6000c0f8 <z_device_ready>
6000be22:	b928      	cbnz	r0, 6000be30 <mcux_lpuart_configure_init+0x24>
		return -EINVAL;
6000be24:	f06f 0515 	mvn.w	r5, #21
}
6000be28:	4628      	mov	r0, r5
6000be2a:	b006      	add	sp, #24
6000be2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->api;

	if (api->get_rate == NULL) {
6000be30:	68ab      	ldr	r3, [r5, #8]
6000be32:	68db      	ldr	r3, [r3, #12]
6000be34:	2b00      	cmp	r3, #0
6000be36:	d0f5      	beq.n	6000be24 <mcux_lpuart_configure_init+0x18>
		return -ENOSYS;
	}

	return api->get_rate(dev, sys, rate);
6000be38:	4628      	mov	r0, r5
6000be3a:	466a      	mov	r2, sp
6000be3c:	4641      	mov	r1, r8
6000be3e:	4798      	blx	r3
	if (clock_control_get_rate(config->clock_dev, config->clock_subsys,
6000be40:	4605      	mov	r5, r0
6000be42:	2800      	cmp	r0, #0
6000be44:	d1ee      	bne.n	6000be24 <mcux_lpuart_configure_init+0x18>
	LPUART_GetDefaultConfig(&uart_config);
6000be46:	a801      	add	r0, sp, #4
6000be48:	f000 f887 	bl	6000bf5a <LPUART_GetDefaultConfig>
	switch (cfg->parity) {
6000be4c:	7923      	ldrb	r3, [r4, #4]
6000be4e:	2b01      	cmp	r3, #1
6000be50:	d00e      	beq.n	6000be70 <mcux_lpuart_configure_init+0x64>
6000be52:	2b02      	cmp	r3, #2
6000be54:	d00d      	beq.n	6000be72 <mcux_lpuart_configure_init+0x66>
6000be56:	b113      	cbz	r3, 6000be5e <mcux_lpuart_configure_init+0x52>
		return -ENOTSUP;
6000be58:	f06f 0585 	mvn.w	r5, #133	; 0x85
6000be5c:	e7e4      	b.n	6000be28 <mcux_lpuart_configure_init+0x1c>
		uart_config.parityMode = kLPUART_ParityDisabled;
6000be5e:	f88d 5008 	strb.w	r5, [sp, #8]
	switch (cfg->data_bits) {
6000be62:	79a3      	ldrb	r3, [r4, #6]
6000be64:	2b02      	cmp	r3, #2
6000be66:	d007      	beq.n	6000be78 <mcux_lpuart_configure_init+0x6c>
6000be68:	2b03      	cmp	r3, #3
6000be6a:	d1f5      	bne.n	6000be58 <mcux_lpuart_configure_init+0x4c>
		uart_config.dataBitsCount  = kLPUART_EightDataBits;
6000be6c:	2300      	movs	r3, #0
6000be6e:	e004      	b.n	6000be7a <mcux_lpuart_configure_init+0x6e>
		uart_config.parityMode = kLPUART_ParityOdd;
6000be70:	2303      	movs	r3, #3
		uart_config.parityMode = kLPUART_ParityEven;
6000be72:	f88d 3008 	strb.w	r3, [sp, #8]
		break;
6000be76:	e7f4      	b.n	6000be62 <mcux_lpuart_configure_init+0x56>
		uart_config.dataBitsCount  = kLPUART_SevenDataBits;
6000be78:	2301      	movs	r3, #1
		uart_config.dataBitsCount  = kLPUART_EightDataBits;
6000be7a:	f88d 3009 	strb.w	r3, [sp, #9]
	switch (cfg->stop_bits) {
6000be7e:	7963      	ldrb	r3, [r4, #5]
6000be80:	2b01      	cmp	r3, #1
6000be82:	d003      	beq.n	6000be8c <mcux_lpuart_configure_init+0x80>
6000be84:	2b03      	cmp	r3, #3
6000be86:	d1e7      	bne.n	6000be58 <mcux_lpuart_configure_init+0x4c>
		uart_config.stopBitCount = kLPUART_TwoStopBit;
6000be88:	2301      	movs	r3, #1
6000be8a:	e000      	b.n	6000be8e <mcux_lpuart_configure_init+0x82>
		uart_config.stopBitCount = kLPUART_OneStopBit;
6000be8c:	2300      	movs	r3, #0
		uart_config.stopBitCount = kLPUART_TwoStopBit;
6000be8e:	f88d 300b 	strb.w	r3, [sp, #11]
	switch (cfg->flow_ctrl) {
6000be92:	79e3      	ldrb	r3, [r4, #7]
6000be94:	b11b      	cbz	r3, 6000be9e <mcux_lpuart_configure_init+0x92>
6000be96:	2b01      	cmp	r3, #1
6000be98:	d1de      	bne.n	6000be58 <mcux_lpuart_configure_init+0x4c>
		uart_config.enableRxRTS = true;
6000be9a:	f240 1301 	movw	r3, #257	; 0x101
6000be9e:	f8ad 300e 	strh.w	r3, [sp, #14]
	LPUART_Init(config->base, &uart_config, clock_freq);
6000bea2:	a901      	add	r1, sp, #4
	uart_config.baudRate_Bps = cfg->baudrate;
6000bea4:	6823      	ldr	r3, [r4, #0]
	LPUART_Init(config->base, &uart_config, clock_freq);
6000bea6:	9a00      	ldr	r2, [sp, #0]
	uart_config.baudRate_Bps = cfg->baudrate;
6000bea8:	9301      	str	r3, [sp, #4]
	uart_config.enableTx = true;
6000beaa:	f240 1301 	movw	r3, #257	; 0x101
	LPUART_Init(config->base, &uart_config, clock_freq);
6000beae:	6838      	ldr	r0, [r7, #0]
	uart_config.enableTx = true;
6000beb0:	f8ad 3014 	strh.w	r3, [sp, #20]
	LPUART_Init(config->base, &uart_config, clock_freq);
6000beb4:	f7fa ffda 	bl	60006e6c <LPUART_Init>
	data->uart_config = *cfg;
6000beb8:	f106 0308 	add.w	r3, r6, #8
6000bebc:	e894 0003 	ldmia.w	r4, {r0, r1}
6000bec0:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
6000bec4:	e7b0      	b.n	6000be28 <mcux_lpuart_configure_init+0x1c>

6000bec6 <mcux_lpuart_err_check>:
{
6000bec6:	b538      	push	{r3, r4, r5, lr}
	const struct mcux_lpuart_config *config = dev->config;
6000bec8:	6845      	ldr	r5, [r0, #4]
	uint32_t flags = LPUART_GetStatusFlags(config->base);
6000beca:	6828      	ldr	r0, [r5, #0]
6000becc:	f000 f892 	bl	6000bff4 <LPUART_GetStatusFlags>
	if (flags & kLPUART_RxOverrunFlag) {
6000bed0:	f3c0 44c0 	ubfx	r4, r0, #19, #1
	if (flags & kLPUART_ParityErrorFlag) {
6000bed4:	03c2      	lsls	r2, r0, #15
	LPUART_ClearStatusFlags(config->base, kLPUART_RxOverrunFlag |
6000bed6:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
		err |= UART_ERROR_PARITY;
6000beda:	bf48      	it	mi
6000bedc:	f044 0402 	orrmi.w	r4, r4, #2
	if (flags & kLPUART_FramingErrorFlag) {
6000bee0:	0383      	lsls	r3, r0, #14
	LPUART_ClearStatusFlags(config->base, kLPUART_RxOverrunFlag |
6000bee2:	6828      	ldr	r0, [r5, #0]
		err |= UART_ERROR_FRAMING;
6000bee4:	bf48      	it	mi
6000bee6:	f044 0404 	orrmi.w	r4, r4, #4
	LPUART_ClearStatusFlags(config->base, kLPUART_RxOverrunFlag |
6000beea:	f7fb f8a9 	bl	60007040 <LPUART_ClearStatusFlags>
}
6000beee:	4620      	mov	r0, r4
6000bef0:	bd38      	pop	{r3, r4, r5, pc}

6000bef2 <mcux_lpuart_config_func_0>:
									\
	LPUART_MCUX_CONFIG_FUNC(n)					\
									\
	LPUART_MCUX_INIT_CFG(n);

DT_INST_FOREACH_STATUS_OKAY(LPUART_MCUX_INIT)
6000bef2:	2200      	movs	r2, #0
6000bef4:	2014      	movs	r0, #20
6000bef6:	b508      	push	{r3, lr}
6000bef8:	4611      	mov	r1, r2
6000befa:	f7fa f8dd 	bl	600060b8 <z_arm_irq_priority_set>
6000befe:	2014      	movs	r0, #20
6000bf00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
6000bf04:	f7fa b8c8 	b.w	60006098 <arch_irq_enable>

6000bf08 <mcux_lpuart_irq_is_pending>:
{
6000bf08:	b538      	push	{r3, r4, r5, lr}
6000bf0a:	4605      	mov	r5, r0
	return (mcux_lpuart_irq_tx_ready(dev)
6000bf0c:	f7ff ff1e 	bl	6000bd4c <mcux_lpuart_irq_tx_ready>
		|| mcux_lpuart_irq_rx_pending(dev));
6000bf10:	4604      	mov	r4, r0
6000bf12:	b968      	cbnz	r0, 6000bf30 <mcux_lpuart_irq_is_pending+0x28>
	return (LPUART_GetEnabledInterrupts(config->base) & mask)
6000bf14:	686b      	ldr	r3, [r5, #4]
6000bf16:	6818      	ldr	r0, [r3, #0]
6000bf18:	f000 f859 	bl	6000bfce <LPUART_GetEnabledInterrupts>
		&& mcux_lpuart_irq_rx_full(dev);
6000bf1c:	0283      	lsls	r3, r0, #10
6000bf1e:	d505      	bpl.n	6000bf2c <mcux_lpuart_irq_is_pending+0x24>
6000bf20:	4628      	mov	r0, r5
6000bf22:	f7ff ff03 	bl	6000bd2c <mcux_lpuart_irq_rx_full>
6000bf26:	1e04      	subs	r4, r0, #0
6000bf28:	bf18      	it	ne
6000bf2a:	2401      	movne	r4, #1
}
6000bf2c:	4620      	mov	r0, r4
6000bf2e:	bd38      	pop	{r3, r4, r5, pc}
		|| mcux_lpuart_irq_rx_pending(dev));
6000bf30:	2401      	movs	r4, #1
6000bf32:	e7fb      	b.n	6000bf2c <mcux_lpuart_irq_is_pending+0x24>

6000bf34 <mcux_lpuart_configure>:
{
6000bf34:	b538      	push	{r3, r4, r5, lr}
	LPUART_Deinit(config->base);
6000bf36:	6843      	ldr	r3, [r0, #4]
{
6000bf38:	4604      	mov	r4, r0
6000bf3a:	460d      	mov	r5, r1
	LPUART_Deinit(config->base);
6000bf3c:	6818      	ldr	r0, [r3, #0]
6000bf3e:	f7fb f863 	bl	60007008 <LPUART_Deinit>
	int ret = mcux_lpuart_configure_init(dev, cfg);
6000bf42:	4620      	mov	r0, r4
6000bf44:	4629      	mov	r1, r5
6000bf46:	f7ff ff61 	bl	6000be0c <mcux_lpuart_configure_init>
	if (ret) {
6000bf4a:	4604      	mov	r4, r0
6000bf4c:	b918      	cbnz	r0, 6000bf56 <mcux_lpuart_configure+0x22>
	return z_impl_k_sleep(timeout);
6000bf4e:	200a      	movs	r0, #10
6000bf50:	2100      	movs	r1, #0
6000bf52:	f7fc ffad 	bl	60008eb0 <z_impl_k_sleep>
}
6000bf56:	4620      	mov	r0, r4
6000bf58:	bd38      	pop	{r3, r4, r5, pc}

6000bf5a <LPUART_GetDefaultConfig>:
    (void)memset(config, 0, sizeof(*config));
6000bf5a:	2214      	movs	r2, #20
6000bf5c:	2100      	movs	r1, #0
{
6000bf5e:	b510      	push	{r4, lr}
6000bf60:	4604      	mov	r4, r0
    (void)memset(config, 0, sizeof(*config));
6000bf62:	f7ff fd21 	bl	6000b9a8 <memset>
    config->parityMode    = kLPUART_ParityDisabled;
6000bf66:	2300      	movs	r3, #0
6000bf68:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
    config->txCtsSource = kLPUART_CtsSourcePin;
6000bf6c:	e9c4 3302 	strd	r3, r3, [r4, #8]
    config->parityMode    = kLPUART_ParityDisabled;
6000bf70:	e9c4 2300 	strd	r2, r3, [r4]
    config->enableTx     = false;
6000bf74:	8223      	strh	r3, [r4, #16]
}
6000bf76:	bd10      	pop	{r4, pc}

6000bf78 <LPUART_EnableInterrupts>:
    base->BAUD |= ((mask << 8U) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
6000bf78:	020a      	lsls	r2, r1, #8
    mask &= 0xFFFFFF00U;
6000bf7a:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    base->BAUD |= ((mask << 8U) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
6000bf7e:	f402 4340 	and.w	r3, r2, #49152	; 0xc000
                 ((mask << 8U) & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK));
6000bf82:	f402 7240 	and.w	r2, r2, #768	; 0x300
{
6000bf86:	b510      	push	{r4, lr}
    base->BAUD |= ((mask << 8U) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
6000bf88:	6904      	ldr	r4, [r0, #16]
6000bf8a:	4323      	orrs	r3, r4
6000bf8c:	6103      	str	r3, [r0, #16]
    base->FIFO = (base->FIFO & ~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) |
6000bf8e:	6a83      	ldr	r3, [r0, #40]	; 0x28
6000bf90:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
6000bf94:	4313      	orrs	r3, r2
6000bf96:	6283      	str	r3, [r0, #40]	; 0x28
    base->CTRL |= mask;
6000bf98:	6983      	ldr	r3, [r0, #24]
6000bf9a:	4319      	orrs	r1, r3
6000bf9c:	6181      	str	r1, [r0, #24]
}
6000bf9e:	bd10      	pop	{r4, pc}

6000bfa0 <LPUART_DisableInterrupts>:
    base->BAUD &= ~((mask << 8U) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
6000bfa0:	020a      	lsls	r2, r1, #8
6000bfa2:	6903      	ldr	r3, [r0, #16]
    mask &= 0xFFFFFF00U;
6000bfa4:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
{
6000bfa8:	b510      	push	{r4, lr}
    base->BAUD &= ~((mask << 8U) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
6000bfaa:	f402 4440 	and.w	r4, r2, #49152	; 0xc000
                 ~((mask << 8U) & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK));
6000bfae:	f402 7240 	and.w	r2, r2, #768	; 0x300
    base->BAUD &= ~((mask << 8U) & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK));
6000bfb2:	ea23 0304 	bic.w	r3, r3, r4
6000bfb6:	6103      	str	r3, [r0, #16]
    base->FIFO = (base->FIFO & ~(LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) &
6000bfb8:	6a83      	ldr	r3, [r0, #40]	; 0x28
6000bfba:	ea23 0302 	bic.w	r3, r3, r2
6000bfbe:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
6000bfc2:	6283      	str	r3, [r0, #40]	; 0x28
    base->CTRL &= ~mask;
6000bfc4:	6983      	ldr	r3, [r0, #24]
6000bfc6:	ea23 0101 	bic.w	r1, r3, r1
6000bfca:	6181      	str	r1, [r0, #24]
}
6000bfcc:	bd10      	pop	{r4, pc}

6000bfce <LPUART_GetEnabledInterrupts>:
    temp = (base->BAUD & (LPUART_BAUD_LBKDIE_MASK | LPUART_BAUD_RXEDGIE_MASK)) >> 8U;
6000bfce:	6903      	ldr	r3, [r0, #16]
6000bfd0:	0a1b      	lsrs	r3, r3, #8
6000bfd2:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
    temp |= (base->FIFO & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK)) >> 8U;
6000bfd6:	6a83      	ldr	r3, [r0, #40]	; 0x28
    temp |= (uint32_t)(base->CTRL & 0xFF0C000u);
6000bfd8:	6980      	ldr	r0, [r0, #24]
    temp |= (base->FIFO & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK)) >> 8U;
6000bfda:	f3c3 2301 	ubfx	r3, r3, #8, #2
    temp |= (uint32_t)(base->CTRL & 0xFF0C000u);
6000bfde:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
    temp |= (base->FIFO & (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUFE_MASK)) >> 8U;
6000bfe2:	4313      	orrs	r3, r2
    temp |= (uint32_t)(base->CTRL & 0xFF0C000u);
6000bfe4:	f420 2073 	bic.w	r0, r0, #995328	; 0xf3000
6000bfe8:	f420 607f 	bic.w	r0, r0, #4080	; 0xff0
6000bfec:	f020 000f 	bic.w	r0, r0, #15
}
6000bff0:	4318      	orrs	r0, r3
6000bff2:	4770      	bx	lr

6000bff4 <LPUART_GetStatusFlags>:
    temp = base->STAT;
6000bff4:	6942      	ldr	r2, [r0, #20]
    temp |= (base->FIFO &
6000bff6:	6a83      	ldr	r3, [r0, #40]	; 0x28
             (LPUART_FIFO_TXEMPT_MASK | LPUART_FIFO_RXEMPT_MASK | LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK)) >>
6000bff8:	0c1b      	lsrs	r3, r3, #16
6000bffa:	f003 03c3 	and.w	r3, r3, #195	; 0xc3
}
6000bffe:	ea43 0002 	orr.w	r0, r3, r2
6000c002:	4770      	bx	lr

6000c004 <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
6000c004:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
6000c006:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
6000c008:	4293      	cmp	r3, r2
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
6000c00a:	bf9c      	itt	ls
6000c00c:	6880      	ldrls	r0, [r0, #8]
6000c00e:	181b      	addls	r3, r3, r0
    r = RdOff - WrOff - 1u;
6000c010:	3b01      	subs	r3, #1
6000c012:	1a98      	subs	r0, r3, r2
}
6000c014:	4770      	bx	lr

6000c016 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
6000c016:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  Rem = pRing->SizeOfBuffer - WrOff;
6000c01a:	e9d0 9402 	ldrd	r9, r4, [r0, #8]
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
6000c01e:	4605      	mov	r5, r0
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
6000c020:	6840      	ldr	r0, [r0, #4]
  Rem = pRing->SizeOfBuffer - WrOff;
6000c022:	eba9 0804 	sub.w	r8, r9, r4
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
6000c026:	460f      	mov	r7, r1
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
6000c028:	4420      	add	r0, r4
    pRing->WrOff = WrOff + NumBytes;
6000c02a:	4414      	add	r4, r2
  if (Rem > NumBytes) {
6000c02c:	4590      	cmp	r8, r2
6000c02e:	d904      	bls.n	6000c03a <_WriteNoCheck+0x24>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
6000c030:	f7ff fc8f 	bl	6000b952 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
6000c034:	60ec      	str	r4, [r5, #12]
}
6000c036:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    NumBytesAtOnce = NumBytes - Rem;
6000c03a:	eba4 0409 	sub.w	r4, r4, r9
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
6000c03e:	4642      	mov	r2, r8
6000c040:	f7ff fc87 	bl	6000b952 <memcpy>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
6000c044:	eb07 0108 	add.w	r1, r7, r8
6000c048:	4622      	mov	r2, r4
6000c04a:	6868      	ldr	r0, [r5, #4]
6000c04c:	e7f0      	b.n	6000c030 <_WriteNoCheck+0x1a>

6000c04e <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
6000c04e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
6000c052:	4606      	mov	r6, r0
6000c054:	4689      	mov	r9, r1
6000c056:	4617      	mov	r7, r2
  WrOff = pRing->WrOff;
6000c058:	68c5      	ldr	r5, [r0, #12]
  NumBytesWritten = 0u;
6000c05a:	f04f 0800 	mov.w	r8, #0
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
6000c05e:	6934      	ldr	r4, [r6, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
6000c060:	4649      	mov	r1, r9
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
6000c062:	68b3      	ldr	r3, [r6, #8]
    if (RdOff > WrOff) {
6000c064:	42a5      	cmp	r5, r4
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
6000c066:	6870      	ldr	r0, [r6, #4]
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
6000c068:	bf28      	it	cs
6000c06a:	18e4      	addcs	r4, r4, r3
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
6000c06c:	4428      	add	r0, r5
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
6000c06e:	3c01      	subs	r4, #1
6000c070:	1b62      	subs	r2, r4, r5
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
6000c072:	1b5c      	subs	r4, r3, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
6000c074:	42bc      	cmp	r4, r7
6000c076:	bf28      	it	cs
6000c078:	463c      	movcs	r4, r7
6000c07a:	4294      	cmp	r4, r2
6000c07c:	bf28      	it	cs
6000c07e:	4614      	movcs	r4, r2
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
6000c080:	4622      	mov	r2, r4
    WrOff           += NumBytesToWrite;
6000c082:	4425      	add	r5, r4
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
6000c084:	f7ff fc65 	bl	6000b952 <memcpy>
    if (WrOff == pRing->SizeOfBuffer) {
6000c088:	68b3      	ldr	r3, [r6, #8]
    NumBytesWritten += NumBytesToWrite;
6000c08a:	44a0      	add	r8, r4
    pBuffer         += NumBytesToWrite;
6000c08c:	44a1      	add	r9, r4
      WrOff = 0u;
6000c08e:	42ab      	cmp	r3, r5
6000c090:	bf08      	it	eq
6000c092:	2500      	moveq	r5, #0
  } while (NumBytes);
6000c094:	1b3f      	subs	r7, r7, r4
    pRing->WrOff = WrOff;
6000c096:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
6000c098:	d1e1      	bne.n	6000c05e <_WriteBlocking+0x10>
}
6000c09a:	4640      	mov	r0, r8
6000c09c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

6000c0a0 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
6000c0a0:	f7fa bff2 	b.w	60007088 <_DoInit>

6000c0a4 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
6000c0a4:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
6000c0a6:	f7ff fffb 	bl	6000c0a0 <SEGGER_RTT_Init>

	return 0;
}
6000c0aa:	2000      	movs	r0, #0
6000c0ac:	bd08      	pop	{r3, pc}

6000c0ae <_EncodeStr>:
static U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned int Limit) {
6000c0ae:	4613      	mov	r3, r2
6000c0b0:	b530      	push	{r4, r5, lr}
  if (pText != NULL) {
6000c0b2:	b9c9      	cbnz	r1, 6000c0e8 <_EncodeStr+0x3a>
  Len = 0;
6000c0b4:	460a      	mov	r2, r1
    *pPayload++ = Len; 
6000c0b6:	4603      	mov	r3, r0
6000c0b8:	f803 2b01 	strb.w	r2, [r3], #1
  while (n < Len) {
6000c0bc:	1e58      	subs	r0, r3, #1
6000c0be:	188c      	adds	r4, r1, r2
6000c0c0:	42a1      	cmp	r1, r4
6000c0c2:	d113      	bne.n	6000c0ec <_EncodeStr+0x3e>
}
6000c0c4:	1898      	adds	r0, r3, r2
6000c0c6:	bd30      	pop	{r4, r5, pc}
      Len++;
6000c0c8:	3201      	adds	r2, #1
    while(*(pText + Len) != 0) {
6000c0ca:	5c8c      	ldrb	r4, [r1, r2]
6000c0cc:	2c00      	cmp	r4, #0
6000c0ce:	d1fb      	bne.n	6000c0c8 <_EncodeStr+0x1a>
    if (Len > Limit) {
6000c0d0:	429a      	cmp	r2, r3
6000c0d2:	bf28      	it	cs
6000c0d4:	461a      	movcs	r2, r3
  if (Len < 255)  {
6000c0d6:	2afe      	cmp	r2, #254	; 0xfe
6000c0d8:	d9ed      	bls.n	6000c0b6 <_EncodeStr+0x8>
    *pPayload++ = 255;
6000c0da:	23ff      	movs	r3, #255	; 0xff
    *pPayload++ = ((Len >> 8) & 255);
6000c0dc:	0a14      	lsrs	r4, r2, #8
    *pPayload++ = (Len & 255);
6000c0de:	7042      	strb	r2, [r0, #1]
    *pPayload++ = 255;
6000c0e0:	7003      	strb	r3, [r0, #0]
    *pPayload++ = ((Len >> 8) & 255);
6000c0e2:	1cc3      	adds	r3, r0, #3
6000c0e4:	7084      	strb	r4, [r0, #2]
6000c0e6:	e7e9      	b.n	6000c0bc <_EncodeStr+0xe>
  Len = 0;
6000c0e8:	2200      	movs	r2, #0
6000c0ea:	e7ee      	b.n	6000c0ca <_EncodeStr+0x1c>
    *pPayload++ = *pText++;
6000c0ec:	f811 5b01 	ldrb.w	r5, [r1], #1
6000c0f0:	f800 5f01 	strb.w	r5, [r0, #1]!
    n++;
6000c0f4:	e7e4      	b.n	6000c0c0 <_EncodeStr+0x12>

6000c0f6 <z_device_state_init>:
}
6000c0f6:	4770      	bx	lr

6000c0f8 <z_device_ready>:
	if (dev == NULL) {
6000c0f8:	b138      	cbz	r0, 6000c10a <z_device_ready+0x12>
	return dev->state->initialized && (dev->state->init_res == 0U);
6000c0fa:	68c3      	ldr	r3, [r0, #12]
6000c0fc:	8818      	ldrh	r0, [r3, #0]
6000c0fe:	f3c0 0008 	ubfx	r0, r0, #0, #9
6000c102:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
6000c106:	4258      	negs	r0, r3
6000c108:	4158      	adcs	r0, r3
}
6000c10a:	4770      	bx	lr

6000c10c <arch_system_halt>:
6000c10c:	f04f 0210 	mov.w	r2, #16
6000c110:	f3ef 8311 	mrs	r3, BASEPRI
6000c114:	f382 8811 	msr	BASEPRI, r2
6000c118:	f3bf 8f6f 	isb	sy
	for (;;) {
6000c11c:	e7fe      	b.n	6000c11c <arch_system_halt+0x10>

6000c11e <k_mem_slab_init>:
{
6000c11e:	b538      	push	{r3, r4, r5, lr}
	slab->num_used = 0U;
6000c120:	2400      	movs	r4, #0
	slab->buffer = buffer;
6000c122:	6101      	str	r1, [r0, #16]
	slab->num_used = 0U;
6000c124:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
6000c126:	ea41 0402 	orr.w	r4, r1, r2
6000c12a:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
6000c12e:	e9c0 3202 	strd	r3, r2, [r0, #8]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
6000c132:	d111      	bne.n	6000c158 <k_mem_slab_init+0x3a>
	slab->free_list = NULL;
6000c134:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
6000c136:	42a3      	cmp	r3, r4
6000c138:	d108      	bne.n	6000c14c <k_mem_slab_init+0x2e>
}
6000c13a:	2400      	movs	r4, #0
6000c13c:	e9c0 0000 	strd	r0, r0, [r0]
	SYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);
6000c140:	4601      	mov	r1, r0
6000c142:	2054      	movs	r0, #84	; 0x54
6000c144:	f7fb fafa 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
}
6000c148:	4620      	mov	r0, r4
6000c14a:	bd38      	pop	{r3, r4, r5, pc}
		*(char **)p = slab->free_list;
6000c14c:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
6000c14e:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
6000c150:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
6000c152:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
6000c154:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
6000c156:	e7ee      	b.n	6000c136 <k_mem_slab_init+0x18>
		return -EINVAL;
6000c158:	f06f 0415 	mvn.w	r4, #21
6000c15c:	e7f0      	b.n	6000c140 <k_mem_slab_init+0x22>

6000c15e <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
6000c15e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
6000c162:	4604      	mov	r4, r0
6000c164:	460e      	mov	r6, r1
6000c166:	f04f 0310 	mov.w	r3, #16
6000c16a:	f3ef 8711 	mrs	r7, BASEPRI
6000c16e:	f383 8811 	msr	BASEPRI, r3
6000c172:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
6000c176:	4601      	mov	r1, r0
6000c178:	2056      	movs	r0, #86	; 0x56
6000c17a:	f7fb fadf 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
6000c17e:	f8d4 8014 	ldr.w	r8, [r4, #20]
6000c182:	f1b8 0f00 	cmp.w	r8, #0
6000c186:	d115      	bne.n	6000c1b4 <k_mem_slab_free+0x56>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
6000c188:	4620      	mov	r0, r4
6000c18a:	f000 f971 	bl	6000c470 <z_unpend_first_thread>

		if (pending_thread != NULL) {
6000c18e:	4605      	mov	r5, r0
6000c190:	b180      	cbz	r0, 6000c1b4 <k_mem_slab_free+0x56>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);
6000c192:	2055      	movs	r0, #85	; 0x55
6000c194:	f7fb fc66 	bl	60007a64 <SEGGER_SYSVIEW_RecordEndCall>

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
6000c198:	6833      	ldr	r3, [r6, #0]
			z_ready_thread(pending_thread);
6000c19a:	4628      	mov	r0, r5
6000c19c:	f8c5 80b8 	str.w	r8, [r5, #184]	; 0xb8
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
6000c1a0:	61ab      	str	r3, [r5, #24]
6000c1a2:	f000 f900 	bl	6000c3a6 <z_ready_thread>
			z_reschedule(&slab->lock, key);
6000c1a6:	4639      	mov	r1, r7
6000c1a8:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
6000c1ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			z_reschedule(&slab->lock, key);
6000c1b0:	f7fc bd44 	b.w	60008c3c <z_reschedule>
	**(char ***) mem = slab->free_list;
6000c1b4:	6833      	ldr	r3, [r6, #0]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);
6000c1b6:	2055      	movs	r0, #85	; 0x55
	**(char ***) mem = slab->free_list;
6000c1b8:	6962      	ldr	r2, [r4, #20]
6000c1ba:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
6000c1bc:	6833      	ldr	r3, [r6, #0]
6000c1be:	6163      	str	r3, [r4, #20]
	slab->num_used--;
6000c1c0:	69a3      	ldr	r3, [r4, #24]
6000c1c2:	3b01      	subs	r3, #1
6000c1c4:	61a3      	str	r3, [r4, #24]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);
6000c1c6:	f7fb fc4d 	bl	60007a64 <SEGGER_SYSVIEW_RecordEndCall>
	__asm__ volatile(
6000c1ca:	f387 8811 	msr	BASEPRI, r7
6000c1ce:	f3bf 8f6f 	isb	sy
}
6000c1d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

6000c1d6 <k_is_in_isr>:
6000c1d6:	f3ef 8005 	mrs	r0, IPSR
}
6000c1da:	3800      	subs	r0, #0
6000c1dc:	bf18      	it	ne
6000c1de:	2001      	movne	r0, #1
6000c1e0:	4770      	bx	lr

6000c1e2 <k_thread_name_get>:
}
6000c1e2:	3080      	adds	r0, #128	; 0x80
6000c1e4:	4770      	bx	lr

6000c1e6 <z_impl_k_thread_start>:
{
6000c1e6:	b510      	push	{r4, lr}
6000c1e8:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);
6000c1ea:	4601      	mov	r1, r0
6000c1ec:	2065      	movs	r0, #101	; 0x65
6000c1ee:	f7fb faa5 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
	z_sched_start(thread);
6000c1f2:	4620      	mov	r0, r4
}
6000c1f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_sched_start(thread);
6000c1f8:	f7fc bd32 	b.w	60008c60 <z_sched_start>

6000c1fc <z_impl_k_thread_stack_space_get>:
#error "Unsupported configuration for stack analysis"
#endif

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
6000c1fc:	b510      	push	{r4, lr}
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
	size_t size = thread->stack_info.size;
	size_t unused = 0;
6000c1fe:	2300      	movs	r3, #0
	size_t size = thread->stack_info.size;
6000c200:	e9d0 4229 	ldrd	r4, r2, [r0, #164]	; 0xa4
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
6000c204:	4293      	cmp	r3, r2
6000c206:	d102      	bne.n	6000c20e <z_impl_k_thread_stack_space_get+0x12>
	}

	*unused_ptr = unused;

	return 0;
}
6000c208:	2000      	movs	r0, #0
	*unused_ptr = unused;
6000c20a:	600b      	str	r3, [r1, #0]
}
6000c20c:	bd10      	pop	{r4, pc}
		if ((checked_stack[i]) == 0xaaU) {
6000c20e:	5ce0      	ldrb	r0, [r4, r3]
6000c210:	28aa      	cmp	r0, #170	; 0xaa
6000c212:	d1f9      	bne.n	6000c208 <z_impl_k_thread_stack_space_get+0xc>
			unused++;
6000c214:	3301      	adds	r3, #1
	for (size_t i = 0; i < size; i++) {
6000c216:	e7f5      	b.n	6000c204 <z_impl_k_thread_stack_space_get+0x8>

6000c218 <z_thread_mark_switched_in>:

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
void z_thread_mark_switched_in(void)
{
#ifdef CONFIG_TRACING
	SYS_PORT_TRACING_FUNC(k_thread, switched_in);
6000c218:	f7f9 bd30 	b.w	60005c7c <sys_trace_k_thread_switched_in>

6000c21c <z_thread_mark_switched_out>:

	threads_runtime_stats.execution_cycles += diff;
#endif /* CONFIG_THREAD_RUNTIME_STATS */

#ifdef CONFIG_TRACING
	SYS_PORT_TRACING_FUNC(k_thread, switched_out);
6000c21c:	f7ff badd 	b.w	6000b7da <sys_trace_k_thread_switched_out>

6000c220 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
6000c220:	b508      	push	{r3, lr}
	__asm__ volatile(
6000c222:	f04f 0210 	mov.w	r2, #16
6000c226:	f3ef 8311 	mrs	r3, BASEPRI
6000c22a:	f382 8811 	msr	BASEPRI, r2
6000c22e:	f3bf 8f6f 	isb	sy
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
6000c232:	f7f9 ffa7 	bl	60006184 <arch_cpu_idle>
6000c236:	e7f4      	b.n	6000c222 <idle+0x2>

6000c238 <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
6000c238:	4603      	mov	r3, r0
6000c23a:	4608      	mov	r0, r1
6000c23c:	b510      	push	{r4, lr}
6000c23e:	f04f 0210 	mov.w	r2, #16
6000c242:	f3ef 8411 	mrs	r4, BASEPRI
6000c246:	f382 8811 	msr	BASEPRI, r2
6000c24a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);

	if (msgq->used_msgs > 0U) {
6000c24e:	6a1a      	ldr	r2, [r3, #32]
6000c250:	b14a      	cbz	r2, 6000c266 <z_impl_k_msgq_peek+0x2e>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
6000c252:	689a      	ldr	r2, [r3, #8]
6000c254:	6999      	ldr	r1, [r3, #24]
6000c256:	f7ff fb7c 	bl	6000b952 <memcpy>
		result = 0;
6000c25a:	2000      	movs	r0, #0
	__asm__ volatile(
6000c25c:	f384 8811 	msr	BASEPRI, r4
6000c260:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
6000c264:	bd10      	pop	{r4, pc}
		result = -ENOMSG;
6000c266:	f06f 0022 	mvn.w	r0, #34	; 0x22
6000c26a:	e7f7      	b.n	6000c25c <z_impl_k_msgq_peek+0x24>

6000c26c <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
6000c26c:	f990 300e 	ldrsb.w	r3, [r0, #14]
6000c270:	428b      	cmp	r3, r1
6000c272:	d001      	beq.n	6000c278 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
6000c274:	f7fc bc8e 	b.w	60008b94 <z_set_prio>
}
6000c278:	2000      	movs	r0, #0
6000c27a:	4770      	bx	lr

6000c27c <z_impl_k_mutex_init>:
{
6000c27c:	b510      	push	{r4, lr}
	mutex->owner = NULL;
6000c27e:	2400      	movs	r4, #0
{
6000c280:	4601      	mov	r1, r0
	mutex->lock_count = 0U;
6000c282:	e9c0 4402 	strd	r4, r4, [r0, #8]
	SYS_PORT_TRACING_OBJ_INIT(k_mutex, mutex, 0);
6000c286:	4622      	mov	r2, r4
6000c288:	e9c0 0000 	strd	r0, r0, [r0]
6000c28c:	2025      	movs	r0, #37	; 0x25
6000c28e:	f7fb fa79 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>
}
6000c292:	4620      	mov	r0, r4
6000c294:	bd10      	pop	{r4, pc}

6000c296 <z_impl_k_sem_init>:
{
6000c296:	b510      	push	{r4, lr}
6000c298:	4604      	mov	r4, r0
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
6000c29a:	b10a      	cbz	r2, 6000c2a0 <z_impl_k_sem_init+0xa>
6000c29c:	428a      	cmp	r2, r1
6000c29e:	d208      	bcs.n	6000c2b2 <z_impl_k_sem_init+0x1c>
		SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);
6000c2a0:	2028      	movs	r0, #40	; 0x28
6000c2a2:	f06f 0215 	mvn.w	r2, #21
6000c2a6:	4621      	mov	r1, r4
6000c2a8:	f7fb fa6c 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>
		return -EINVAL;
6000c2ac:	f06f 0015 	mvn.w	r0, #21
}
6000c2b0:	bd10      	pop	{r4, pc}
	sem->limit = limit;
6000c2b2:	e9c0 1202 	strd	r1, r2, [r0, #8]
	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);
6000c2b6:	4601      	mov	r1, r0
6000c2b8:	2200      	movs	r2, #0
6000c2ba:	2028      	movs	r0, #40	; 0x28
6000c2bc:	f7fb fa62 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>
	sys_dlist_init(&sem->poll_events);
6000c2c0:	f104 0310 	add.w	r3, r4, #16
	return 0;
6000c2c4:	2000      	movs	r0, #0
6000c2c6:	e9c4 4400 	strd	r4, r4, [r4]
6000c2ca:	e9c4 3304 	strd	r3, r3, [r4, #16]
6000c2ce:	e7ef      	b.n	6000c2b0 <z_impl_k_sem_init+0x1a>

6000c2d0 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
6000c2d0:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
6000c2d4:	6013      	str	r3, [r2, #0]
	next->prev = prev;
6000c2d6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
6000c2d8:	2300      	movs	r3, #0
	node->prev = NULL;
6000c2da:	e9c0 3300 	strd	r3, r3, [r0]
}
6000c2de:	4770      	bx	lr

6000c2e0 <unpend_thread_no_timeout>:
{
6000c2e0:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
6000c2e2:	f7ff fff5 	bl	6000c2d0 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
6000c2e6:	7b43      	ldrb	r3, [r0, #13]
6000c2e8:	f023 0302 	bic.w	r3, r3, #2
6000c2ec:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
6000c2ee:	2300      	movs	r3, #0
6000c2f0:	6083      	str	r3, [r0, #8]
}
6000c2f2:	bd08      	pop	{r3, pc}

6000c2f4 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
6000c2f4:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
6000c2f8:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
6000c2fc:	4283      	cmp	r3, r0
		return b2 - b1;
6000c2fe:	bf14      	ite	ne
6000c300:	1ac0      	subne	r0, r0, r3
	return 0;
6000c302:	2000      	moveq	r0, #0
}
6000c304:	4770      	bx	lr

6000c306 <add_to_waitq_locked>:
{
6000c306:	b538      	push	{r3, r4, r5, lr}
6000c308:	4604      	mov	r4, r0
6000c30a:	460d      	mov	r5, r1
	unready_thread(thread);
6000c30c:	f7fc fb14 	bl	60008938 <unready_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_pend, thread);
6000c310:	2118      	movs	r1, #24
	thread->base.thread_state |= _THREAD_PENDING;
6000c312:	7b63      	ldrb	r3, [r4, #13]
6000c314:	4620      	mov	r0, r4
6000c316:	f043 0302 	orr.w	r3, r3, #2
6000c31a:	7363      	strb	r3, [r4, #13]
6000c31c:	f7fb fc98 	bl	60007c50 <SEGGER_SYSVIEW_OnTaskStopReady>
	if (wait_q != NULL) {
6000c320:	b195      	cbz	r5, 6000c348 <add_to_waitq_locked+0x42>
	return list->head == list;
6000c322:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
6000c324:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000c326:	429d      	cmp	r5, r3
6000c328:	d015      	beq.n	6000c356 <add_to_waitq_locked+0x50>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
6000c32a:	b1a3      	cbz	r3, 6000c356 <add_to_waitq_locked+0x50>
	int32_t b1 = thread_1->base.prio;
6000c32c:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
6000c330:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
6000c334:	4291      	cmp	r1, r2
6000c336:	d008      	beq.n	6000c34a <add_to_waitq_locked+0x44>
		return b2 - b1;
6000c338:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
6000c33a:	2a00      	cmp	r2, #0
6000c33c:	dd05      	ble.n	6000c34a <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
6000c33e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
6000c340:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
6000c344:	6014      	str	r4, [r2, #0]
	successor->prev = node;
6000c346:	605c      	str	r4, [r3, #4]
}
6000c348:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
6000c34a:	686a      	ldr	r2, [r5, #4]
6000c34c:	4293      	cmp	r3, r2
6000c34e:	d002      	beq.n	6000c356 <add_to_waitq_locked+0x50>
6000c350:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
6000c352:	2b00      	cmp	r3, #0
6000c354:	d1ec      	bne.n	6000c330 <add_to_waitq_locked+0x2a>
	sys_dnode_t *const tail = list->tail;
6000c356:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
6000c358:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
6000c35c:	601c      	str	r4, [r3, #0]
	list->tail = node;
6000c35e:	606c      	str	r4, [r5, #4]
}
6000c360:	e7f2      	b.n	6000c348 <add_to_waitq_locked+0x42>

6000c362 <z_thread_timeout>:
{
6000c362:	4601      	mov	r1, r0
6000c364:	b510      	push	{r4, lr}
	__asm__ volatile(
6000c366:	f04f 0310 	mov.w	r3, #16
6000c36a:	f3ef 8411 	mrs	r4, BASEPRI
6000c36e:	f383 8811 	msr	BASEPRI, r3
6000c372:	f3bf 8f6f 	isb	sy
		if (!killed) {
6000c376:	f810 3c13 	ldrb.w	r3, [r0, #-19]
6000c37a:	f013 0f28 	tst.w	r3, #40	; 0x28
6000c37e:	d10d      	bne.n	6000c39c <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
6000c380:	f851 3c18 	ldr.w	r3, [r1, #-24]
	struct k_thread *thread = CONTAINER_OF(timeout,
6000c384:	3820      	subs	r0, #32
			if (thread->base.pended_on != NULL) {
6000c386:	b10b      	cbz	r3, 6000c38c <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
6000c388:	f7ff ffaa 	bl	6000c2e0 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
6000c38c:	f811 3c13 	ldrb.w	r3, [r1, #-19]
6000c390:	f023 0314 	bic.w	r3, r3, #20
6000c394:	f801 3c13 	strb.w	r3, [r1, #-19]
			ready_thread(thread);
6000c398:	f7fc fb46 	bl	60008a28 <ready_thread>
	__asm__ volatile(
6000c39c:	f384 8811 	msr	BASEPRI, r4
6000c3a0:	f3bf 8f6f 	isb	sy
}
6000c3a4:	bd10      	pop	{r4, pc}

6000c3a6 <z_ready_thread>:
{
6000c3a6:	b510      	push	{r4, lr}
	__asm__ volatile(
6000c3a8:	f04f 0310 	mov.w	r3, #16
6000c3ac:	f3ef 8411 	mrs	r4, BASEPRI
6000c3b0:	f383 8811 	msr	BASEPRI, r3
6000c3b4:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
6000c3b8:	f7fc fb36 	bl	60008a28 <ready_thread>
	__asm__ volatile(
6000c3bc:	f384 8811 	msr	BASEPRI, r4
6000c3c0:	f3bf 8f6f 	isb	sy
}
6000c3c4:	bd10      	pop	{r4, pc}

6000c3c6 <z_unpend_thread_no_timeout>:
{
6000c3c6:	b508      	push	{r3, lr}
	__asm__ volatile(
6000c3c8:	f04f 0310 	mov.w	r3, #16
6000c3cc:	f3ef 8111 	mrs	r1, BASEPRI
6000c3d0:	f383 8811 	msr	BASEPRI, r3
6000c3d4:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
6000c3d8:	f7ff ff82 	bl	6000c2e0 <unpend_thread_no_timeout>
	__asm__ volatile(
6000c3dc:	f381 8811 	msr	BASEPRI, r1
6000c3e0:	f3bf 8f6f 	isb	sy
}
6000c3e4:	bd08      	pop	{r3, pc}

6000c3e6 <z_unpend_thread>:
{
6000c3e6:	b510      	push	{r4, lr}
	__asm__ volatile(
6000c3e8:	f04f 0310 	mov.w	r3, #16
6000c3ec:	f3ef 8411 	mrs	r4, BASEPRI
6000c3f0:	f383 8811 	msr	BASEPRI, r3
6000c3f4:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
6000c3f8:	f7ff ff72 	bl	6000c2e0 <unpend_thread_no_timeout>
	__asm__ volatile(
6000c3fc:	f384 8811 	msr	BASEPRI, r4
6000c400:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
6000c404:	3020      	adds	r0, #32
}
6000c406:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
6000c40a:	f000 b867 	b.w	6000c4dc <z_abort_timeout>

6000c40e <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
6000c40e:	4603      	mov	r3, r0
6000c410:	b920      	cbnz	r0, 6000c41c <z_reschedule_irqlock+0xe>
6000c412:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
6000c416:	b90a      	cbnz	r2, 6000c41c <z_reschedule_irqlock+0xe>
6000c418:	f7f9 bddc 	b.w	60005fd4 <arch_swap>
6000c41c:	f383 8811 	msr	BASEPRI, r3
6000c420:	f3bf 8f6f 	isb	sy
}
6000c424:	4770      	bx	lr

6000c426 <z_reschedule_unlocked>:
	__asm__ volatile(
6000c426:	f04f 0310 	mov.w	r3, #16
6000c42a:	f3ef 8011 	mrs	r0, BASEPRI
6000c42e:	f383 8811 	msr	BASEPRI, r3
6000c432:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
6000c436:	f7ff bfea 	b.w	6000c40e <z_reschedule_irqlock>

6000c43a <z_priq_dumb_best>:
{
6000c43a:	4603      	mov	r3, r0
	return list->head == list;
6000c43c:	6800      	ldr	r0, [r0, #0]
}
6000c43e:	4283      	cmp	r3, r0
6000c440:	bf08      	it	eq
6000c442:	2000      	moveq	r0, #0
6000c444:	4770      	bx	lr

6000c446 <z_unpend1_no_timeout>:
{
6000c446:	b510      	push	{r4, lr}
6000c448:	f04f 0310 	mov.w	r3, #16
6000c44c:	f3ef 8411 	mrs	r4, BASEPRI
6000c450:	f383 8811 	msr	BASEPRI, r3
6000c454:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
6000c458:	f7ff ffef 	bl	6000c43a <z_priq_dumb_best>
		if (thread != NULL) {
6000c45c:	4601      	mov	r1, r0
6000c45e:	b108      	cbz	r0, 6000c464 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
6000c460:	f7ff ff3e 	bl	6000c2e0 <unpend_thread_no_timeout>
	__asm__ volatile(
6000c464:	f384 8811 	msr	BASEPRI, r4
6000c468:	f3bf 8f6f 	isb	sy
}
6000c46c:	4608      	mov	r0, r1
6000c46e:	bd10      	pop	{r4, pc}

6000c470 <z_unpend_first_thread>:
{
6000c470:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
6000c472:	f04f 0310 	mov.w	r3, #16
6000c476:	f3ef 8511 	mrs	r5, BASEPRI
6000c47a:	f383 8811 	msr	BASEPRI, r3
6000c47e:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
6000c482:	f7ff ffda 	bl	6000c43a <z_priq_dumb_best>
		if (thread != NULL) {
6000c486:	4604      	mov	r4, r0
6000c488:	b120      	cbz	r0, 6000c494 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
6000c48a:	f7ff ff29 	bl	6000c2e0 <unpend_thread_no_timeout>
6000c48e:	3020      	adds	r0, #32
6000c490:	f000 f824 	bl	6000c4dc <z_abort_timeout>
	__asm__ volatile(
6000c494:	f385 8811 	msr	BASEPRI, r5
6000c498:	f3bf 8f6f 	isb	sy
}
6000c49c:	4620      	mov	r0, r4
6000c49e:	bd38      	pop	{r3, r4, r5, pc}

6000c4a0 <z_sched_wake>:
{
6000c4a0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
6000c4a2:	f04f 0310 	mov.w	r3, #16
6000c4a6:	f3ef 8511 	mrs	r5, BASEPRI
6000c4aa:	f383 8811 	msr	BASEPRI, r3
6000c4ae:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
6000c4b2:	f7ff ffc2 	bl	6000c43a <z_priq_dumb_best>
		if (thread != NULL) {
6000c4b6:	4604      	mov	r4, r0
6000c4b8:	b158      	cbz	r0, 6000c4d2 <z_sched_wake+0x32>
6000c4ba:	f8c0 10b8 	str.w	r1, [r0, #184]	; 0xb8
6000c4be:	6182      	str	r2, [r0, #24]
			unpend_thread_no_timeout(thread);
6000c4c0:	f7ff ff0e 	bl	6000c2e0 <unpend_thread_no_timeout>
6000c4c4:	3020      	adds	r0, #32
6000c4c6:	f000 f809 	bl	6000c4dc <z_abort_timeout>
			ready_thread(thread);
6000c4ca:	4620      	mov	r0, r4
6000c4cc:	f7fc faac 	bl	60008a28 <ready_thread>
			ret = true;
6000c4d0:	2001      	movs	r0, #1
	__asm__ volatile(
6000c4d2:	f385 8811 	msr	BASEPRI, r5
6000c4d6:	f3bf 8f6f 	isb	sy
}
6000c4da:	bd38      	pop	{r3, r4, r5, pc}

6000c4dc <z_abort_timeout>:
{
6000c4dc:	b510      	push	{r4, lr}
	__asm__ volatile(
6000c4de:	f04f 0210 	mov.w	r2, #16
6000c4e2:	f3ef 8411 	mrs	r4, BASEPRI
6000c4e6:	f382 8811 	msr	BASEPRI, r2
6000c4ea:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
6000c4ee:	6803      	ldr	r3, [r0, #0]
6000c4f0:	b13b      	cbz	r3, 6000c502 <z_abort_timeout+0x26>
			remove_timeout(to);
6000c4f2:	f7fc fe45 	bl	60009180 <remove_timeout>
			ret = 0;
6000c4f6:	2000      	movs	r0, #0
	__asm__ volatile(
6000c4f8:	f384 8811 	msr	BASEPRI, r4
6000c4fc:	f3bf 8f6f 	isb	sy
}
6000c500:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
6000c502:	f06f 0015 	mvn.w	r0, #21
6000c506:	e7f7      	b.n	6000c4f8 <z_abort_timeout+0x1c>

6000c508 <z_set_timeout_expiry>:
{
6000c508:	b570      	push	{r4, r5, r6, lr}
6000c50a:	4604      	mov	r4, r0
6000c50c:	460d      	mov	r5, r1
	__asm__ volatile(
6000c50e:	f04f 0310 	mov.w	r3, #16
6000c512:	f3ef 8611 	mrs	r6, BASEPRI
6000c516:	f383 8811 	msr	BASEPRI, r3
6000c51a:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
6000c51e:	f7fc fe07 	bl	60009130 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
6000c522:	2801      	cmp	r0, #1
6000c524:	dd05      	ble.n	6000c532 <z_set_timeout_expiry+0x2a>
6000c526:	42a0      	cmp	r0, r4
6000c528:	db03      	blt.n	6000c532 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
6000c52a:	4629      	mov	r1, r5
6000c52c:	4620      	mov	r0, r4
6000c52e:	f7f9 fcad 	bl	60005e8c <sys_clock_set_timeout>
	__asm__ volatile(
6000c532:	f386 8811 	msr	BASEPRI, r6
6000c536:	f3bf 8f6f 	isb	sy
}
6000c53a:	bd70      	pop	{r4, r5, r6, pc}

6000c53c <sys_clock_tick_get_32>:
{
6000c53c:	b508      	push	{r3, lr}
	return (uint32_t)sys_clock_tick_get();
6000c53e:	f7fc ff0f 	bl	60009360 <sys_clock_tick_get>
}
6000c542:	bd08      	pop	{r3, pc}

6000c544 <z_impl_k_uptime_ticks>:
	return sys_clock_tick_get();
6000c544:	f7fc bf0c 	b.w	60009360 <sys_clock_tick_get>

6000c548 <k_timer_init>:
{
6000c548:	b538      	push	{r3, r4, r5, lr}
	timer->status = 0U;
6000c54a:	2500      	movs	r5, #0
	sys_dlist_init(&w->waitq);
6000c54c:	f100 0318 	add.w	r3, r0, #24
{
6000c550:	4604      	mov	r4, r0
	timer->status = 0U;
6000c552:	6305      	str	r5, [r0, #48]	; 0x30
	timer->stop_fn = stop_fn;
6000c554:	e9c0 1208 	strd	r1, r2, [r0, #32]
	list->tail = (sys_dnode_t *)list;
6000c558:	e9c0 3306 	strd	r3, r3, [r0, #24]
	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);
6000c55c:	4601      	mov	r1, r0
	node->prev = NULL;
6000c55e:	e9c0 5500 	strd	r5, r5, [r0]
6000c562:	2057      	movs	r0, #87	; 0x57
6000c564:	f7fb f8ea 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>
	timer->user_data = NULL;
6000c568:	6365      	str	r5, [r4, #52]	; 0x34
}
6000c56a:	bd38      	pop	{r3, r4, r5, pc}

6000c56c <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
6000c56c:	b510      	push	{r4, lr}
6000c56e:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);
6000c570:	4601      	mov	r1, r0
6000c572:	2059      	movs	r0, #89	; 0x59
6000c574:	f7fb f8e2 	bl	6000773c <SEGGER_SYSVIEW_RecordU32>

	int inactive = z_abort_timeout(&timer->timeout) != 0;
6000c578:	4620      	mov	r0, r4
6000c57a:	f7ff ffaf 	bl	6000c4dc <z_abort_timeout>

	if (inactive) {
6000c57e:	b9b0      	cbnz	r0, 6000c5ae <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
6000c580:	6a63      	ldr	r3, [r4, #36]	; 0x24
6000c582:	b10b      	cbz	r3, 6000c588 <z_impl_k_timer_stop+0x1c>
		timer->stop_fn(timer);
6000c584:	4620      	mov	r0, r4
6000c586:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
6000c588:	f104 0018 	add.w	r0, r4, #24
6000c58c:	f7ff ff5b 	bl	6000c446 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
6000c590:	b168      	cbz	r0, 6000c5ae <z_impl_k_timer_stop+0x42>
			z_ready_thread(pending_thread);
6000c592:	f7ff ff08 	bl	6000c3a6 <z_ready_thread>
	__asm__ volatile(
6000c596:	f04f 0310 	mov.w	r3, #16
6000c59a:	f3ef 8011 	mrs	r0, BASEPRI
6000c59e:	f383 8811 	msr	BASEPRI, r3
6000c5a2:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
6000c5a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
6000c5aa:	f7ff bf30 	b.w	6000c40e <z_reschedule_irqlock>
6000c5ae:	bd10      	pop	{r4, pc}

6000c5b0 <z_impl_k_timer_status_get>:
}
#include <syscalls/k_timer_stop_mrsh.c>
#endif

uint32_t z_impl_k_timer_status_get(struct k_timer *timer)
{
6000c5b0:	4603      	mov	r3, r0
6000c5b2:	f04f 0110 	mov.w	r1, #16
6000c5b6:	f3ef 8211 	mrs	r2, BASEPRI
6000c5ba:	f381 8811 	msr	BASEPRI, r1
6000c5be:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t result = timer->status;

	timer->status = 0U;
6000c5c2:	2100      	movs	r1, #0
	uint32_t result = timer->status;
6000c5c4:	6b00      	ldr	r0, [r0, #48]	; 0x30
	timer->status = 0U;
6000c5c6:	6319      	str	r1, [r3, #48]	; 0x30
	__asm__ volatile(
6000c5c8:	f382 8811 	msr	BASEPRI, r2
6000c5cc:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	return result;
}
6000c5d0:	4770      	bx	lr

6000c5d2 <add_event>:
{
6000c5d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000c5d4:	4617      	mov	r7, r2
6000c5d6:	4604      	mov	r4, r0
6000c5d8:	460d      	mov	r5, r1
	return sys_dlist_is_empty(list) ? NULL : list->tail;
6000c5da:	e9d0 2300 	ldrd	r2, r3, [r0]
6000c5de:	4290      	cmp	r0, r2
6000c5e0:	d105      	bne.n	6000c5ee <add_event+0x1c>
	sys_dnode_t *const tail = list->tail;
6000c5e2:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
6000c5e4:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
6000c5e8:	601d      	str	r5, [r3, #0]
	list->tail = node;
6000c5ea:	6065      	str	r5, [r4, #4]
}
6000c5ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
6000c5ee:	2b00      	cmp	r3, #0
6000c5f0:	d0f7      	beq.n	6000c5e2 <add_event+0x10>
		(z_sched_prio_cmp(poller_thread(pending->poller),
6000c5f2:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
6000c5f4:	b100      	cbz	r0, 6000c5f8 <add_event+0x26>
6000c5f6:	3868      	subs	r0, #104	; 0x68
6000c5f8:	b107      	cbz	r7, 6000c5fc <add_event+0x2a>
6000c5fa:	3f68      	subs	r7, #104	; 0x68
		(z_sched_prio_cmp(poller_thread(pending->poller),
6000c5fc:	4639      	mov	r1, r7
6000c5fe:	f7ff fe79 	bl	6000c2f4 <z_sched_prio_cmp>
	if ((pending == NULL) ||
6000c602:	2800      	cmp	r0, #0
6000c604:	dced      	bgt.n	6000c5e2 <add_event+0x10>
	return list->head == list;
6000c606:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
6000c608:	42b4      	cmp	r4, r6
6000c60a:	d0ea      	beq.n	6000c5e2 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
6000c60c:	2e00      	cmp	r6, #0
6000c60e:	d0e8      	beq.n	6000c5e2 <add_event+0x10>
		if (z_sched_prio_cmp(poller_thread(poller),
6000c610:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
6000c612:	b101      	cbz	r1, 6000c616 <add_event+0x44>
6000c614:	3968      	subs	r1, #104	; 0x68
		if (z_sched_prio_cmp(poller_thread(poller),
6000c616:	4638      	mov	r0, r7
6000c618:	f7ff fe6c 	bl	6000c2f4 <z_sched_prio_cmp>
6000c61c:	2800      	cmp	r0, #0
6000c61e:	dd05      	ble.n	6000c62c <add_event+0x5a>
	sys_dnode_t *const prev = successor->prev;
6000c620:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
6000c622:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
6000c626:	601d      	str	r5, [r3, #0]
	successor->prev = node;
6000c628:	6075      	str	r5, [r6, #4]
			return;
6000c62a:	e7df      	b.n	6000c5ec <add_event+0x1a>
	return (node == list->tail) ? NULL : node->next;
6000c62c:	6863      	ldr	r3, [r4, #4]
6000c62e:	42b3      	cmp	r3, r6
6000c630:	d0d7      	beq.n	6000c5e2 <add_event+0x10>
6000c632:	6836      	ldr	r6, [r6, #0]
6000c634:	e7ea      	b.n	6000c60c <add_event+0x3a>

6000c636 <register_events>:
{
6000c636:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
6000c63a:	2500      	movs	r5, #0
{
6000c63c:	468b      	mov	fp, r1
6000c63e:	4614      	mov	r4, r2
6000c640:	461f      	mov	r7, r3
6000c642:	4682      	mov	sl, r0
	int events_registered = 0;
6000c644:	462e      	mov	r6, r5
	event->poller = NULL;
6000c646:	46a8      	mov	r8, r5
	for (int ii = 0; ii < num_events; ii++) {
6000c648:	455d      	cmp	r5, fp
6000c64a:	db02      	blt.n	6000c652 <register_events+0x1c>
}
6000c64c:	4630      	mov	r0, r6
6000c64e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__asm__ volatile(
6000c652:	f04f 0310 	mov.w	r3, #16
6000c656:	f3ef 8911 	mrs	r9, BASEPRI
6000c65a:	f383 8811 	msr	BASEPRI, r3
6000c65e:	f3bf 8f6f 	isb	sy
	switch (event->type) {
6000c662:	f89a 300d 	ldrb.w	r3, [sl, #13]
6000c666:	f003 031f 	and.w	r3, r3, #31
6000c66a:	3b01      	subs	r3, #1
6000c66c:	2b07      	cmp	r3, #7
6000c66e:	d80f      	bhi.n	6000c690 <register_events+0x5a>
6000c670:	e8df f003 	tbb	[pc, r3]
6000c674:	0a0e041e 	.word	0x0a0e041e
6000c678:	250e0e0e 	.word	0x250e0e0e
		if (k_sem_count_get(event->sem) > 0U) {
6000c67c:	f8da 3010 	ldr.w	r3, [sl, #16]
6000c680:	689b      	ldr	r3, [r3, #8]
6000c682:	b12b      	cbz	r3, 6000c690 <register_events+0x5a>
			*state = K_POLL_STATE_SEM_AVAILABLE;
6000c684:	2302      	movs	r3, #2
6000c686:	e020      	b.n	6000c6ca <register_events+0x94>
		if (!k_queue_is_empty(event->queue)) {
6000c688:	f8da 3010 	ldr.w	r3, [sl, #16]
6000c68c:	681b      	ldr	r3, [r3, #0]
6000c68e:	bb8b      	cbnz	r3, 6000c6f4 <register_events+0xbe>
		} else if (!just_check && poller->is_polling) {
6000c690:	bb47      	cbnz	r7, 6000c6e4 <register_events+0xae>
6000c692:	7823      	ldrb	r3, [r4, #0]
6000c694:	b333      	cbz	r3, 6000c6e4 <register_events+0xae>
	switch (event->type) {
6000c696:	f89a 300d 	ldrb.w	r3, [sl, #13]
6000c69a:	f003 031f 	and.w	r3, r3, #31
6000c69e:	3b01      	subs	r3, #1
6000c6a0:	2b07      	cmp	r3, #7
6000c6a2:	d830      	bhi.n	6000c706 <register_events+0xd0>
6000c6a4:	e8df f003 	tbb	[pc, r3]
6000c6a8:	282f2833 	.word	0x282f2833
6000c6ac:	382f2f2f 	.word	0x382f2f2f
		if (event->signal->signaled != 0U) {
6000c6b0:	f8da 3010 	ldr.w	r3, [sl, #16]
6000c6b4:	689b      	ldr	r3, [r3, #8]
6000c6b6:	2b00      	cmp	r3, #0
6000c6b8:	d0ea      	beq.n	6000c690 <register_events+0x5a>
			*state = K_POLL_STATE_SIGNALED;
6000c6ba:	2301      	movs	r3, #1
6000c6bc:	e005      	b.n	6000c6ca <register_events+0x94>
		if (event->msgq->used_msgs > 0) {
6000c6be:	f8da 3010 	ldr.w	r3, [sl, #16]
6000c6c2:	6a1b      	ldr	r3, [r3, #32]
6000c6c4:	2b00      	cmp	r3, #0
6000c6c6:	d0e3      	beq.n	6000c690 <register_events+0x5a>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
6000c6c8:	2310      	movs	r3, #16
	event->state |= state;
6000c6ca:	f8da 200c 	ldr.w	r2, [sl, #12]
	event->poller = NULL;
6000c6ce:	f8ca 8008 	str.w	r8, [sl, #8]
	event->state |= state;
6000c6d2:	f3c2 3145 	ubfx	r1, r2, #13, #6
6000c6d6:	430b      	orrs	r3, r1
6000c6d8:	f363 3252 	bfi	r2, r3, #13, #6
6000c6dc:	f8ca 200c 	str.w	r2, [sl, #12]
			poller->is_polling = false;
6000c6e0:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
6000c6e4:	f389 8811 	msr	BASEPRI, r9
6000c6e8:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
6000c6ec:	3501      	adds	r5, #1
6000c6ee:	f10a 0a14 	add.w	sl, sl, #20
6000c6f2:	e7a9      	b.n	6000c648 <register_events+0x12>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
6000c6f4:	2304      	movs	r3, #4
6000c6f6:	e7e8      	b.n	6000c6ca <register_events+0x94>
		add_event(&event->queue->poll_events, event, poller);
6000c6f8:	f8da 0010 	ldr.w	r0, [sl, #16]
6000c6fc:	4622      	mov	r2, r4
6000c6fe:	4651      	mov	r1, sl
6000c700:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
6000c702:	f7ff ff66 	bl	6000c5d2 <add_event>
			events_registered += 1;
6000c706:	3601      	adds	r6, #1
	event->poller = poller;
6000c708:	f8ca 4008 	str.w	r4, [sl, #8]
			events_registered += 1;
6000c70c:	e7ea      	b.n	6000c6e4 <register_events+0xae>
		add_event(&event->signal->poll_events, event, poller);
6000c70e:	4622      	mov	r2, r4
6000c710:	4651      	mov	r1, sl
6000c712:	f8da 0010 	ldr.w	r0, [sl, #16]
6000c716:	e7f4      	b.n	6000c702 <register_events+0xcc>
		add_event(&event->msgq->poll_events, event, poller);
6000c718:	f8da 0010 	ldr.w	r0, [sl, #16]
6000c71c:	4622      	mov	r2, r4
6000c71e:	4651      	mov	r1, sl
6000c720:	3024      	adds	r0, #36	; 0x24
6000c722:	e7ee      	b.n	6000c702 <register_events+0xcc>

6000c724 <signal_poll_event>:
{
6000c724:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
6000c728:	6884      	ldr	r4, [r0, #8]
{
6000c72a:	4605      	mov	r5, r0
6000c72c:	460e      	mov	r6, r1
	if (poller != NULL) {
6000c72e:	b144      	cbz	r4, 6000c742 <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
6000c730:	7863      	ldrb	r3, [r4, #1]
6000c732:	2b01      	cmp	r3, #1
6000c734:	d136      	bne.n	6000c7a4 <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
6000c736:	f814 3c5b 	ldrb.w	r3, [r4, #-91]
6000c73a:	f013 0302 	ands.w	r3, r3, #2
6000c73e:	d10a      	bne.n	6000c756 <signal_poll_event+0x32>
		poller->is_polling = false;
6000c740:	7023      	strb	r3, [r4, #0]
	event->state |= state;
6000c742:	68eb      	ldr	r3, [r5, #12]
	event->poller = NULL;
6000c744:	2000      	movs	r0, #0
	event->state |= state;
6000c746:	f3c3 3145 	ubfx	r1, r3, #13, #6
	event->poller = NULL;
6000c74a:	60a8      	str	r0, [r5, #8]
	event->state |= state;
6000c74c:	430e      	orrs	r6, r1
6000c74e:	f366 3352 	bfi	r3, r6, #13, #6
6000c752:	60eb      	str	r3, [r5, #12]
	return retcode;
6000c754:	e00b      	b.n	6000c76e <signal_poll_event+0x4a>
	if (z_is_thread_timeout_expired(thread)) {
6000c756:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
6000c75a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
6000c75e:	bf08      	it	eq
6000c760:	f112 0f02 	cmneq.w	r2, #2
6000c764:	d105      	bne.n	6000c772 <signal_poll_event+0x4e>
		poller->is_polling = false;
6000c766:	2300      	movs	r3, #0
		return -EAGAIN;
6000c768:	f06f 000a 	mvn.w	r0, #10
		poller->is_polling = false;
6000c76c:	7023      	strb	r3, [r4, #0]
}
6000c76e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
6000c772:	f1a4 0868 	sub.w	r8, r4, #104	; 0x68
	z_unpend_thread(thread);
6000c776:	4640      	mov	r0, r8
6000c778:	f7ff fe35 	bl	6000c3e6 <z_unpend_thread>
	arch_thread_return_value_set(thread,
6000c77c:	2e08      	cmp	r6, #8
6000c77e:	bf0c      	ite	eq
6000c780:	f06f 0303 	mvneq.w	r3, #3
6000c784:	2300      	movne	r3, #0
6000c786:	6523      	str	r3, [r4, #80]	; 0x50
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
6000c788:	f814 3c5b 	ldrb.w	r3, [r4, #-91]
6000c78c:	06db      	lsls	r3, r3, #27
6000c78e:	d102      	bne.n	6000c796 <signal_poll_event+0x72>
	if (!z_is_thread_ready(thread)) {
6000c790:	f854 7c48 	ldr.w	r7, [r4, #-72]
6000c794:	b10f      	cbz	r7, 6000c79a <signal_poll_event+0x76>
		poller->is_polling = false;
6000c796:	2300      	movs	r3, #0
6000c798:	e7d2      	b.n	6000c740 <signal_poll_event+0x1c>
	z_ready_thread(thread);
6000c79a:	4640      	mov	r0, r8
6000c79c:	f7ff fe03 	bl	6000c3a6 <z_ready_thread>
		poller->is_polling = false;
6000c7a0:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
6000c7a2:	e7ce      	b.n	6000c742 <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
6000c7a4:	2b02      	cmp	r3, #2
6000c7a6:	d1f6      	bne.n	6000c796 <signal_poll_event+0x72>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
6000c7a8:	7823      	ldrb	r3, [r4, #0]
6000c7aa:	2b00      	cmp	r3, #0
6000c7ac:	d0c9      	beq.n	6000c742 <signal_poll_event+0x1e>
6000c7ae:	f854 7c04 	ldr.w	r7, [r4, #-4]
6000c7b2:	2f00      	cmp	r7, #0
6000c7b4:	d0f4      	beq.n	6000c7a0 <signal_poll_event+0x7c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
6000c7b6:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
6000c7ba:	f1a4 0914 	sub.w	r9, r4, #20
6000c7be:	f104 0014 	add.w	r0, r4, #20
6000c7c2:	f7ff fe8b 	bl	6000c4dc <z_abort_timeout>
		k_work_submit_to_queue(work_q, &twork->work);
6000c7c6:	4649      	mov	r1, r9
6000c7c8:	4638      	mov	r0, r7
		twork->poll_result = 0;
6000c7ca:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		k_work_submit_to_queue(work_q, &twork->work);
6000c7ce:	f000 f87c 	bl	6000c8ca <k_work_submit_to_queue>
		poller->is_polling = false;
6000c7d2:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
6000c7d6:	e7b4      	b.n	6000c742 <signal_poll_event+0x1e>

6000c7d8 <clear_event_registrations>:
	while (num_events--) {
6000c7d8:	2314      	movs	r3, #20
{
6000c7da:	b5f0      	push	{r4, r5, r6, r7, lr}
6000c7dc:	fb03 0001 	mla	r0, r3, r1, r0
	event->poller = NULL;
6000c7e0:	2400      	movs	r4, #0
6000c7e2:	2601      	movs	r6, #1
	while (num_events--) {
6000c7e4:	b901      	cbnz	r1, 6000c7e8 <clear_event_registrations+0x10>
}
6000c7e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (event->type) {
6000c7e8:	f810 3c07 	ldrb.w	r3, [r0, #-7]
6000c7ec:	f1a0 0714 	sub.w	r7, r0, #20
	event->poller = NULL;
6000c7f0:	f840 4c0c 	str.w	r4, [r0, #-12]
	switch (event->type) {
6000c7f4:	f003 031f 	and.w	r3, r3, #31
6000c7f8:	2b08      	cmp	r3, #8
6000c7fa:	d80d      	bhi.n	6000c818 <clear_event_registrations+0x40>
6000c7fc:	fa06 f303 	lsl.w	r3, r6, r3
6000c800:	f413 7f8b 	tst.w	r3, #278	; 0x116
6000c804:	d008      	beq.n	6000c818 <clear_event_registrations+0x40>
	return node->next != NULL;
6000c806:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
6000c80a:	b12b      	cbz	r3, 6000c818 <clear_event_registrations+0x40>
	sys_dnode_t *const prev = node->prev;
6000c80c:	f850 5c10 	ldr.w	r5, [r0, #-16]
	prev->next = next;
6000c810:	602b      	str	r3, [r5, #0]
	next->prev = prev;
6000c812:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
6000c814:	e940 4405 	strd	r4, r4, [r0, #-20]
6000c818:	f382 8811 	msr	BASEPRI, r2
6000c81c:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
6000c820:	f04f 0310 	mov.w	r3, #16
6000c824:	f3ef 8211 	mrs	r2, BASEPRI
6000c828:	f383 8811 	msr	BASEPRI, r3
6000c82c:	f3bf 8f6f 	isb	sy
6000c830:	3901      	subs	r1, #1
6000c832:	4638      	mov	r0, r7
6000c834:	e7d6      	b.n	6000c7e4 <clear_event_registrations+0xc>

6000c836 <k_poll_event_init>:
	event->type = type;
6000c836:	04d2      	lsls	r2, r2, #19
6000c838:	0209      	lsls	r1, r1, #8
6000c83a:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
6000c83e:	f401 51f8 	and.w	r1, r1, #7936	; 0x1f00
6000c842:	430a      	orrs	r2, r1
6000c844:	7b01      	ldrb	r1, [r0, #12]
{
6000c846:	b510      	push	{r4, lr}
	event->type = type;
6000c848:	430a      	orrs	r2, r1
	event->poller = NULL;
6000c84a:	2400      	movs	r4, #0
	event->obj = obj;
6000c84c:	e9c0 2303 	strd	r2, r3, [r0, #12]
	event->poller = NULL;
6000c850:	6084      	str	r4, [r0, #8]
}
6000c852:	bd10      	pop	{r4, pc}

6000c854 <z_handle_obj_poll_events>:
{
6000c854:	4603      	mov	r3, r0
	return list->head == list;
6000c856:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
6000c858:	4283      	cmp	r3, r0
6000c85a:	d008      	beq.n	6000c86e <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
6000c85c:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
6000c860:	6013      	str	r3, [r2, #0]
	next->prev = prev;
6000c862:	605a      	str	r2, [r3, #4]
	node->next = NULL;
6000c864:	2300      	movs	r3, #0
	node->prev = NULL;
6000c866:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
6000c86a:	f7ff bf5b 	b.w	6000c724 <signal_poll_event>
}
6000c86e:	4770      	bx	lr

6000c870 <z_impl_k_poll_signal_init>:
	sig->signaled = 0U;
6000c870:	2300      	movs	r3, #0
	list->tail = (sys_dnode_t *)list;
6000c872:	e9c0 0000 	strd	r0, r0, [r0]
6000c876:	6083      	str	r3, [r0, #8]
}
6000c878:	4770      	bx	lr

6000c87a <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
6000c87a:	2300      	movs	r3, #0
6000c87c:	6083      	str	r3, [r0, #8]
}
6000c87e:	4770      	bx	lr

6000c880 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
6000c880:	6883      	ldr	r3, [r0, #8]
6000c882:	600b      	str	r3, [r1, #0]
	*result = sig->result;
6000c884:	68c3      	ldr	r3, [r0, #12]
6000c886:	6013      	str	r3, [r2, #0]
}
6000c888:	4770      	bx	lr

6000c88a <k_heap_init>:
6000c88a:	f100 030c 	add.w	r3, r0, #12
{
6000c88e:	b510      	push	{r4, lr}
6000c890:	4604      	mov	r4, r0
6000c892:	e9c0 3303 	strd	r3, r3, [r0, #12]
	sys_heap_init(&h->heap, mem, bytes);
6000c896:	f7fd f8cc 	bl	60009a32 <sys_heap_init>
	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
6000c89a:	4621      	mov	r1, r4
6000c89c:	204c      	movs	r0, #76	; 0x4c
}
6000c89e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
6000c8a2:	f7fa bf4b 	b.w	6000773c <SEGGER_SYSVIEW_RecordU32>

6000c8a6 <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
6000c8a6:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
6000c8a8:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
6000c8aa:	408b      	lsls	r3, r1
6000c8ac:	ea22 0303 	bic.w	r3, r2, r3
6000c8b0:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
6000c8b2:	fa22 f001 	lsr.w	r0, r2, r1
}
6000c8b6:	f000 0001 	and.w	r0, r0, #1
6000c8ba:	4770      	bx	lr

6000c8bc <notify_queue_locked.isra.0>:
	if (queue != NULL) {
6000c8bc:	b120      	cbz	r0, 6000c8c8 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
6000c8be:	2200      	movs	r2, #0
6000c8c0:	30c8      	adds	r0, #200	; 0xc8
6000c8c2:	4611      	mov	r1, r2
6000c8c4:	f7ff bdec 	b.w	6000c4a0 <z_sched_wake>
}
6000c8c8:	4770      	bx	lr

6000c8ca <k_work_submit_to_queue>:
{
6000c8ca:	b537      	push	{r0, r1, r2, r4, r5, lr}
6000c8cc:	460c      	mov	r4, r1
6000c8ce:	9001      	str	r0, [sp, #4]
6000c8d0:	f04f 0310 	mov.w	r3, #16
6000c8d4:	f3ef 8511 	mrs	r5, BASEPRI
6000c8d8:	f383 8811 	msr	BASEPRI, r3
6000c8dc:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, submit_to_queue, queue, work);
6000c8e0:	2084      	movs	r0, #132	; 0x84
6000c8e2:	460a      	mov	r2, r1
6000c8e4:	9901      	ldr	r1, [sp, #4]
6000c8e6:	f7fa ff4d 	bl	60007784 <SEGGER_SYSVIEW_RecordU32x2>
	int ret = submit_to_queue_locked(work, &queue);
6000c8ea:	a901      	add	r1, sp, #4
6000c8ec:	4620      	mov	r0, r4
6000c8ee:	f7fc ff49 	bl	60009784 <submit_to_queue_locked>
6000c8f2:	4604      	mov	r4, r0
	__asm__ volatile(
6000c8f4:	f385 8811 	msr	BASEPRI, r5
6000c8f8:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
6000c8fc:	2800      	cmp	r0, #0
6000c8fe:	dd04      	ble.n	6000c90a <k_work_submit_to_queue+0x40>
	return z_impl_k_is_preempt_thread();
6000c900:	f7fc fb0a 	bl	60008f18 <z_impl_k_is_preempt_thread>
6000c904:	b108      	cbz	r0, 6000c90a <k_work_submit_to_queue+0x40>
	z_impl_k_yield();
6000c906:	f7fc fa41 	bl	60008d8c <z_impl_k_yield>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, submit_to_queue, queue, work, ret);
6000c90a:	4621      	mov	r1, r4
6000c90c:	2084      	movs	r0, #132	; 0x84
6000c90e:	f7fb f8cb 	bl	60007aa8 <SEGGER_SYSVIEW_RecordEndCallU32>
}
6000c912:	4620      	mov	r0, r4
6000c914:	b003      	add	sp, #12
6000c916:	bd30      	pop	{r4, r5, pc}
